<link href="http://kevinburke.bitbucket.org/markdowncss/markdown.css" rel="stylesheet"></link>
<div class="markdown-body">
            <h1><strong>第 1 章　初入 React 世界</strong></h1>
<p>欢迎进入 React 世界。从本章开始，不论你是刚刚入门的前端开发者，还是经验老道的资深工程师，都可以学习到 React 的基本思想以及基本用法。在之后慢慢深入的过程中，各节均会不同程度地带上进阶的实践与分析。希望在本章结束时，我们能够带领你实现应用 React 进行基本的组件开发。请从这里开始你的旅程……</p>
<h2><strong>1.1　React 简介</strong></h2>
<p>React 是 Facebook 在 2013 年开源在 GitHub 上的 JavaScript 库。React 把用户界面抽象成一个个组件，如按钮组件 Button、对话框组件 Dialog、日期组件 Calendar。开发者通过组合这些组件，最终得到功能丰富、可交互的页面。通过引入 JSX 语法，复用组件变得非常容易，同时也能保证组件结构清晰。有了组件这层抽象，React 把代码和真实渲染目标隔离开来，除了可以在浏览器端渲染到 DOM 来开发网页外，还能用于开发原生移动应用。</p>
<h3><strong>1.1.1　专注视图层</strong></h3>
<p>现在的应用已经变得前所未有的复杂，因而开发工具也必须变得越来越强大。和 Angular、Ember 等框架不同，React 并不是完整的 MVC/MVVM 框架，它专注于提供清晰、简洁的 View（视图）层解决方案。而又与模板引擎不同，React 不仅专注于解决 View 层的问题，又是一个包括 View 和 Controller 的库。对于复杂的应用，可以根据应用场景自行选择业务层框架，并根据需要搭配 Flux、Redux、GraphQL/Relay 来使用。</p>
<p>React 不像其他框架那样提供了许多复杂的概念与烦琐的 API，它以 Minimal API Interface 为目标，只提供组件化相关的非常少量的 API。同时为了保持灵活性，它没有自创一套规则，而是尽可能地让用户使用原生 JavaScript 进行开发。只要熟悉原生 JavaScript 并了解重要概念后，就可以很容易上手 React 应用开发。</p>
<h3><strong>1.1.2　Virtual DOM</strong></h3>
<p>真实页面对应一个 DOM 树。在传统页面的开发模式中，每次需要更新页面时，都要手动操作 DOM 来进行更新，如图 1-1 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/03.d01z.001.png" alt="" width="85%" style="width: 85%"></p>
<p><strong>图 1-1　传统 DOM 更新</strong></p>
<p>DOM 操作非常昂贵。我们都知道在前端开发中，性能消耗最大的就是 DOM 操作，而且这部分代码会让整体项目的代码变得难以维护。React 把真实 DOM 树转换成 JavaScript 对象树，也就是 Virtual DOM，如图 1-2 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/03.d01z.002.png" alt="{%}"></p>
<p><strong>图 1-2　React DOM 更新</strong></p>
<p>每次数据更新后，重新计算 Virtual DOM，并和上一次生成的 Virtual DOM 做对比，对发生变化的部分做批量更新。React 也提供了直观的 <code>shouldComponentUpdate</code> 生命周期回调，来减少数据变化后不必要的 Virtual DOM 对比过程，以保证性能。</p>
<p>我们说 Virtual DOM 提升了 React 的性能，但这并不是 React 的唯一亮点。此外，Virtual DOM 的渲染方式也比传统 DOM 操作好一些，但并不明显，因为对比 DOM 节点也是需要计算资源的。</p>
<p>它最大的好处其实还在于方便和其他平台集成，比如 react-native 是基于 Virtual DOM 渲染出原生控件，因为 React 组件可以映射为对应的原生控件。在输出的时候，是输出 Web DOM，还是 Android 控件，还是 iOS 控件，就由平台本身决定了。因此，react-native 有一个口号——Learn Once，Write Anywhere。</p>
<h3><strong>1.1.3　函数式编程</strong></h3>
<p>在过去，工业界的编程方式一直以命令式编程为主。命令式编程解决的是做什么的问题，比如图灵机，而现代计算机就是一个经历了多次进化的高级图灵机。如果说人脑最擅长的是分析问题，那么电脑最擅长的就是执行指令，电脑只需要几条汇编指令就可以轻松算出我们需要很长时间才能解出的运算。命令式编程就像是在给电脑下命令，现在主要的编程语言（包括 C 和 Java 等）都是由命令式编程构建起来的。</p>
<p>而函数式编程，对应的是声明式编程，它是人类模仿自己逻辑思考方式发明出来的。声明式编程的本质是 lambda 演算<span class="注释编号">1</span>。试想当我们操作数组的每个元素并返回一个新数组时，如果是计算机的思考方式，则是需要一个新数组，然后遍历原数组，并计算赋值；如果是人的思考方式，则是构建一个规则，这个过程就变成构建一个 <code>f</code> 函数作用在数组上，然后返回新数组。这样，计算可以被重复利用。</p>
<p class="注释内容"><span class="注释编号下">1</span>lambda calculus，详见 <a href="https://en.wikipedia.org/wiki/Lambda_calculus">https://en.wikipedia.org/wiki/Lambda_calculus</a>。</p>
<p>当回到 UI 界面上，我们的产品经理又想出了一个新点子时，我们是抱怨呢，还是去思考怎么解决这个问题。React 把过去不断重复构建 UI 的过程抽象成了组件，且在给定参数的情况下约定渲染对应的 UI 界面。React 能充分利用很多函数式方法去减少冗余代码。此外，由于它本身就是简单函数，所以易于测试。可以说，函数式编程才是 React 的精髓。</p>
<h2><strong>1.2　JSX 语法</strong></h2>
<p>当初学 React 时，JSX 是我们遇到的第一个新概念。也许我们都是写惯了 JavaScript 程序的开发者，对于类似于静态编译并不感冒。早些年风靡前端界的 CoffeeScript，也因为 ES6 标准化的加速推进，慢慢变为了茶余饭后的谈资。面对 React，我们又一次需要玩转一门新的静态转译语言，而这一次，又会有什么不一样的体验呢。</p>
<h3><strong>1.2.1　JSX 的由来</strong></h3>
<p>JSX 与 React 有什么关系呢？简单来讲，React 为方便 View 层组件化，承载了构建 HTML 结构化页面的职责。从这点上来看，React 与其他 JavaScript 模板语言有着许多异曲同工之处，但不同之处在于 React 是通过创建与更新虚拟元素（virtual element）来管理整个 Virtual DOM 的。</p>
<blockquote>
<p><strong>说明</strong>　JSX 语言的名字最早出现在游戏厂商 DeNA，但和 React 中的 JSX 不同的是，它意在通过加入增强语法，使得 JavaScript 变得更快、更安全、更简单。</p>
</blockquote>
<p>其中，虚拟元素可以理解为真实元素的对应，它的构建与更新都是在内存中完成的，并不会真正渲染到 DOM 中去。在 React 中创建的虚拟元素可以分为两类，DOM 元素（DOM element）与组件元素（component element），分别对应着原生 DOM 元素与自定义元素，而 JSX 与创建元素的过程有着莫大的关联。</p>
<p>接着，我们从这两种元素的构建开始说起。</p>
<p><strong>1. DOM 元素</strong></p>
<p>从过往的经验中知道，Web 页面是由一个个 HTML 元素嵌套组合而成的。当使用 JavaScript 来描述这些元素的时候，这些元素可以简单地被表示成纯粹的 JSON 对象。比如，现在需要描述一个按钮（button），这用 HTML 语法表示非常简单：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;button</span><span class="pln"> </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"btn btn-blue"</span><span class="tag">&gt;</span><span class="pln">
  </span><span class="tag">&lt;em&gt;</span><span class="pln">Confirm</span><span class="tag">&lt;/em&gt;</span><span class="pln">
</span><span class="tag">&lt;/button&gt;</span><span class="pln">
</span></code></pre>
<p>其中包括了元素的类型和属性。如果转成 JSON 对象，那么依然包括元素的类型以及属性：</p>
<pre class="代码无行号 prettyprint"><code><span class="pun">{</span><span class="pln">
  type</span><span class="pun">:</span><span class="pln"> </span><span class="str">'button'</span><span class="pun">,</span><span class="pln">
  props</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    className</span><span class="pun">:</span><span class="pln"> </span><span class="str">'btn btn-blue'</span><span class="pun">,</span><span class="pln">
    children</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[{</span><span class="pln">
      type</span><span class="pun">:</span><span class="pln"> </span><span class="str">'em'</span><span class="pun">,</span><span class="pln">
      props</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        children</span><span class="pun">:</span><span class="pln"> </span><span class="str">'Confirm'</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}]</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>这样，我们就可以在 JavaScript 中创建 Virtual DOM 元素了。</p>
<p>在 React 中，到处都是可以复用的元素，这些元素并不是真实的实例，它只是让 React 告诉开发者想要在屏幕上显示什么。我们无法通过方法去调用这些元素，它们只是不可变的描述对象。</p>
<p><strong>2. 组件元素</strong></p>
<p>当然，我们可以很方便地封装上述 <code>button</code> 元素，得到一种构建按钮的公共方法：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> </span><span class="typ">Button</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">({</span><span class="pln"> color</span><span class="pun">,</span><span class="pln"> text </span><span class="pun">})</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    type</span><span class="pun">:</span><span class="pln"> </span><span class="str">'button'</span><span class="pun">,</span><span class="pln">
    props</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      className</span><span class="pun">:</span><span class="pln"> </span><span class="str">`btn btn-${color}`</span><span class="pun">,</span><span class="pln">
      children</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        type</span><span class="pun">:</span><span class="pln"> </span><span class="str">'em'</span><span class="pun">,</span><span class="pln">
        props</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
          children</span><span class="pun">:</span><span class="pln"> text</span><span class="pun">,</span><span class="pln">
        </span><span class="pun">},</span><span class="pln">
      </span><span class="pun">},</span><span class="pln">
    </span><span class="pun">},</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>自然，当我们要生成 DOM 元素中具体的按钮时，就可以方便地调用 <code>Button({color: 'blue', text: 'Confirm'})</code> 来创建。</p>
<p>仔细思考这个过程可以发现，<code>Button</code> 方法其实也可以作为元素而存在，方法名对应了 DOM 元素类型，参数对应了 DOM 元素属性，那么它就具备了元素的两大必要条件，这样构建的元素就是自定义类型的元素，或称为组件元素。我们用 JSON 结构来描述它：</p>
<pre class="代码无行号 prettyprint"><code><span class="pun">{</span><span class="pln">
  type</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Button</span><span class="pun">,</span><span class="pln">
  props</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    color</span><span class="pun">:</span><span class="pln"> </span><span class="str">'blue'</span><span class="pun">,</span><span class="pln">
    children</span><span class="pun">:</span><span class="pln"> </span><span class="str">'Confirm'</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>这也是 React 的核心思想之一。因为有公共的表达方法，我们就可以让元素们彼此嵌套或混合。这些层层封装的组件元素，就是所谓的 React 组件，最终我们可以用递归渲染的方式构建出完全的 DOM 元素树。</p>
<p>我们再来看一个封装得更深的例子。为上述 Button 元素再封装一次，它由一个方法构建而成：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> </span><span class="typ">DangerButton</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">({</span><span class="pln"> text </span><span class="pun">})</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">({</span><span class="pln">
  type</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Button</span><span class="pun">,</span><span class="pln">
  props</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    color</span><span class="pun">:</span><span class="pln"> </span><span class="str">'red'</span><span class="pun">,</span><span class="pln">
    children</span><span class="pun">:</span><span class="pln"> text
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">});</span><span class="pln">
</span></code></pre>
<p>直观地看，<code>DangerButton</code> 从视觉上为我们定义了“危险的按钮”这样一种新的组件元素。接着，我们可以很轻松地运用它，继续封装新的组件元素：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> </span><span class="typ">DeleteAccount</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">({</span><span class="pln">
  type</span><span class="pun">:</span><span class="pln"> </span><span class="str">'div'</span><span class="pun">,</span><span class="pln">
  props</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    children</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[{</span><span class="pln">
      type</span><span class="pun">:</span><span class="pln"> </span><span class="str">'p'</span><span class="pun">,</span><span class="pln">
      props</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        children</span><span class="pun">:</span><span class="pln"> </span><span class="str">'Are you sure?'</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">},</span><span class="pln">
    </span><span class="pun">},</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      type</span><span class="pun">:</span><span class="pln"> </span><span class="typ">DangerButton</span><span class="pun">,</span><span class="pln">
      props</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        children</span><span class="pun">:</span><span class="pln"> </span><span class="str">'Confirm'</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">},</span><span class="pln">
    </span><span class="pun">},</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      type</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Button</span><span class="pun">,</span><span class="pln">
      props</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        color</span><span class="pun">:</span><span class="pln"> </span><span class="str">'blue'</span><span class="pun">,</span><span class="pln">
        children</span><span class="pun">:</span><span class="pln"> </span><span class="str">'Cancel'</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">},</span><span class="pln">
   </span><span class="pun">}],</span><span class="pln">
 </span><span class="pun">}</span><span class="pln">
</span><span class="pun">});</span><span class="pln">
</span></code></pre>
<p><code>DeleteAccount</code> 清晰地表达了一个功能模块、一段提示语、一个表示确认的警示按钮和一个表示取消的普通按钮。不过在表达还不怎么复杂的结构时，它就力不从心了。这让我们想起使用 HTML 书写结构时的畅快感受，JSX 语法为此应运而生。假如我们使用 JSX 语法来重新表达上述组件元素，只需这么写：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> </span><span class="typ">DeleteAccount</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
  </span><span class="str">&lt;div&gt;</span><span class="pln">
    </span><span class="str">&lt;p&gt;</span><span class="typ">Are</span><span class="pln"> you sure</span><span class="pun">?&lt;/</span><span class="pln">p</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">&lt;</span><span class="typ">DangerButton</span><span class="pun">&gt;</span><span class="typ">Confirm</span><span class="pun">&lt;</span><span class="str">/DangerButton&gt;
    &lt;Button color="blue"&gt;Cancel&lt;/</span><span class="typ">Button</span><span class="pun">&gt;</span><span class="pln">
  </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<blockquote>
<p><strong>注意</strong>　上述 <code>DeleteAccount</code> 并不是真实转换，在实际场景中构建元素会考虑到诸如安全等因素，会由 React 内部方法创建虚拟元素。如果需要自己构建虚拟元素，原理也是一样的。</p>
</blockquote>
<p>如你所见，JSX 将 HTML 语法直接加入到 JavaScript 代码中，再通过翻译器转换到纯 JavaScript 后由浏览器执行。在实际开发中，JSX 在产品打包阶段都已经编译成纯 JavaScript，不会带来任何副作用，反而会让代码更加直观并易于维护。尽管 JSX 是第三方标准，但这套标准适用于任何一套框架。</p>
<p>React 官方在早期为 JSX 语法解析开发了一套编译器 JSTransform，目前已经不再维护，现在已全部采用 Babel 的 JSX 编译器实现。因为两者在功能上完全重复，而 Babel 作为专门的 JavaScript 语法编译工具，提供了更为强大的功能，达到了“一处配置，统一运行”的目的。</p>
<p>我们试着将 DeleteAccount 组件通过 Babel 转译成 React 可以执行的代码：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">var</span><span class="pln"> </span><span class="typ">DeleteAccount</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="typ">DeleteAccount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="pln">createElement</span><span class="pun">(</span><span class="pln">
    </span><span class="str">'div'</span><span class="pun">,</span><span class="pln">
    </span><span class="kwd">null</span><span class="pun">,</span><span class="pln">
    </span><span class="typ">React</span><span class="pun">.</span><span class="pln">createElement</span><span class="pun">(</span><span class="pln">
      </span><span class="str">'p'</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">null</span><span class="pun">,</span><span class="pln">
      </span><span class="str">'Are you sure?'</span><span class="pln">
    </span><span class="pun">),</span><span class="pln">
    </span><span class="typ">React</span><span class="pun">.</span><span class="pln">createElement</span><span class="pun">(</span><span class="pln">
      </span><span class="typ">DangerButton</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">null</span><span class="pun">,</span><span class="pln">
      </span><span class="str">'Confirm'</span><span class="pln">
    </span><span class="pun">),</span><span class="pln">
    </span><span class="typ">React</span><span class="pun">.</span><span class="pln">createElement</span><span class="pun">(</span><span class="pln">
      </span><span class="typ">Button</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">{</span><span class="pln"> color</span><span class="pun">:</span><span class="pln"> </span><span class="str">'blue'</span><span class="pln"> </span><span class="pun">},</span><span class="pln">
      </span><span class="str">'Cancel'</span><span class="pln">
    </span><span class="pun">)</span><span class="pln">
  </span><span class="pun">);</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span></code></pre>
<p>可以看到，除了在创建元素时使用 <code>React.createElement</code> 创建之外，其结构与一直在讲的 JSON 的结构是一致的。</p>
<p>反过来说，JSX 并不是强制选项，我们可以像上述代码那样直接书写而无须编译，但这实在是极其槽糕的编程体验。JSX 的出现为我们省去了这个烦琐过程，使用 JSX 写法的代码更易于阅读与开发。事实上，JSX 并不需要花精力学习。只要你熟悉 HTML 标签，大多数功能就都可以直接使用了。</p>
<h3><strong>1.2.2　JSX 基本语法</strong></h3>
<p>JSX 的官方定义是类 XML 语法的 ECMAScript 扩展。它完美地利用了 JavaScript 自带的语法和特性，并使用大家熟悉的 HTML 语法来创建虚拟元素。可以说，JSX 基本语法基本被 XML 囊括了，但也有少许不同之处。接着我们从基本语法、元素类型、元素属性、JavaScript 属性表达式等维度一一讲述。</p>
<p><strong>1. XML 基本语法</strong></p>
<p>使用类 XML 语法的好处是标签可以任意嵌套，我们可以像 HTML 一样清晰地看到 DOM 树状结构及其属性。比如，我们构造一个 List 组件：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> </span><span class="typ">List</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
  </span><span class="str">&lt;div&gt;</span><span class="pln">
    </span><span class="pun">&lt;</span><span class="typ">Title</span><span class="pun">&gt;</span><span class="typ">This</span><span class="pln"> </span><span class="kwd">is</span><span class="pln"> title</span><span class="pun">&lt;</span><span class="str">/Title&gt;
    &lt;ul&gt;
      &lt;li&gt;list item&lt;/</span><span class="pln">li</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="str">&lt;li&gt;</span><span class="pln">list item</span><span class="pun">&lt;</span><span class="str">/li&gt;
      &lt;li&gt;list item&lt;/</span><span class="pln">li</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">&lt;</span><span class="str">/ul&gt;
  &lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>写 List 的过程就像写 HTML 一样，只不过它被包裹在 JavaScript 的方法中，需要注意以下几点。</p>
<ul>
<li><p><strong>定义标签时，只允许被一个标签包裹</strong>。例如，<code>const component = &lt;span&gt;name&lt;/span&gt;&lt;span&gt; value&lt;/span&gt;</code> 这样写会报错。原因是一个标签会被转译成对应的 <code>React.createElement</code> 调用方法，最外层没有被包裹，显然无法转译成方法调用。</p>
</li>
<li><p><strong>标签一定要闭合</strong>。所有标签（比如 <code>&lt;div&gt;&lt;/div&gt;</code>、<code>&lt;p&gt;&lt;/p&gt;</code>）都必须闭合，否则无法编译通过。其中 HTML 中自闭合的标签（如 <code>&lt;img&gt;</code>）在 JSX 中也遵循同样规则，自定义标签可以根据是否有子组件或文本来决定闭合方式。</p>
</li>
</ul>
<p>当然，JSX 报错机制非常强大，如果有拼写错误时，可以直接在控制台打印出来。</p>
<p><strong>2. 元素类型</strong></p>
<p>在 1.2 节中，我们讲到两种不同的元素：DOM 元素和组件元素。在 JSX 里自然会有对应，对应规则是 HTML 标签首字母是否为小写字母，其中小写首字母对应 DOM 元素，而组件元素自然对应大写首字母。</p>
<p>比如 List 组件中的 <code>&lt;div&gt;</code> 标签会生成 DOM 元素，<code>Title</code> 以大写字母开头，会生成组件元素：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> </span><span class="typ">Title</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">children</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
  </span><span class="str">&lt;h3&gt;</span><span class="pun">{</span><span class="pln">children</span><span class="pun">}&lt;/</span><span class="pln">h3</span><span class="pun">&gt;</span><span class="pln">
</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>等到依赖的组件元素中不再出现组件元素，我们就可以将完整的 DOM 树构建出来了。</p>
<p>JSX 还可以通过命名空间的方式使用组件元素，以解决组件相同名称冲突的问题，或是对一组组件进行归类。比如，我们想使用 Material UI 组件库中的组件，以 <code>MUI</code> 为包名，可以这么写：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
  </span><span class="pun">&lt;</span><span class="pln">MUI</span><span class="pun">.</span><span class="typ">RaisedButton</span><span class="pln"> label</span><span class="pun">=</span><span class="str">"Default"</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>在 HTML 标准中，还有一些特殊的标签值得讨论，比如注释和 <code>DOCTYPE</code> 头。</p>
<ul>
<li><p><strong>注释</strong></p>
<p>在 HTML 中，注释写成 <code>&lt;!-- content --&gt;</code> 这样的形式，但在 JSX 中并没有定义注释的转换方法。事实上，JSX 还是 JavaScript，依然可以用简单的方法使用注释，唯一要注意的是，在一个组件的子元素位置使用注释要用 <code>{}</code> 包起来。示例代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
  </span><span class="pun">&lt;</span><span class="typ">Nav</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">{</span><span class="com">/* 节点注释 */</span><span class="pun">}</span><span class="pln">
    </span><span class="pun">&lt;</span><span class="typ">Person</span><span class="pln">
      </span><span class="com">/* 多行
         注释 */</span><span class="pln">
      name</span><span class="pun">={</span><span class="pln">window</span><span class="pun">.</span><span class="pln">isLoggedIn </span><span class="pun">?</span><span class="pln"> window</span><span class="pun">.</span><span class="pln">name </span><span class="pun">:</span><span class="pln"> </span><span class="str">''</span><span class="pun">}</span><span class="pln">
    </span><span class="pun">/&gt;</span><span class="pln">
  </span><span class="pun">&lt;/</span><span class="typ">Nav</span><span class="pun">&gt;</span><span class="pln">
</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>但 HTML 中有一类特殊的注释——条件注释，它常用于判断浏览器的版本：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">&lt;!--[if IE]&gt;
  &lt;p&gt;Work in IE browser&lt;/p&gt;
&lt;![endif]--&gt;</span><span class="pln">
</span></code></pre>
<p>上述方法可以通过使用 JavaScript 判断浏览器版本来替代：</p>
<pre class="代码无行号 prettyprint"><code><span class="pun">{</span><span class="pln">
  </span><span class="pun">(!!</span><span class="pln">window</span><span class="pun">.</span><span class="typ">ActiveXObject</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> </span><span class="str">'ActiveXObject'</span><span class="pln"> </span><span class="kwd">in</span><span class="pln"> window</span><span class="pun">)</span><span class="pln"> </span><span class="pun">?</span><span class="pln">
  </span><span class="str">&lt;p&gt;</span><span class="typ">Work</span><span class="pln"> </span><span class="kwd">in</span><span class="pln"> IE browser</span><span class="pun">&lt;/</span><span class="pln">p</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="str">''</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>一般来说，条件注释的使用场景是在 <code>&lt;head&gt;</code> 中判断加载对应的脚本或样式。在服务端渲染中，我们还会遇到这样的场景，在 0.14 版本中可以使用 <code>&lt;meta&gt;</code> 标签来实现：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">&lt;meta dangerouslySetInnerHTML={
_html: `
  </span><span class="com">&lt;!--[if IE]&gt;
    &lt;script src="//example.org/app.js"&gt;&lt;/script&gt;
  &lt;![endif]--&gt;</span><span class="pln">
`
} /&gt;
</span></code></pre>
<p>但在 15.0 版本中这已经不可用。因此，还是建议在 JavaScript 里判断浏览器版本，进行一些特有的操作。</p>
</li>
<li><p><strong><code>DOCTYPE</code></strong></p>
<p><code>DOCTYPE</code> 头是一个非常特殊的标志，一般会在使用 React 作为服务端渲染时用到。在 HTML 中，<code>DOCTYPE</code> 是没有闭合的，也就是说我们无法渲染它。</p>
<p>常见的做法是构造一个保存 HTML 的变量，将 <code>DOCTYPE</code> 与整个 HTML 标签渲染后的结果串连起来。第 7 章会详细讲到。</p>
</li>
</ul>
<p><strong>3. 元素属性</strong></p>
<p>元素除了标签之外，另一个组成部分就是标签的属性。</p>
<p>在 JSX 中，不论是 DOM 元素还是组件元素，它们都有属性。不同的是，DOM 元素的属性是标准规范属性，但有两个例外——<code>class</code> 和 <code>for</code>，这是因为在 JavaScript 中这两个单词都是关键词。因此，我们这么转换：</p>
<ul>
<li><p><code>class</code> 属性改为 <code>className</code>；</p>
</li>
<li><p><code>for</code> 属性改为 <code>htmlFor</code>。</p>
</li>
</ul>
<p>而组件元素的属性是完全自定义的属性，也可以理解为实现组件所需要的参数。比如：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> </span><span class="typ">Header</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">({</span><span class="pln">title</span><span class="pun">,</span><span class="pln"> children</span><span class="pun">})</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
  </span><span class="pun">&lt;</span><span class="pln">h3 title</span><span class="pun">={</span><span class="pln">title</span><span class="pun">}&gt;{</span><span class="pln">children</span><span class="pun">}&lt;/</span><span class="pln">h3</span><span class="pun">&gt;</span><span class="pln">
</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>我们给 <code>Header</code> 组件加了一个 <code>title</code> 属性，那么可以这么调用：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;Header</span><span class="pln"> </span><span class="atn">title</span><span class="pun">=</span><span class="atv">"hello world"</span><span class="tag">&gt;</span><span class="pln">Hello world</span><span class="tag">&lt;/Header&gt;</span><span class="pln">
</span></code></pre>
<p>当然，我们可以再给 <code>Header</code> 组件加上 <code>color</code> 等属性。可以看到，<code>Header</code> 和 h3 中两个 <code>title</code> 的不同之处，一个代表的是自定义标签的属性可以传递，一个是标签自带的属性无法传递。值得注意的是，在写自定义属性的时候，都由标准写法改为小驼峰写法。</p>
<p>此外，还有一些 JSX 特有的属性表达。</p>
<ul>
<li><p><strong>Boolean 属性</strong></p>
<p>省略 Boolean 属性值会导致 JSX 认为 <code>bool</code> 值设为了 <code>true</code>。要传 <code>false</code> 时，必须使用属性表达式。这常用于表单元素中，比如 <code>disabled</code>、<code>required</code>、<code>checked</code> 和 <code>readOnly</code> 等。</p>
<p>例如，<code>&lt;Checkbox checked={true} /&gt;</code> 可以简写为 <code>&lt;Checkbox checked /&gt;</code>，反之 <code>&lt;Checkbox checked={false} /&gt;</code> 就可以省略 <code>checked</code> 属性。</p>
</li>
<li><p><strong>展开属性</strong></p>
<p>如果事先知道组件需要的全部属性，JSX 可以这样来写：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> component </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;</span><span class="typ">Component</span><span class="pln"> name</span><span class="pun">={</span><span class="pln">name</span><span class="pun">}</span><span class="pln"> value</span><span class="pun">={</span><span class="pln">value</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;;</span><span class="pln">
</span></code></pre>
<p>如果你不知道要设置哪些 props，那么现在最好不要设置它：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> component </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;</span><span class="typ">Component</span><span class="pln"> </span><span class="pun">/&gt;;</span><span class="pln">
component</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">name </span><span class="pun">=</span><span class="pln"> name</span><span class="pun">;</span><span class="pln">
component</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">value </span><span class="pun">=</span><span class="pln"> value</span><span class="pun">;</span><span class="pln">
</span></code></pre>
<p>上述这样是反模式，因为 React 不能帮你检查属性类型（propTypes）。这样即使组件的属性类型有错误，也不能得到清晰的错误提示。</p>
<p>这里，可以使用 ES6 rest/spread 特性来提高效率：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> data </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> name</span><span class="pun">:</span><span class="pln"> </span><span class="str">'foo'</span><span class="pun">,</span><span class="pln"> value</span><span class="pun">:</span><span class="pln"> </span><span class="str">'bar'</span><span class="pln"> </span><span class="pun">};</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> component </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;</span><span class="typ">Component</span><span class="pln"> name</span><span class="pun">={</span><span class="pln">data</span><span class="pun">.</span><span class="pln">name</span><span class="pun">}</span><span class="pln"> value</span><span class="pun">={</span><span class="pln">data</span><span class="pun">.</span><span class="pln">value</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;;</span><span class="pln">
</span></code></pre>
<p>可以写成：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> data </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> name</span><span class="pun">:</span><span class="pln"> </span><span class="str">'foo'</span><span class="pun">,</span><span class="pln"> value</span><span class="pun">:</span><span class="pln"> </span><span class="str">'bar'</span><span class="pln"> </span><span class="pun">};</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> component </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;</span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{...</span><span class="pln">data</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;;</span></code></pre>
</li>
<li><p><strong>自定义 HTML 属性</strong></p>
<p>如果在 JSX 中往 DOM 元素中传入自定义属性，React 是不会渲染的：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;div</span><span class="pln"> </span><span class="atn">d</span><span class="pun">=</span><span class="atv">"xxx"</span><span class="tag">&gt;</span><span class="pln">content</span><span class="tag">&lt;/div&gt;</span><span class="pln">
</span></code></pre>
<p>如果要使用 HTML 自定义属性，要使用 <code>data-</code> 前缀，这与 HTML 标准也是一致的：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;div</span><span class="pln"> </span><span class="atn">data-attr</span><span class="pun">=</span><span class="atv">"xxx"</span><span class="tag">&gt;</span><span class="pln">content</span><span class="tag">&lt;/div&gt;</span><span class="pln">
</span></code></pre>
<p>然而，在自定义标签中任意的属性都是被支持的：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;x-my-component</span><span class="pln"> </span><span class="atn">custom-attr</span><span class="pun">=</span><span class="atv">"foo"</span><span class="pln"> </span><span class="tag">/&gt;</span><span class="pln">
</span></code></pre>
<p>以 <code>aria-</code> 开头的网络无障碍属性同样可以正常使用：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;div</span><span class="pln"> </span><span class="atn">aria-hidden</span><span class="pun">=</span><span class="atv">{true}</span><span class="tag">&gt;&lt;/div&gt;</span><span class="pln">
</span></code></pre>
<p>不论组件是用什么方法来写，我们都需要知道，组件的最终目的是输出虚拟元素，也就是需要被渲染到界面的结构。其核心渲染方法，或称为组件输出方法，就是 <code>render</code> 方法。它是 React 组件生命周期的一部分，也是最核心的函数之一。1.5 节将详细解释整个生命周期的运作。</p>
</li>
</ul>
<p><strong>4. JavaScript 属性表达式</strong></p>
<p>属性值要使用表达式，只要用 <code>{}</code> 替换 <code>""</code> 即可：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">// 输入（JSX）：</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> person </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;</span><span class="typ">Person</span><span class="pln"> name</span><span class="pun">={</span><span class="pln">window</span><span class="pun">.</span><span class="pln">isLoggedIn </span><span class="pun">?</span><span class="pln"> window</span><span class="pun">.</span><span class="pln">name </span><span class="pun">:</span><span class="pln"> </span><span class="str">''</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;;</span><span class="pln">
</span><span class="com">// 输出（JavaScript）：</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> person </span><span class="pun">=</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="pln">createElement</span><span class="pun">(</span><span class="pln">
  </span><span class="typ">Person</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">{</span><span class="pln">name</span><span class="pun">:</span><span class="pln"> window</span><span class="pun">.</span><span class="pln">isLoggedIn </span><span class="pun">?</span><span class="pln"> window</span><span class="pun">.</span><span class="pln">name </span><span class="pun">:</span><span class="pln"> </span><span class="str">''</span><span class="pun">}</span><span class="pln">
</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>子组件也可以作为表达式使用：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">// 输入（JSX）：</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> content </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;</span><span class="typ">Container</span><span class="pun">&gt;{</span><span class="pln">window</span><span class="pun">.</span><span class="pln">isLoggedIn </span><span class="pun">?</span><span class="pln"> </span><span class="pun">&lt;</span><span class="typ">Nav</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="pun">&lt;</span><span class="typ">Login</span><span class="pln"> </span><span class="pun">/&gt;}&lt;/</span><span class="typ">Container</span><span class="pun">&gt;;</span><span class="pln">
</span><span class="com">// 输出（JavaScript）：</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> content </span><span class="pun">=</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="pln">createElement</span><span class="pun">(</span><span class="pln">
  </span><span class="typ">Container</span><span class="pun">,</span><span class="pln">
  </span><span class="kwd">null</span><span class="pun">,</span><span class="pln">
  window</span><span class="pun">.</span><span class="pln">isLoggedIn </span><span class="pun">?</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="pln">createElement</span><span class="pun">(</span><span class="typ">Nav</span><span class="pun">)</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="pln">createElement</span><span class="pun">(</span><span class="typ">Login</span><span class="pun">)</span><span class="pln">
</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p><strong>5. HTML 转义</strong></p>
<p>React 会将所有要显示到 DOM 的字符串转义，防止 XSS。所以，如果 JSX 中含有转义后的实体字符，比如 <code>&amp;copy;</code>（©），则最后 DOM 中不会正确显示，因为 React 自动把 <code>&amp;copy;</code> 中的特殊字符转义了。有几种解决办法：</p>
<ul>
<li><p>直接使用 UTF-8 字符 ©；</p>
</li>
<li><p>使用对应字符的 Unicode 编码查询编码；</p>
</li>
<li><p>使用数组组装 <code>&lt;div&gt;{['cc ', &lt;span&gt;&amp;copy;&lt;/span&gt;, ' 2015']}&lt;/div&gt;</code>；</p>
</li>
<li><p>直接插入原始的 HTML。</p>
</li>
</ul>
<p>此外，React 提供了 <code>dangerouslySetInnerHTML</code> 属性。正如其名，它的作用就是避免 React 转义字符，在确定必要的情况下可以使用它：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;div</span><span class="pln"> </span><span class="atn">dangerouslySetInnerHTML</span><span class="pun">=</span><span class="atv">{{__html:</span><span class="pln"> </span><span class="atv">'cc &amp;copy; 2015'</span><span class="pln">}} </span><span class="tag">/&gt;</span><span class="pln">
</span></code></pre>
<h2><strong>1.3　React 组件</strong></h2>
<p>终于说到我们最为关心的 React 组件了。在 React 诞生之前，前端界对于组件的封装实现一直都处在摸索和实践的阶段。</p>
<h3><strong>1.3.1　组件的演变</strong></h3>
<p>在 MV* 架构出现之前，组件主要分为两种。</p>
<ul>
<li><p>狭义上的组件，又称为 UI 组件，比如 Tabs 组件、Dropdown 组件。组件主要围绕在交互动作上的抽象，针对这些交互动作，利用 JavaScript 操作 DOM 结构或 style 样式来控制。</p>
</li>
<li><p>广义上的组件，即带有业务含义和数据的 UI 组件组合。这类组件不仅有交互动作，更重要的是有数据与界面之间的交互。然而，这类组件往往有较大的争议。在规模较大的场景下，我们更倾向于采用分层的思想去处理。</p>
</li>
</ul>
<p>以常用的 Tabs 组件为例，对于 UI 组件来说，一定会有 3 个部分组件：结构、样式和交互行为，分别对应着 HTML、CSS 和 JavaScript。一般情况下，我们会先构建组件的基本结构：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;div</span><span class="pln"> </span><span class="atn">id</span><span class="pun">=</span><span class="atv">"tab-demo"</span><span class="tag">&gt;</span><span class="pln">
  </span><span class="tag">&lt;div</span><span class="pln"> </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"tabs-bar"</span><span class="pln"> </span><span class="atn">role</span><span class="pun">=</span><span class="atv">"tablist"</span><span class="tag">&gt;</span><span class="pln">
    </span><span class="tag">&lt;ul</span><span class="pln"> </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"tabs-nav"</span><span class="tag">&gt;</span><span class="pln">
      </span><span class="tag">&lt;li</span><span class="pln"> </span><span class="atn">role</span><span class="pun">=</span><span class="atv">"tab"</span><span class="pln"> </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"tabs-tab"</span><span class="tag">&gt;</span><span class="pln">Tab 1</span><span class="tag">&lt;/li&gt;</span><span class="pln">
      </span><span class="tag">&lt;li</span><span class="pln"> </span><span class="atn">role</span><span class="pun">=</span><span class="atv">"tab"</span><span class="pln"> </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"tabs-tab"</span><span class="tag">&gt;</span><span class="pln">Tab 2</span><span class="tag">&lt;/li&gt;</span><span class="pln">
      </span><span class="tag">&lt;li</span><span class="pln"> </span><span class="atn">role</span><span class="pun">=</span><span class="atv">"tab"</span><span class="pln"> </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"tabs-tab"</span><span class="tag">&gt;</span><span class="pln">Tab 3</span><span class="tag">&lt;/li&gt;</span><span class="pln">
    </span><span class="tag">&lt;/ul&gt;</span><span class="pln">
  </span><span class="tag">&lt;/div&gt;</span><span class="pln">
  </span><span class="tag">&lt;div</span><span class="pln"> </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"tabs-content"</span><span class="tag">&gt;</span><span class="pln">
    </span><span class="tag">&lt;div</span><span class="pln"> </span><span class="atn">role</span><span class="pun">=</span><span class="atv">"tabpanel"</span><span class="pln"> </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"tabs-panel"</span><span class="tag">&gt;</span><span class="pln">
      第一个 Tab 里的内容
    </span><span class="tag">&lt;/div&gt;</span><span class="pln">
    </span><span class="tag">&lt;div</span><span class="pln"> </span><span class="atn">role</span><span class="pun">=</span><span class="atv">"tabpanel"</span><span class="pln"> </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"tabs-panel"</span><span class="tag">&gt;</span><span class="pln">
      第二个 Tab 里的内容
    </span><span class="tag">&lt;/div&gt;</span><span class="pln">
    </span><span class="tag">&lt;div</span><span class="pln"> </span><span class="atn">role</span><span class="pun">=</span><span class="atv">"tabpanel"</span><span class="pln"> </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"tabs-panel"</span><span class="tag">&gt;</span><span class="pln">
      第三个 Tab 里的内容
    </span><span class="tag">&lt;/div&gt;</span><span class="pln">
  </span><span class="tag">&lt;/div&gt;</span><span class="pln">
</span><span class="tag">&lt;/div&gt;</span><span class="pln">
</span></code></pre>
<p>这个结构对我们来说非常熟悉，其中 <code>tabs-bar</code> 中的内容是组件的导航区域，而 <code>tabs-content</code> 中的内容自然就是组件的内容区域。利用 JavaScript 和 CSS 来控制对应索引的导航激活，且显示内容区域。</p>
<p>现在，我们就按照图 1-3 来定义组件的样式。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/03.d01z.003.png" alt="{%}"></p>
<p><strong>图 1-3　组件样式</strong></p>
<p>样式代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">$class</span><span class="pun">-</span><span class="pln">prefix</span><span class="pun">:</span><span class="pln"> </span><span class="str">"tabs"</span><span class="pun">;</span><span class="pln">
</span><span class="pun">.</span><span class="com">#{$class-prefix} {</span><span class="pln">
  </span><span class="pun">&amp;-</span><span class="pln">bar </span><span class="pun">{</span><span class="pln">
    margin</span><span class="pun">-</span><span class="pln">bottom</span><span class="pun">:</span><span class="pln"> </span><span class="lit">16px</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">&amp;-</span><span class="pln">nav </span><span class="pun">{</span><span class="pln">
    font</span><span class="pun">-</span><span class="pln">size</span><span class="pun">:</span><span class="pln"> </span><span class="lit">14px</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">&amp;:</span><span class="pln">after</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">&amp;:</span><span class="pln">before </span><span class="pun">{</span><span class="pln">
      display</span><span class="pun">:</span><span class="pln"> table</span><span class="pun">;</span><span class="pln">
      content</span><span class="pun">:</span><span class="pln"> </span><span class="str">" "</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">&amp;:</span><span class="pln">after </span><span class="pun">{</span><span class="pln">
      clear</span><span class="pun">:</span><span class="pln"> both</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">&amp;-</span><span class="pln">nav </span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">&amp;-</span><span class="pln">tab </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">float</span><span class="pun">:</span><span class="pln"> left</span><span class="pun">;</span><span class="pln">
    list</span><span class="pun">-</span><span class="pln">style</span><span class="pun">:</span><span class="pln"> none</span><span class="pun">;</span><span class="pln">
    margin</span><span class="pun">-</span><span class="pln">right</span><span class="pun">:</span><span class="pln"> </span><span class="lit">24px</span><span class="pun">;</span><span class="pln">
    padding</span><span class="pun">:</span><span class="pln"> </span><span class="lit">8px</span><span class="pln"> </span><span class="lit">20px</span><span class="pun">;</span><span class="pln">
    text</span><span class="pun">-</span><span class="pln">decoration</span><span class="pun">:</span><span class="pln"> none</span><span class="pun">;</span><span class="pln">
    color</span><span class="pun">:</span><span class="pln"> </span><span class="com">#666;</span><span class="pln">
    cursor</span><span class="pun">:</span><span class="pln"> pointer</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">&amp;-</span><span class="pln">nav </span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">&amp;-</span><span class="pln">active </span><span class="pun">{</span><span class="pln">
    border</span><span class="pun">-</span><span class="pln">bottom</span><span class="pun">:</span><span class="pln"> </span><span class="lit">2px</span><span class="pln"> solid </span><span class="com">#00C49F;</span><span class="pln">
    color</span><span class="pun">:</span><span class="pln"> </span><span class="com">#00C49F;</span><span class="pln">
    cursor</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">default</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">&amp;-</span><span class="pln">content </span><span class="pun">&amp;-</span><span class="pln">panel </span><span class="pun">{</span><span class="pln">
    display</span><span class="pun">:</span><span class="pln"> none</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">&amp;-</span><span class="pln">content </span><span class="pun">&amp;-</span><span class="pln">active </span><span class="pun">{</span><span class="pln">
    display</span><span class="pun">:</span><span class="pln"> block</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>这里我们用 SCSS 来定义组件的样式，这样可以方便地定义 class 前缀，以达到定义一系列组件主题的目的。</p>
<p>最后是交互行为。我们引入 jQuery 方便操作 DOM，使用 ES6 classes 语法糖来替换早期利用原型构建面向对象的方法，以及使用 ES6 modules 替换 AMD 模块加载机制：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> $ </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'jquery'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">EventEmitter</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'events'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> </span><span class="typ">Selector</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">classPrefix</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">({</span><span class="pln">
  PREFIX</span><span class="pun">:</span><span class="pln"> classPrefix</span><span class="pun">,</span><span class="pln">
  NAV</span><span class="pun">:</span><span class="pln"> </span><span class="str">`${classPrefix}-nav`</span><span class="pun">,</span><span class="pln">
  CONTENT</span><span class="pun">:</span><span class="pln"> </span><span class="str">`${classPrefix}-content`</span><span class="pun">,</span><span class="pln">
  TAB</span><span class="pun">:</span><span class="pln"> </span><span class="str">`${classPrefix}-tab`</span><span class="pun">,</span><span class="pln">
  PANEL</span><span class="pun">:</span><span class="pln"> </span><span class="str">`${classPrefix}-panel`</span><span class="pun">,</span><span class="pln">
  ACTIVE</span><span class="pun">:</span><span class="pln"> </span><span class="str">`${classPrefix}-active`</span><span class="pun">,</span><span class="pln">
  DISABLE</span><span class="pun">:</span><span class="pln"> </span><span class="str">`${classPrefix}-disable`</span><span class="pun">,</span><span class="pln">
</span><span class="pun">});</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Tabs</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> defaultOptions </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    classPrefix</span><span class="pun">:</span><span class="pln"> </span><span class="str">'tabs'</span><span class="pun">,</span><span class="pln">
    activeIndex</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">options</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">options </span><span class="pun">=</span><span class="pln"> $</span><span class="pun">.</span><span class="pln">extend</span><span class="pun">({},</span><span class="pln"> </span><span class="typ">Tabs</span><span class="pun">.</span><span class="pln">defaultOptions</span><span class="pun">,</span><span class="pln"> options</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">element </span><span class="pun">=</span><span class="pln"> $</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">options</span><span class="pun">.</span><span class="pln">element</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">fromIndex </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">options</span><span class="pun">.</span><span class="pln">activeIndex</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">events </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">EventEmitter</span><span class="pun">();</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">selector </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Selector</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">options</span><span class="pun">.</span><span class="pln">classPrefix</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_initElement</span><span class="pun">();</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_initTabs</span><span class="pun">();</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_initPanels</span><span class="pun">();</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_bindTabs</span><span class="pun">();</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">options</span><span class="pun">.</span><span class="pln">activeIndex </span><span class="pun">!==</span><span class="pln"> </span><span class="kwd">undefined</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">switchTo</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">options</span><span class="pun">.</span><span class="pln">activeIndex</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  _initElement</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">element</span><span class="pun">.</span><span class="pln">addClass</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">selector</span><span class="pun">.</span><span class="pln">PREFIX</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">tabs </span><span class="pun">=</span><span class="pln"> $</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">options</span><span class="pun">.</span><span class="pln">tabs</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">panels </span><span class="pun">=</span><span class="pln"> $</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">options</span><span class="pun">.</span><span class="pln">panels</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">nav </span><span class="pun">=</span><span class="pln"> $</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">options</span><span class="pun">.</span><span class="pln">nav</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">content </span><span class="pun">=</span><span class="pln"> $</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">options</span><span class="pun">.</span><span class="pln">content</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">length </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">tabs</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  _initTabs</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">nav </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">nav</span><span class="pun">.</span><span class="pln">addClass</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">selector</span><span class="pun">.</span><span class="pln">NAV</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">tabs</span><span class="pun">.</span><span class="pln">addClass</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">selector</span><span class="pun">.</span><span class="pln">TAB</span><span class="pun">).</span><span class="pln">each</span><span class="pun">((</span><span class="pln">index</span><span class="pun">,</span><span class="pln"> tab</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      $</span><span class="pun">(</span><span class="pln">tab</span><span class="pun">).</span><span class="pln">data</span><span class="pun">(</span><span class="str">'value'</span><span class="pun">,</span><span class="pln"> index</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  _initPanels</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">content</span><span class="pun">.</span><span class="pln">addClass</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">selector</span><span class="pun">.</span><span class="pln">CONTENT</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">panels</span><span class="pun">.</span><span class="pln">addClass</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">selector</span><span class="pun">.</span><span class="pln">PANEL</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  _bindTabs</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">tabs</span><span class="pun">.</span><span class="pln">click</span><span class="pun">((</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">const</span><span class="pln"> $el </span><span class="pun">=</span><span class="pln"> $</span><span class="pun">(</span><span class="pln">e</span><span class="pun">.</span><span class="pln">target</span><span class="pun">);</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">$el</span><span class="pun">.</span><span class="pln">hasClass</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">selector</span><span class="pun">.</span><span class="pln">DISABLE</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">switchTo</span><span class="pun">(</span><span class="pln">$el</span><span class="pun">.</span><span class="pln">data</span><span class="pun">(</span><span class="str">'value'</span><span class="pun">));</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  events</span><span class="pun">(</span><span class="pln">name</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">events</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  switchTo</span><span class="pun">(</span><span class="pln">toIndex</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_switchTo</span><span class="pun">(</span><span class="pln">toIndex</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  _switchTo</span><span class="pun">(</span><span class="pln">toIndex</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> fromIndex </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">fromIndex</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> panelInfo </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_getPanelInfo</span><span class="pun">(</span><span class="pln">toIndex</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_switchTabs</span><span class="pun">(</span><span class="pln">toIndex</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">_switchPanel</span><span class="pun">(</span><span class="pln">panelInfo</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">events</span><span class="pun">.</span><span class="pln">emit</span><span class="pun">(</span><span class="str">'change'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> toIndex</span><span class="pun">,</span><span class="pln"> fromIndex </span><span class="pun">});</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">fromIndex </span><span class="pun">=</span><span class="pln"> toIndex</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  _switchTabs</span><span class="pun">(</span><span class="pln">toIndex</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> tabs </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">tabs</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> fromIndex </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">fromIndex</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">tabs</span><span class="pun">.</span><span class="pln">length </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
    tabs
      </span><span class="pun">.</span><span class="pln">eq</span><span class="pun">(</span><span class="pln">fromIndex</span><span class="pun">)</span><span class="pln">
      </span><span class="pun">.</span><span class="pln">removeClass</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">selector</span><span class="pun">.</span><span class="pln">ACTIVE</span><span class="pun">)</span><span class="pln">
      </span><span class="pun">.</span><span class="pln">attr</span><span class="pun">(</span><span class="str">'aria-selected'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
    tabs
      </span><span class="pun">.</span><span class="pln">eq</span><span class="pun">(</span><span class="pln">toIndex</span><span class="pun">)</span><span class="pln">
      </span><span class="pun">.</span><span class="pln">addClass</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">selector</span><span class="pun">.</span><span class="pln">ACTIVE</span><span class="pun">)</span><span class="pln">
      </span><span class="pun">.</span><span class="pln">attr</span><span class="pun">(</span><span class="str">'aria-selected'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  _switchPanel</span><span class="pun">(</span><span class="pln">panelInfo</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    panelInfo</span><span class="pun">.</span><span class="pln">fromPanels
      </span><span class="pun">.</span><span class="pln">attr</span><span class="pun">(</span><span class="str">'aria-hidden'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">)</span><span class="pln">
      </span><span class="pun">.</span><span class="pln">hide</span><span class="pun">();</span><span class="pln">
    panelInfo</span><span class="pun">.</span><span class="pln">toPanels
      </span><span class="pun">.</span><span class="pln">attr</span><span class="pun">(</span><span class="str">'aria-hidden'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">)</span><span class="pln">
      </span><span class="pun">.</span><span class="pln">show</span><span class="pun">();</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  _getPanelInfo</span><span class="pun">(</span><span class="pln">toIndex</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> panels </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">panels</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> fromIndex </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">fromIndex</span><span class="pun">;</span><span class="pln">
    let fromPanels</span><span class="pun">,</span><span class="pln"> toPanels</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">fromIndex </span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      fromPanels </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">panels</span><span class="pun">.</span><span class="pln">slice</span><span class="pun">(</span><span class="pln">fromIndex</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln">fromIndex </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">));</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    toPanels </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">panels</span><span class="pun">.</span><span class="pln">slice</span><span class="pun">(</span><span class="pln">toIndex</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln">toIndex </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">));</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      toIndex</span><span class="pun">:</span><span class="pln"> toIndex</span><span class="pun">,</span><span class="pln">
      fromIndex</span><span class="pun">:</span><span class="pln"> fromIndex</span><span class="pun">,</span><span class="pln">
      toPanels</span><span class="pun">:</span><span class="pln"> $</span><span class="pun">(</span><span class="pln">toPanels</span><span class="pun">),</span><span class="pln">
      fromPanels</span><span class="pun">:</span><span class="pln"> $</span><span class="pun">(</span><span class="pln">fromPanels</span><span class="pun">),</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  destroy</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">events</span><span class="pun">.</span><span class="pln">removeAllListeners</span><span class="pun">();</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">export</span><span class="pln"> defaults </span><span class="typ">Tabs</span><span class="pun">;</span><span class="pln">
</span></code></pre>
<p>初始化过程十分简洁，实例化组件并传入必要的几个参数就可以赋予交互：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> tab </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Tabs</span><span class="pun">({</span><span class="pln">
  element</span><span class="pun">:</span><span class="pln"> </span><span class="str">'#tab-demo'</span><span class="pun">,</span><span class="pln">
  tabs</span><span class="pun">:</span><span class="pln"> </span><span class="str">'#tab-demo .tabs-nav li'</span><span class="pun">,</span><span class="pln">
  panels</span><span class="pun">:</span><span class="pln"> </span><span class="str">'#tab-demo .tabs-content div'</span><span class="pun">,</span><span class="pln">
  activeIndex</span><span class="pun">:</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln">
</span><span class="pun">});</span><span class="pln">
tab</span><span class="pun">.</span><span class="pln">events</span><span class="pun">.</span><span class="pln">on</span><span class="pun">(</span><span class="str">'change'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln">o</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">o</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span><span class="pln">
</span></code></pre>
<p>我们看到，组件封装的基本思路就是面向对象思想。交互基本上以操作 DOM 为主，逻辑上是结构上哪里需要变，我们就操作哪里。此外，对于 JavaScript 的结构，我们得到了几项规范标准组件的信息。</p>
<ul>
<li><p><strong>基本的封装性</strong>。尽管说 JavaScript 没有真正面向对象的方法，但我们还是可以通过实例化的方法来制造对象。</p>
</li>
<li><p><strong>简单的生命周期呈现</strong>。最明显的两个方法 <code>constructor</code> 和 <code>destroy</code>，代表了组件的挂载和卸载过程。但除此之外，其他过程（如更新时的生命周期）并没有体现。</p>
</li>
<li><p><strong>明确的数据流动</strong>。这里的数据指的是调用组件的参数。一旦确定参数的值，就会解析传进来的参数，根据参数的不同作出不同的响应，从而得到渲染结果。</p>
</li>
</ul>
<p>在这个阶段，前端在应用级别并没有过多复杂的交互，组件化发展缓慢。传统组件的主要问题在于结构、样式与行为没有很好地结合，不同参数下的逻辑可能会导致不同的渲染逻辑，这时就会存在大量 HTML 结构与 style 样式的拼装。比如，常见的 <code>show</code>、<code>hide</code> 与 <code>toggle</code> 方法，就是通过改变 <code>class</code> 控制 style 来显示或隐藏。这样的逻辑一旦复杂，就存在大量的 DOM 操作，开发及维护成本相当高。</p>
<p>直到富客户端应用越来越多，传统组件化越来越无法满足开发者的需要，于是引进了分层的思想，此时就出现了 MVC 架构。View 只关心怎么输出变量，所以就诞生了各种各样的模板语言，比如 Smarty、Mustache、Handlerbars 等。我们结合 Backbone 这样的架构一起使用。让模板本身可以承载逻辑，可以帮我们解决 View 上的逻辑问题。对于组件来说，可以减轻拼装 HTML 的逻辑部分，将这一部分解耦出去，解决了数据与界面耦合的问题。这时利用模板引擎可以在一定程度上实现组件化，不过这种组件化实现的还是字符串拼接级别的组件化。</p>
<p>对于模板，它更接近 HTML 表达方式，能更好地反映应用的语义结构，且易于从设计、布局和样式上思考，但模板作为一个 DSL，也有其局限性。我们需要重新思考到底什么才是组件的组成。直到这几年萌生的 Angular，我们看到了在 HTML 上定义指令的方式。</p>
<p>W3C 标准委员会最近才将类似的思想制定成了规范，称为 Web Components。顾名思义，这个规范是想统一 Web 端关于组件的定义。它通过定义 Custom Elements（自定义元素）的方式来统一组件。每个自定义元素可以定义自己对外提供的属性、方法，还有事件，内部可以像写一个页面一样，专注于实现功能来完成对组件的封装。</p>
<p>图 1-4 讲述了 Web Components 的 4 个组成部分：HTML Templates 定义了之前模板的概念，Custom Elements 定义了组件的展现形式，Shadow DOM 定义了组件的作用域范围、可以囊括样式，HTML Imports 提出了新的引入方式。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/03.d01z.004.png" alt="{%}"></p>
<p><strong>图 1-4　Web Components 组成</strong></p>
<p>Web Components 定义了一切我们想要的组件化概念，现在还有 polymer 这个库可实现这一套理念，但事实上它还需要时间的考验。因为诸如如何包装在这套规范之上的框架，如何获得在浏览器端的全部支持、怎么与现代应用架构相结合等问题，目前都还没有统一的解法。但 Web Components 的确为组件化开辟了一条罗马大道，告诉了我们组件化可以这样去做。</p>
<p>再说回 React，它的组件化是什么，又是怎么样构建的呢？</p>
<h3><strong>1.3.2　React 组件的构建</strong></h3>
<p>Web Components 通过自定义元素的方式实现组件化，而 React 的本质就是关心元素的构成，React 组件即为组件元素。组件元素被描述成纯粹的 JSON 对象，意味着可以使用方法或是类来构建。React 组件基本上由 3 个部分组成——属性（props）、状态（state）以及生命周期方法。这里我们从一张图来简单概括 React，如图 1-5 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/03.d01z.005.png" alt="{%}"></p>
<p><strong>图 1-5　React 组件的组成</strong></p>
<p>React 组件可以接收参数，也可能有自身状态。一旦接收到的参数或自身状态有所改变，React 组件就会执行相应的生命周期方法，最后渲染。整个过程完全符合传统组件所定义的组件职责。</p>
<p><strong>1. React 与 Web Components</strong></p>
<p>从 React 组件上看，它与 Web Components 传达的理念是一致的，但两者的实现方式不同：</p>
<ul>
<li><p>React 自定义元素是库自己构建的，与 Web Components 规范并不通用；</p>
</li>
<li><p>React 渲染过程包含了模板的概念，即 1.2 节所讲的 JSX；</p>
</li>
<li><p>React 组件的实现均在方法与类中，因此可以做到相互隔离，但不包括样式；</p>
</li>
<li><p>React 引用方式遵循 ES6 module 标准。</p>
</li>
</ul>
<p>可以说，React 还是在纯 JavaScript 上下了工夫，将 HTML 结构彻底引入到 JavaScript 中。尽管这种做法褒贬不一，但也有效解决了组件所要解决的问题之一。</p>
<p><strong>2. React 组件的构建方法</strong></p>
<p>React 组件基本上由组件的构建方式、组件内的属性状态与生命周期方法组成。在本节中，我们先来讨论创建 React 组件的构建方式，而属性状态与生命周期会在后面再介绍。</p>
<p>官方在 React 组件构建上提供了 3 种不同的方法：<code>React.createClass</code>、ES6 classes 和无状态函数（stateless function）。我们使用 1.1 节中的 Button 来分别介绍这 3 种方法。</p>
<ul>
<li><p><strong><code>React.createClass</code></strong></p>
<p>用 <code>React.createClass</code> 构建组件是 React 最传统、也是兼容性最好的方法。在 0.14 版本发布之前，这一直都是 React 官方唯一指定的组件写法。示例代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> </span><span class="typ">Button</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="pln">createClass</span><span class="pun">({</span><span class="pln">
  getDefaultProps</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      color</span><span class="pun">:</span><span class="pln"> </span><span class="str">'blue'</span><span class="pun">,</span><span class="pln">
      text</span><span class="pun">:</span><span class="pln"> </span><span class="str">'Confirm'</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
  </span><span class="pun">},</span><span class="pln">
　
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> color</span><span class="pun">,</span><span class="pln"> text </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
　
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="pln">button className</span><span class="pun">={</span><span class="str">`btn btn-${color}`</span><span class="pun">}&gt;</span><span class="pln">
        </span><span class="str">&lt;em&gt;</span><span class="pun">{</span><span class="pln">text</span><span class="pun">}&lt;/</span><span class="pln">em</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">button</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">});</span><span class="pln">
</span></code></pre>
<p>从表象上看，<code>React.createClass</code> 方法就是构建一个组件对象。当另一个组件需要调用 Button 组件时，只用写成 <code>&lt;Button /&gt;</code>，就可以被解析成 <code>React.createElement(Button)</code> 方法来创建 Button 实例，这意味着在一个应用中调用几次 Button，就会创建几次 Button 实例。</p>
</li>
<li><p><strong>ES6 classes</strong></p>
<p>ES6 classes 的写法是通过 ES6 标准的类语法的方式来构建方法：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
　
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Button</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
　
  </span><span class="kwd">static</span><span class="pln"> defaultProps </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    color</span><span class="pun">:</span><span class="pln"> </span><span class="str">'blue'</span><span class="pun">,</span><span class="pln">
    text</span><span class="pun">:</span><span class="pln"> </span><span class="str">'Confirm'</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
　
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> color</span><span class="pun">,</span><span class="pln"> text </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="pln">button className</span><span class="pun">={</span><span class="str">`btn btn-${color}`</span><span class="pun">}&gt;</span><span class="pln">
        </span><span class="str">&lt;em&gt;</span><span class="pun">{</span><span class="pln">text</span><span class="pun">}&lt;/</span><span class="pln">em</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">button</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>这里的直观感受是从调用内部方法变成了用类来实现。与 <code>createClass</code> 的结果相同的是，调用类实现的组件会创建实例对象。</p>
<p>再说起继承，我们很容易联想到在组件抽象过程中也可以使用继承的思路。如果我们学过面向对象的知识，就知道继承与组合的不同，它们可以用 IS-A 与 HAS-A 来区别。在实际应用 React 的过程中，我们极少让子类去继承功能组件。试想在 UI 层面小的修改就会影响到整体交互或样式，牵一发而动全身，用继承来抽象往往是事倍功半。在 React 组件开发中，常用的方式是将组件拆分到合理的粒度，用组合的方式合成业务组件，也就是 HAS-A 的关系。但在高阶组件构建中，我们可以用反向继承的方法来实现，具体内容请阅读 2.5 节。</p>
<blockquote>
<p><strong>说明</strong>　React 的所有组件都继承自顶层类 <code>React.Component</code>。它的定义非常简洁，只是初始化了 <code>React.Component</code> 方法，声明了 <code>props</code>、<code>context</code>、<code>refs</code> 等，并在原型上定义了 <code>setState</code> 和 <code>forceUpdate</code> 方法。内部初始化的生命周期方法与 <code>createClass</code> 方式使用的是同一个方法创建的。具体解读可参见 3.2.2 节。</p>
</blockquote>
</li>
<li><p><strong>无状态函数</strong></p>
<p>使用无状态函数构建的组件称为无状态组件，这种构建方式是 0.14 版本之后新增的，且官方颇为推崇。示例代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">function</span><span class="pln"> </span><span class="typ">Button</span><span class="pun">({</span><span class="pln"> color </span><span class="pun">=</span><span class="pln"> </span><span class="str">'blue'</span><span class="pun">,</span><span class="pln"> text </span><span class="pun">=</span><span class="pln"> </span><span class="str">'Confirm'</span><span class="pln"> </span><span class="pun">})</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
    </span><span class="pun">&lt;</span><span class="pln">button className</span><span class="pun">={</span><span class="str">`btn btn-${color}`</span><span class="pun">}&gt;</span><span class="pln">
      </span><span class="str">&lt;em&gt;</span><span class="pun">{</span><span class="pln">text</span><span class="pun">}&lt;/</span><span class="pln">em</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">&lt;/</span><span class="pln">button</span><span class="pun">&gt;</span><span class="pln">
  </span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>无状态组件只传入 <code>props</code> 和 <code>context</code> 两个参数；也就是说，它不存在 <code>state</code>，也没有生命周期方法，组件本身即上面两种 React 组件构建方法中的 <code>render</code> 方法。不过，像 <code>propTypes</code> 和 <code>defaultProps</code> 还是可以通过向方法设置静态属性来实现的。</p>
<p>在适合的情况下，我们都应该且必须使用无状态组件。无状态组件不像上述两种方法在调用时会创建新实例，它创建时始终保持了一个实例，避免了不必要的检查和内存分配，做到了内部优化。</p>
</li>
</ul>
<p><strong>3. 用 React 实现 Tabs 组件</strong></p>
<p>这里我们趁热打铁，运用已经掌握的组件构建方法来实现一个组件。首先，用 ES6 classes 的写法来初始化 Tabs 组件的“骨架”：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pun">,</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Tabs</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="com">// ...</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">div className</span><span class="pun">=</span><span class="str">"ui-tabs"</span><span class="pun">&gt;&lt;/</span><span class="pln">div</span><span class="pun">&gt;;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span><span class="kwd">export</span><span class="pln"> defaults </span><span class="typ">Tabs</span><span class="pun">;</span><span class="pln">
</span></code></pre>
<p>从这一节起，我们就以 Tabs 组件为例慢慢介绍 React 组件的主要组成部分，看看它到底有什么不同之处。</p>
<h2><strong>1.4　React 数据流</strong></h2>
<p>在 React 中，数据是自顶向下单向流动的，即从父组件到子组件。这条原则让组件之间的关系变得简单且可预测。</p>
<p>state 与 props 是 React 组件中最重要的概念。如果顶层组件初始化 props，那么 React 会向下遍历整棵组件树，重新尝试渲染所有相关的子组件。而 state 只关心每个组件自己内部的状态，这些状态只能在组件内改变。把组件看成一个函数，那么它接受了 props 作为参数，内部由 state 作为函数的内部参数，返回一个 Virtual DOM 的实现。</p>
<h3><strong>1.4.1　state</strong></h3>
<p>在使用 React 之前，常见的 MVC 框架也非常容易实现交互界面的状态管理，比如 Backbone。它们将 View 中与界面交互的状态解耦，一般将状态放在 Model 中管理。但在 React 没有结合 Flux 或 Redux 框架前，它自身也同样可以管理组件的内部状态。在 React 中，把这类状态统一称为 state。</p>
<p>当组件内部使用库内置的 <code>setState</code> 方法时，最大的表现行为就是该组件会尝试重新渲染。这很好理解，因为我们改变了内部状态，组件需要更新了。比如，我们实现了一个计数器组件：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Counter</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      count</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  handleClick</span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    e</span><span class="pun">.</span><span class="pln">preventDefault</span><span class="pun">();</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
      count</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">count </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="str">&lt;div&gt;</span><span class="pln">
        </span><span class="str">&lt;p&gt;</span><span class="pun">{</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">count</span><span class="pun">}&lt;/</span><span class="pln">p</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">a href</span><span class="pun">=</span><span class="str">"#"</span><span class="pln"> onClick</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick</span><span class="pun">}&gt;更新&lt;/</span><span class="pln">a</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>在 React 中常常在事件处理方法中更新 state，上述例子就是通过点击“更新”按钮不断地更新内部 <code>count</code> 的值，这样就可以把组件内状态封装在实现中。</p>
<p>值得注意的是，<code>setState</code> 是一个异步方法，一个生命周期内所有的 <code>setState</code> 方法会合并操作。关于 <code>setState</code> 的实现原理，请参见 3.4 节。</p>
<p>有了这个特性，让 React 变得充满了想象力。我们完全可以只用 React 来完成对行为的控制、数据的更新和界面的渲染。然而，随着内容的深入，我们并不推荐开发者滥用 state，过多的内部状态会让数据流混乱，程序变得难以维护。</p>
<p>我们再来看 Tabs 组件的 state。从前一节的经验中得到两个可能的内部状态——<code>activeIndex</code> 和 <code>prevIndex</code>，它们分别表示当前选中 tab 的索引和前一次选中 tab 的索引。而需要特别注意的一点是，当前选中的索引亦是组件本身需要的参数之一。</p>
<p>这里我们针对 <code>activeIndex</code> 作为 state，就有两种不同的视角。</p>
<ul>
<li><p><strong><code>activeIndex</code> 在内部更新</strong>。当我们切换 tab 标签时，可以看作是组件内部的交互行为，被选择后通过回调函数返回具体选择的索引。</p>
</li>
<li><p><strong><code>activeIndex</code> 在外部更新</strong>。当我们切换 tab 标签时，可以看作是组件外部在传入具体的索引，而组件就像“木偶”一样被操控着。</p>
</li>
</ul>
<p>这两种情形在 React 组件的设计中非常常见，我们形象地把第一种和第二种视角写成的组件分别称为智能组件（smart component）和木偶组件（dumb component）。</p>
<p>当然，实现组件时，可以同时考虑兼容这两种。我们来看下 Tabs 组件中初始化时的实现部分：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> currProps </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
  let activeIndex </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="str">'activeIndex'</span><span class="pln"> </span><span class="kwd">in</span><span class="pln"> currProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    activeIndex </span><span class="pun">=</span><span class="pln"> currProps</span><span class="pun">.</span><span class="pln">activeIndex</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="str">'defaultActiveIndex'</span><span class="pln"> </span><span class="kwd">in</span><span class="pln"> currProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    activeIndex </span><span class="pun">=</span><span class="pln"> currProps</span><span class="pun">.</span><span class="pln">defaultActiveIndex</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    activeIndex</span><span class="pun">,</span><span class="pln">
    prevIndex</span><span class="pun">:</span><span class="pln"> activeIndex</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>这里我们定义了两种 state——<code>activeIndex</code> 和 <code>prevIndex</code>。</p>
<p>对于 <code>activeIndex</code> 来说，既可能来源于使用内部更新的 <code>defaultActiveIndex</code> prop，即我们不需要外组件控制组件状态，也可能来源于需要外部更新的 <code>activeIndex</code> prop。如图 1-6 所示，我们只能通过切换外组件的状态来更新。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/03.d01z.006.png" alt="" width="90%" style="width: 90%"></p>
<p><strong>图 1-6　切换组件的状态</strong></p>
<p>不过，不论组件是内部更新还是外部更新，我们都需要 <code>activeIndex</code> 这个 state 来更新渲染。那么，如何做到外部更新时让状态更新呢？这个问题会在 1.6 节中详解。</p>
<p>这里，我们反复提到的 props 是不是就是指传入参数呢？继续看下一节。</p>
<h3><strong>1.4.2　props</strong></h3>
<p>props 是 React 中另一个重要的概念，它是 properties 的缩写。props 是 React 用来让组件之间互相联系的一种机制，通俗地说就像方法的参数一样。在 1.2 节中，我们已经接触过它们了。</p>
<p>props 的传递过程，对于 React 组件来说是非常直观的。React 的单向数据流，主要的流动管道就是 props。props 本身是<strong>不可变的</strong>。当我们试图改变 props 的原始值时，React 会报出类型错误的警告，组件的 props 一定来自于默认属性或通过父组件传递而来。如果说要渲染一个对 props 加工后的值，最简单的方法就是使用局部变量或直接在 JSX 中计算结果。</p>
<p>我们在 1.4.1 节中讨论了 Tabs 组件 state 的设置情况。假设 Tabs 组件的数据都是通过 <code>data</code> prop 传入的，即 <code>&lt;Tabs data={data} /&gt;</code>。那么，Tabs 组件的 props 还会有哪些。根据之前的经验，它一定会有以下几项。</p>
<ul>
<li><p><code>className</code>：根节点的 <code>class</code>。为了方便覆盖其原始样式，我们都会在根节点上定义 <code>class</code>，这一点会在 2.3 节中详细说明。</p>
</li>
<li><p><code>classPrefix</code>：<code>class</code> 前缀。对于组件来说，定义一个统一的 <code>class</code> 前缀，对样式与交互分离起了非常重要的作用。</p>
</li>
<li><p><code>defaultActiveIndex</code> 和 <code>activeIndex</code>：默认的激活索引，这在 1.4.1 节中已说明。</p>
</li>
<li><p><code>onChange</code>：回调函数。当我们切换 tab 时，外组件需要知道组件内部的信息，尤其是当前 tab 的索引号的信息。它一般与 <code>activeIndex</code> 搭配使用。</p>
</li>
</ul>
<p>React 为 props 同样提供了默认配置，通过 <code>defaultProps</code> 静态变量的方式来定义。当组件被调用的时候，默认值保证渲染后始终有值。在 <code>render</code> 方法中，可以直接使用 props 的值来渲染。这里，我们只需要默认设置 <code>classPrefix</code> 和 <code>onChange</code> 即可。因为 <code>defaultActiveIndex</code> 和<code>activeIndex</code> 我们需要保持只取其中一个条件。相关代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">static</span><span class="pln"> defaultProps </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  classPrefix</span><span class="pun">:</span><span class="pln"> </span><span class="str">'tabs'</span><span class="pun">,</span><span class="pln">
  onChange</span><span class="pun">:</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{},</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span></code></pre>
<p>但 Tabs 组件的信息全由一个对象传进来的方式真的好么？对于 React 组件来说，我们考虑设计组件一定要满足一大原则——<strong>直观</strong>。把基本设置与数据一起定义成一个数组或对象是初学者最容易犯的一个错误，如果说组件能够分解，那我们一定要分解，并使用子组件的方式来处理。</p>
<p>再一次仔细观察 Tabs 组件在 Web 界面的特征，一般来说，会看到两个区域：切换区域与内容区域。那么，我们就定义两个子组件，其中 TabNav 组件对应切换区域，TabContent 组件对应内容区域。这两个区域组件都存放了一个有序数组，都可以进一步拆分。到这里，我们就想得到两种组织的方式。</p>
<ul>
<li><p>在 Tabs 组件内把所有定义的子组件都显式展示出来。这种方式的好处在于非常易于理解，可自定义能力强，但调用过程显得过于笨重。React-Bootstrap 和 Material UI 组件库中的 Tabs 组件采用的是这种形式。调用方式近似如下形式：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;Tabs</span><span class="pln"> </span><span class="atn">classPrefix</span><span class="pun">=</span><span class="atv">{'tabs'</span><span class="pln">} </span><span class="atn">defaultActiveIndex</span><span class="pun">=</span><span class="atv">{0}</span><span class="tag">&gt;</span><span class="pln">
  </span><span class="tag">&lt;TabNav&gt;</span><span class="pln">
    </span><span class="tag">&lt;TabHead&gt;</span><span class="pln">Tab 1</span><span class="tag">&lt;/TabHead&gt;</span><span class="pln">
    </span><span class="tag">&lt;TabHead&gt;</span><span class="pln">Tab 2</span><span class="tag">&lt;/TabHead&gt;</span><span class="pln">
    </span><span class="tag">&lt;TabHead&gt;</span><span class="pln">Tab 3</span><span class="tag">&lt;/TabHead&gt;</span><span class="pln">
  </span><span class="tag">&lt;/TabNav&gt;</span><span class="pln">
  </span><span class="tag">&lt;TabContent&gt;</span><span class="pln">
    </span><span class="tag">&lt;TabPane&gt;</span><span class="pln">第一个 Tab 里的内容</span><span class="tag">&lt;/TabPane&gt;</span><span class="pln">
    </span><span class="tag">&lt;TabPane&gt;</span><span class="pln">第二个 Tab 里的内容</span><span class="tag">&lt;/TabPane&gt;</span><span class="pln">
    </span><span class="tag">&lt;TabPane&gt;</span><span class="pln">第三个 Tab 里的内容</span><span class="tag">&lt;/TabPane&gt;</span><span class="pln">
  </span><span class="tag">&lt;/TabContent&gt;</span><span class="pln">
</span><span class="tag">&lt;/Tabs&gt;</span></code></pre>
</li>
<li><p>在 Tabs 组件内只显示定义内容区域的子组件集合，头部区域对应内部区域每一个 TabPane 组件的 props，让其在 TabNav 组件内拼装。这种方式的调用写法简洁，把复杂的逻辑留给了组件去实现。Ant Design 组件库中的 Tabs 组件采用的就是这种形式。调用方式近似如下形式：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;Tabs</span><span class="pln"> </span><span class="atn">classPrefix</span><span class="pun">=</span><span class="atv">{'tabs'</span><span class="pln">} </span><span class="atn">defaultActiveIndex</span><span class="pun">=</span><span class="atv">{0}</span><span class="tag">&gt;</span><span class="pln">
  </span><span class="tag">&lt;TabPane</span><span class="pln"> </span><span class="atn">key</span><span class="pun">=</span><span class="atv">{0}</span><span class="pln"> </span><span class="atn">tab</span><span class="pun">=</span><span class="atv">{'Tab 1'</span><span class="pln">}</span><span class="tag">&gt;</span><span class="pln">第一个 Tab 里的内容</span><span class="tag">&lt;/TabPane&gt;</span><span class="pln">
  </span><span class="tag">&lt;TabPane</span><span class="pln"> </span><span class="atn">key</span><span class="pun">=</span><span class="atv">{1}</span><span class="pln"> </span><span class="atn">tab</span><span class="pun">=</span><span class="atv">{'Tab 2'</span><span class="pln">}</span><span class="tag">&gt;</span><span class="pln">第二个 Tab 里的内容</span><span class="tag">&lt;/TabPane&gt;</span><span class="pln">
  </span><span class="tag">&lt;TabPane</span><span class="pln"> </span><span class="atn">key</span><span class="pun">=</span><span class="atv">{2}</span><span class="pln"> </span><span class="atn">tab</span><span class="pun">=</span><span class="atv">{'Tab 3'</span><span class="pln">}</span><span class="tag">&gt;</span><span class="pln">第三个 Tab 里的内容</span><span class="tag">&lt;/TabPane&gt;</span><span class="pln">
</span><span class="tag">&lt;/Tabs&gt;</span><span class="pln">
</span></code></pre>
</li>
</ul>
<p>在本章中，我们通过后一种方式讲解。基本的结构确定后，我们需要想一下怎么渲染这个结构的内容。显然，并不是所有参数都由 Tabs 组件承载。只有两个 props 放在了 Tabs 组件上，而其他参数直接放到 TabPane 组件中，由它的父组件 TabContent 隐式对 TabPane 组件拼装。</p>
<p>那么，这个一直在说的子组件是什么呢，我们到底怎么对它进行拼装渲染呢？</p>
<p><strong>1. 子组件 prop</strong></p>
<p>在 React 中有一个重要且内置的 prop——<code>children</code>，它代表组件的子组件集合。<code>children</code> 可以根据传入子组件的数量来决定是否是数组类型。上述调用 TabPane 组件的过程，翻译过来即是：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">&lt;Tabs classPrefix={'tabs'} defaultActiveIndex={0} className="tabs-bar"
  children={[
    </span><span class="tag">&lt;TabPane</span><span class="pln"> </span><span class="atn">key</span><span class="pun">=</span><span class="atv">{0}</span><span class="pln"> </span><span class="atn">tab</span><span class="pun">=</span><span class="atv">{'Tab 1'</span><span class="pln">}</span><span class="tag">&gt;</span><span class="pln">第一个 Tab 里的内容</span><span class="tag">&lt;/TabPane&gt;</span><span class="pln">,
    </span><span class="tag">&lt;TabPane</span><span class="pln"> </span><span class="atn">key</span><span class="pun">=</span><span class="atv">{1}</span><span class="pln"> </span><span class="atn">tab</span><span class="pun">=</span><span class="atv">{'Tab 2'</span><span class="pln">}</span><span class="tag">&gt;</span><span class="pln">第二个 Tab 里的内容</span><span class="tag">&lt;/TabPane&gt;</span><span class="pln">,
    </span><span class="tag">&lt;TabPane</span><span class="pln"> </span><span class="atn">key</span><span class="pun">=</span><span class="atv">{2}</span><span class="pln"> </span><span class="atn">tab</span><span class="pun">=</span><span class="atv">{'Tab 3'</span><span class="pln">}</span><span class="tag">&gt;</span><span class="pln">第三个 Tab 里的内容</span><span class="tag">&lt;/TabPane&gt;</span><span class="pln">,
  ]}
&gt;
</span><span class="tag">&lt;/Tabs&gt;</span><span class="pln">
</span></code></pre>
<p>实现的基本思路就以 TabContent 组件渲染 TabPane 子组件集合为例来讲，其中渲染 TabPane 组件的方法如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">getTabPanes</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> classPrefix</span><span class="pun">,</span><span class="pln"> activeIndex</span><span class="pun">,</span><span class="pln"> panels</span><span class="pun">,</span><span class="pln"> isActive </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">Children</span><span class="pun">.</span><span class="pln">map</span><span class="pun">(</span><span class="pln">panels</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln">child</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">child</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> order </span><span class="pun">=</span><span class="pln"> parseInt</span><span class="pun">(</span><span class="pln">child</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">order</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> isActive </span><span class="pun">=</span><span class="pln"> activeIndex </span><span class="pun">===</span><span class="pln"> order</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="pln">cloneElement</span><span class="pun">(</span><span class="pln">child</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      classPrefix</span><span class="pun">,</span><span class="pln">
      isActive</span><span class="pun">,</span><span class="pln">
      children</span><span class="pun">:</span><span class="pln"> child</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">children</span><span class="pun">,</span><span class="pln">
      key</span><span class="pun">:</span><span class="pln"> </span><span class="str">`tabpane-${order}`</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>上述代码讲述了子组件集合是怎么渲染的。通过 <code>React.Children.map</code> 方法遍历子组件，将 <code>order</code>（渲染顺序）、<code>isActive</code>（是否激活 tab）、<code>children</code>（Tabs 组件中传下的 children）和 <code>key</code> 利用 React 的 <code>cloneElement</code> 方法克隆到 TabPane 组件中，最后返回这个 TabPane 组件集合。这也是 Tabs 组件拼装子组件的基本原理。</p>
<p>其中，<code>React.Children</code> 是 React 官方提供的一系列操作 <code>children</code> 的方法。它提供诸如 <code>map</code>、<code>forEach</code>、<code>count</code> 等实用函数，可以为我们处理子组件提供便利。</p>
<p>最后，TabContent 组件的 <code>render</code> 方法只需要调用 <code>getTabPanes</code> 方法即可渲染：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(&lt;</span><span class="pln">div</span><span class="pun">&gt;{</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">getTabPanes</span><span class="pun">()}&lt;/</span><span class="pln">div</span><span class="pun">&gt;);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>假如我们把 <code>render</code> 方法中的 <code>this.getTabPanes</code> 方法中对子组件的遍历直接放进去，就会变成如下形式：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(&lt;</span><span class="pln">div</span><span class="pun">&gt;{</span><span class="typ">React</span><span class="pun">.</span><span class="typ">Children</span><span class="pun">.</span><span class="pln">map</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">children</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln">child</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{...})}&lt;/</span><span class="pln">div</span><span class="pun">&gt;);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>这种调用方式称为 <strong>Dynamic Children（动态子组件）</strong>。它指的是组件内的子组件是通过动态计算得到的。就像上述对子组件的遍历一样，我们一样可以对任何数据、字符串、数组或对象作动态计算。</p>
<p>用声明式编程的方式来渲染数据，这种做法和关心所有细节的命令式编程相比，会让我们轻松许多。当然，除了数组的 <code>map</code> 函数，还可以用其他实用的高阶函数，如 <code>reduce</code>、<code>filter</code> 等函数。值得注意的是，与 <code>map</code> 函数相似但不返回调用结果的 <code>forEach</code> 函数不能这么使用。</p>
<p><strong>2. 组件 props</strong></p>
<p>当然，React 的强大之处不止于此，我们观察 TabPane 组件中的 <code>tab</code> prop：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;TabPane</span><span class="pln"> </span><span class="atn">key</span><span class="pun">=</span><span class="atv">{0}</span><span class="pln"> </span><span class="atn">tab</span><span class="pun">=</span><span class="atv">{'Tab 1'</span><span class="pln">}</span><span class="tag">&gt;</span><span class="pln">第一个 Tab 里的内容</span><span class="tag">&lt;/TabPane&gt;</span><span class="pln">
</span></code></pre>
<p>它现在传入的是一个字符串。那么，假如可以传入节点呢，是不是就可以自定义 tab 头展示的形式了。这就是 <code>component</code> props。对于子组件而言，我们不仅可以直接使用 <code>this.props.children</code> 定义，也可以将子组件以 props 的形式传递。一般我们会用这种方法来让开发者定义组件的某一个 prop，让其具备多种类型，来做到简单配置和自定义配置组合在一起的效果。</p>
<p>在 Tabs 组件中，我们就用到了这样的功能，调用方式如下所示：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;Tabs</span><span class="pln"> </span><span class="atn">classPrefix</span><span class="pun">=</span><span class="atv">{'tabs'</span><span class="pln">} </span><span class="atn">defaultActiveIndex</span><span class="pun">=</span><span class="atv">{0}</span><span class="pln"> </span><span class="atn">className</span><span class="pun">=</span><span class="atv">"tabs-bar"</span><span class="tag">&gt;</span><span class="pln">
  &lt;TabPane
    order="0"
    tab={</span><span class="tag">&lt;span&gt;&lt;i</span><span class="pln"> </span><span class="atn">className</span><span class="pun">=</span><span class="atv">"fa fa-home"</span><span class="tag">&gt;&lt;/i&gt;</span><span class="pln">&amp;nbsp;Home</span><span class="tag">&lt;/span&gt;</span><span class="pln">}&gt;
    第一个 Tab 里的内容
  </span><span class="tag">&lt;/TabPane&gt;</span><span class="pln">
  &lt;TabPane
    order="1"
    tab={</span><span class="tag">&lt;span&gt;&lt;i</span><span class="pln"> </span><span class="atn">className</span><span class="pun">=</span><span class="atv">"fa fa-book"</span><span class="tag">&gt;&lt;/i&gt;</span><span class="pln">&amp;nbsp;Library</span><span class="tag">&lt;/span&gt;</span><span class="pln">}&gt;
    第二个 Tab 里的内容
  </span><span class="tag">&lt;/TabPane&gt;</span><span class="pln">
  &lt;TabPane
    order="2"
    tab={</span><span class="tag">&lt;span&gt;&lt;i</span><span class="pln"> </span><span class="atn">className</span><span class="pun">=</span><span class="atv">"fa fa-pencil"</span><span class="tag">&gt;&lt;/i&gt;</span><span class="pln">&amp;nbsp;Applications</span><span class="tag">&lt;/span&gt;</span><span class="pln">}&gt;
    第三个 Tab 里的内容
  </span><span class="tag">&lt;/TabPane&gt;</span><span class="pln">
</span><span class="tag">&lt;/Tabs&gt;</span><span class="pln">
</span></code></pre>
<p>这里我们使用 font-awesome 的图标。渲染后，每一个 tab 上的文字前都会有一个图标，如图 1-7 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/03.d01z.007.png" alt="{%}"></p>
<p><strong>图 1-7　文字前加上了图标</strong></p>
<p>当然，我们也可以加入更多的自定义元素，可以是多行的，甚至可以插入动态数据。这听上去有些复杂，但实现过程其实非常简单。下面是写在 TabNav 组件中简化的渲染子组件集合的方法：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">getTabs</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> classPrefix</span><span class="pun">,</span><span class="pln"> activeIndex</span><span class="pun">,</span><span class="pln"> panels </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">Children</span><span class="pun">.</span><span class="pln">map</span><span class="pun">(</span><span class="pln">panels</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln">child</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">child</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> order </span><span class="pun">=</span><span class="pln"> parseInt</span><span class="pun">(</span><span class="pln">child</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">order</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">);</span><span class="pln">
    let classes </span><span class="pun">=</span><span class="pln"> classnames</span><span class="pun">({</span><span class="pln">
      </span><span class="pun">[</span><span class="str">`${classPrefix}-tab`</span><span class="pun">]:</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">[</span><span class="str">`${classPrefix}-active`</span><span class="pun">]:</span><span class="pln"> activeIndex </span><span class="pun">===</span><span class="pln"> order</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">[</span><span class="str">`${classPrefix}-disabled`</span><span class="pun">]:</span><span class="pln"> child</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">disabled</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="str">&lt;li&gt;</span><span class="pun">{</span><span class="pln">child</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">tab</span><span class="pun">}&lt;/</span><span class="pln">li</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>其实现看上去与 <code>getTabPanes</code> 方法非常像，关键在于通过遍历 TabPane 组件的 <code>tab</code> prop 来实现我们想要的功能。不论 tab 是以字符串的形式还是以虚拟元素的形式存在，都可以直接在 <code>&lt;li&gt;</code> 标签中渲染出来。</p>
<p><strong>3. 用 <code>function</code> prop 与父组件通信</strong></p>
<p>现在我们发现对于 state 来说，它的通信集中在组件内部；对于 props 来说，它的通信是父组件向子组件的传播。相关代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">handleTabClick</span><span class="pun">(</span><span class="pln">activeIndex</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// ...</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">onChange</span><span class="pun">({</span><span class="pln">activeIndex</span><span class="pun">,</span><span class="pln"> prevIndex</span><span class="pun">});</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>我们通过点击事件 <code>handleTabClick</code> 触发了 <code>onChange</code> prop 回调函数给父组件必要的值。对于兄弟组件或不相关组件之间的通信，具体请看 2.4 节。</p>
<p><strong>4. <code>propTypes</code></strong></p>
<p>众所周知，JavaScript 不是强类型语言，我们对在没有保证的环境下写 JavaScript 已经习以为常了。强类型还是弱类型，正是一个开发时的约束问题。React 对此作了妥协，便有了 <code>propTypes</code>。</p>
<p><code>propTypes</code> 用于规范 props 的类型与必需的状态。如果组件定义了 <code>propTypes</code>，那么在开发环境下，就会对组件的 props 值的类型作检查，如果传入的 props 不能与之匹配，React 将实时在控制台里报 warning。在生产环境下，这是不会进行检查的。</p>
<p>我们来分析下 Tabs 组件中的情况，并写出对应的 <code>propTypes</code>。Tabs 组件包括父组件 Tabs 与子组件 TabPane，下面我们分开来讨论两者的 <code>propTypes</code>。现在，我们先来看 Tabs 组件的 <code>propTypes</code>：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">static</span><span class="pln"> propTypes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  classPrefix</span><span class="pun">:</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">string</span><span class="pun">,</span><span class="pln">
  className</span><span class="pun">:</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">string</span><span class="pun">,</span><span class="pln">
  defaultActiveIndex</span><span class="pun">:</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">number</span><span class="pun">,</span><span class="pln">
  activeIndex</span><span class="pun">:</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">number</span><span class="pun">,</span><span class="pln">
  onChange</span><span class="pun">:</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">func</span><span class="pun">,</span><span class="pln">
  children</span><span class="pun">:</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">oneOfType</span><span class="pun">([</span><span class="pln">
    </span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">arrayOf</span><span class="pun">(</span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">node</span><span class="pun">),</span><span class="pln">
    </span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">node</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">]),</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span></code></pre>
<p>我们很清晰地列举了所有可能的 props，并对它们的类型进行定义。再来看看 TabPane 组件的 <code>propTypes</code>：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">static</span><span class="pln"> propTypes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  tab</span><span class="pun">:</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">oneOfType</span><span class="pun">([</span><span class="pln">
    </span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">string</span><span class="pun">,</span><span class="pln">
    </span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">node</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">]).</span><span class="pln">isRequired</span><span class="pun">,</span><span class="pln">
  order</span><span class="pun">:</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">string</span><span class="pun">.</span><span class="pln">isRequired</span><span class="pun">,</span><span class="pln">
  disable</span><span class="pun">:</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">bool</span><span class="pun">,</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span></code></pre>
<p>在 TabPane 组件的 props 中，对 <code>tab</code> 和 <code>order</code> prop 除了定义类型，还定义了是否必要。因此，如果在写 TabPane 组件时，没有定义 <code>order</code> prop，浏览器就会主动报一个类型错误的提示：</p>
<pre class="代码无行号 prettyprint"><code><span class="typ">Warning</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Failed</span><span class="pln"> propType</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Required</span><span class="pln"> prop </span><span class="str">`order`</span><span class="pln"> was </span><span class="kwd">not</span><span class="pln"> specified </span><span class="kwd">in</span><span class="pln"> </span><span class="str">`TabPane`</span><span class="pun">.</span><span class="pln">
</span></code></pre>
<p>值得注意的是，在 <code>propTypes</code> 支持的基本类型中，函数类型的检查是 <code>propTypes.func</code>，而不是 <code>propTypes.function</code>。对于布尔类型的检查是 <code>propTypes.bool</code>，而不是 <code>propTypes.boolean</code>。这是因为 <code>function</code> 和<code>boolean</code> 在 JavaScript 里是关键词。</p>
<p><code>propTypes</code> 有很多类型支持，不仅有基本类型，还包括枚举和自定义类型。</p>
<h2><strong>1.5　React 生命周期</strong></h2>
<p>生命周期（life cycle）的概念广泛运用于各行各业。从广义上来说，生命周期泛指自然界和人类社会中各种客观事物的阶段性变化及其规律。自然界的生命周期，可分为出生、成长、成熟、衰退直到死亡。而不同体系下的生命周期又都可以从上述规律中演化出来，运用到软件开发的生命周期上，这二者看似相似，事实上又有所不同。生命体的周期是单一方向不可逆的过程，而软件开发的生命周期会根据方法的不同，在完成前重新开始。</p>
<p>React 组件的生命周期根据广义定义描述，可以分为挂载、渲染和卸载这几个阶段。当渲染后的组件需要更新时，我们会重新去渲染组件，直至卸载。</p>
<p>因此，我们可以把 React 生命周期分成两类：</p>
<ul>
<li><p>当组件在挂载或卸载时；</p>
</li>
<li><p>当组件接收新的数据时，即组件更新时。</p>
</li>
</ul>
<h3><strong>1.5.1　挂载或卸载过程</strong></h3>
<p>下面我们简要介绍一下组件的挂载和卸载过程。</p>
<p><strong>1. 组件的挂载</strong></p>
<p>组件挂载是最基本的过程，这个过程主要做组件状态的初始化。我们推荐以下面的例子为模板写初始化组件：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pun">,</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> propTypes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// ...</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> defaultProps </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// ...</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="com">// ...</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  componentWillMount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// ...</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  componentDidMount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// ...</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="str">&lt;div&gt;</span><span class="typ">This</span><span class="pln"> </span><span class="kwd">is</span><span class="pln"> a demo</span><span class="pun">.&lt;/</span><span class="pln">div</span><span class="pun">&gt;;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>我们看到 <code>propTypes</code> 和 <code>defaultProps</code> 分别代表 props 类型检查和默认类型。这两个属性被声明成静态属性，意味着从类外面也可以访问它们，比如可以这么访问：<code>App.propTypes</code> 和 <code>App.defaultProps</code>。</p>
<p>之后会看到两个明显的生命周期方法，其中 <code>componentWillMount</code> 方法会在 <code>render</code> 方法之前执行，而 <code>componentDidMount</code> 方法会在 <code>render</code> 方法之后执行，分别代表了渲染前后的时刻。</p>
<p>这个初始化过程没什么特别的，包括读取初始 state 和 props 以及两个组件生命周期方法 <code>componentWillMount</code> 和 <code>componentDidMount</code>，这些都只会在组件初始化时运行一次。</p>
<p>如果我们在 <code>componentWillMount</code> 中执行 <code>setState</code> 方法，会发生什么呢？组件会更新 state，但组件<strong>只渲染一次</strong>。因此，这是无意义的执行，初始化时的 state 都可以放在 <code>this.state</code>。</p>
<p>如果我们在 <code>componentDidMount</code> 中执行 <code>setState</code> 方法，又会发生什么呢？组件当然会再次更新，不过在初始化过程就渲染了两次组件，这并不是一件好事。但实际情况是，有一些场景不得不需要 <code>setState</code>，比如计算组件的位置或宽高时，就不得不让组件先渲染，更新必要的信息后，再次渲染。</p>
<p>2. <strong>组件的卸载</strong></p>
<p>组件卸载非常简单，只有 <code>componentWillUnmount</code> 这一个卸载前状态：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pun">,</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  componentWillUnmount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// ...</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="str">&lt;div&gt;</span><span class="typ">This</span><span class="pln"> </span><span class="kwd">is</span><span class="pln"> a demo</span><span class="pun">.&lt;/</span><span class="pln">div</span><span class="pun">&gt;;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>在 <code>componentWillUnmount</code> 方法中，我们常常会执行一些清理方法，如事件回收或是清除定时器。</p>
<h3><strong>1.5.2　数据更新过程</strong></h3>
<p>更新过程指的是父组件向下传递 props 或组件自身执行 <code>setState</code> 方法时发生的一系列更新动作。这里我们屏蔽了初始化的生命周期方法，以便观察更新过程的生命周期：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pun">,</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  componentWillReceiveProps</span><span class="pun">(</span><span class="pln">nextProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// this.setState({})</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  shouldComponentUpdate</span><span class="pun">(</span><span class="pln">nextProps</span><span class="pun">,</span><span class="pln"> nextState</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// return true;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  componentWillUpdate</span><span class="pun">(</span><span class="pln">nextProps</span><span class="pun">,</span><span class="pln"> nextState</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// ...</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  componentDidUpdate</span><span class="pun">(</span><span class="pln">prevProps</span><span class="pun">,</span><span class="pln"> prevState</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// ...</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="str">&lt;div&gt;</span><span class="typ">This</span><span class="pln"> </span><span class="kwd">is</span><span class="pln"> a demo</span><span class="pun">.&lt;/</span><span class="pln">div</span><span class="pun">&gt;;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>如果组件自身的 state 更新了，那么会依次执行 <code>shouldComponentUpdate</code>、<code>componentWillUpdate</code>、<code>render</code> 和 <code>componentDidUpdate</code>。</p>
<p><code>shouldComponentUpdate</code> 是一个特别的方法，它接收需要更新的 props 和 state，让开发者增加必要的条件判断，让其在需要时更新，不需要时不更新。因此，当方法返回 <code>false</code> 的时候，组件不再向下执行生命周期方法。</p>
<p><code>shouldComponentUpdate</code> 的本质是用来进行正确的组件渲染。怎么理解呢？我们需要先从初始化组件的过程开始说起，假设有如图 1-8 所示的组件关系，它呈三级的树状结构，其中空心圆表示已经渲染的节点。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/03.d01z.008.png" alt="{%}"></p>
<p><strong>图 1-8　初始化渲染结构</strong></p>
<p>当父节点 props 改变的时候，在理想情况下，只需渲染在一条链路上有相关 props 改变的节点即可，如图 1-9 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/03.d01z.009.png" alt="{%}"></p>
<p><strong>图 1-9　props 改变时 React 节点的渲染路径</strong></p>
<p>而默认情况下，React 会渲染所有的节点，因为 <code>shouldComponentUpdate</code> 默认返回 <code>true</code>。正确的组件渲染从另一个意义上说，也是性能优化的手段之一。</p>
<p>值得注意的是，无状态组件是没有生命周期方法的，这也意味着它没有 <code>shouldComponentUpdate</code>。渲染到该类组件时，每次都会重新渲染。当然，不少开发者在使用无状态组件时会纠结这一点。为了更放心地使用，我们可以选择引用 Recompose 库的 <code>pure</code> 方法：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> </span><span class="typ">OptimizedComponent</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> pure</span><span class="pun">(</span><span class="typ">ExpensiveComponent</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>事实上，<code>pure</code> 方法做的事就是将无状态组件转换成 class 语法加上 PureRender 后的组件。关于性能优化相关的内容，我们会在 2.6 节中详解。</p>
<p><code>componentWillUpdate</code> 和 <code>componentDidUpdate</code> 这两个生命周期方法很容易理解，对应的初始化方法也很容易知道，它们代表在更新过程中渲染前后的时刻。此时，我们可以想到 <code>componentWillUpdate</code> 方法提供需要更新的 props 和 state，而 <code>componentDidUpdate</code> 提供更新前的 props 和 state。</p>
<p>这里需要注意的是，你不能在 <code>componentWillUpdate</code> 中执行 <code>setState</code>。如果你对此很感兴趣，想一探究竟，可以直接跳至 3.3 节，那里有更加深入的解释。</p>
<p>如果组件是由父组件更新 props 而更新的，那么在 <code>shouldComponentUpdate</code> 之前会先执行 <code>componentWillReceiveProps</code> 方法。此方法可以作为 React 在 props 传入后，渲染之前 <code>setState</code> 的机会。在此方法中调用 <code>setState</code> 是不会二次渲染的。</p>
<p>回想之前介绍 Tabs 组件实现时留下的一个问题：如果 Tabs 组件的 <code>activeIndex</code> prop 只由外组件来更新，那是怎么做到的呢？秘密就在 <code>componentWillReceiveProps</code> 方法上，相关代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">componentWillReceiveProps</span><span class="pun">(</span><span class="pln">nextProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="str">'activeIndex'</span><span class="pln"> </span><span class="kwd">in</span><span class="pln"> nextProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
      activeIndex</span><span class="pun">:</span><span class="pln"> nextProps</span><span class="pun">.</span><span class="pln">activeIndex</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>这样的设置就是让传入的 props 判断是否存在 <code>activeIndex</code>。如果用了 <code>activeIndex</code> 初始化组件，那么每次组件更新前都会去更新组件内部的 <code>activeIndex state</code>，达到更新组件的目的。</p>
<p>然后，在 tab 点击事件上，对是否存在 <code>defaultActiveIndex</code> prop 进行判断即可达到在传入 <code>defaultActiveIndex</code> 时使用内部更新，当传入 <code>activeIndex</code> 时使用外部传入的 props 更新。相关代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">handleTabClick</span><span class="pun">(</span><span class="pln">activeIndex</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> prevIndex </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">activeIndex</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">activeIndex </span><span class="pun">!==</span><span class="pln"> activeIndex </span><span class="pun">&amp;&amp;</span><span class="pln">
      </span><span class="str">'defaultActiveIndex'</span><span class="pln"> </span><span class="kwd">in</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
      activeIndex</span><span class="pun">,</span><span class="pln">
      prevIndex</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">onChange</span><span class="pun">({</span><span class="pln"> activeIndex</span><span class="pun">,</span><span class="pln"> prevIndex </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<h3><strong>1.5.3　整体流程</strong></h3>
<p>我们用一张流程图（如图 1-10 所示）来理清生命周期方法之间的关系，以及关键 API 调用的反馈。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/03.d01z.010.png" alt="{%}"></p>
<p><strong>图 1-10　React 生命周期整体流程图</strong></p>
<p>此外，我们在 1.3 节中提到用 <code>createClass</code> 来构建组件时，生命周期稍有不同。这里我们对还在用 createClass 方式的开发者们，简要说明方法级别上的不同，如图 1-11 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/03.d01z.011.png" alt="" width="90%" style="width: 90%"></p>
<p><strong>图 1-11　使用 ES6 classes 与 createClass 构建组件方法的异同</strong></p>
<p>我们看到初始化方法有所不同，但生命周期方法均没有变化。此外，ES6 classes 中的静态方法用静态关键词 <code>static</code> 声明即可，如 <code>static customMethod() {}</code>；mixin 属性被移除，可以使用高阶组件（higher-order component）替代。</p>
<p>在源码中，生命周期的调用其实也是复用的代码。为推行 ECMAScript 标准，我们更倾向于使用 ES6 classes 的方式来构建组件。</p>
<h2><strong>1.6　React 与 DOM</strong></h2>
<p>前面已经介绍完组件的组成部分了，但还缺少最后一环，那就是将组件渲染到真实 DOM 上。从 React 0.14 版本开始，React 将 React 中涉及 DOM 操作的部分剥离开，目的是为了抽象 React，同时适用于 Web 端和移动端。ReactDOM 的关注点在 DOM 上，因此只适用于 Web 端。</p>
<p>在 React 组件的开发实现中，我们并不会用到 ReactDOM，只有在顶层组件以及由于 React 模型所限而不得不操作 DOM 的时候，才会使用它。</p>
<h3><strong>1.6.1　ReactDOM</strong></h3>
<p>ReactDOM 中的 API 非常少，只有 <code>findDOMNode</code>、<code>unmountComponentAtNode</code> 和 <code>render</code>。下面我们就从 API 的角度来讲讲它们的用法。</p>
<p><strong>1. <code>findDOMNode</code></strong></p>
<p>上一节我们已经讲过组件的生命周期，DOM 真正被添加到 HTML 中的生命周期方法是 <code>componentDidMount</code> 和 <code>componentDidUpdate</code> 方法。在这两个方法中，我们可以获取真正的 DOM 元素。React 提供的获取 DOM 元素的方法有两种，其中一种就是 ReactDOM 提供的 <code>findDOMNode</code>：</p>
<pre class="代码无行号 prettyprint"><code><span class="typ">DOMElement</span><span class="pln"> findDOMNode</span><span class="pun">(</span><span class="typ">ReactComponent</span><span class="pln"> component</span><span class="pun">)</span><span class="pln">
</span></code></pre>
<p>当组件被渲染到 DOM 中后，<code>findDOMNode</code> 返回该 React 组件实例相应的 DOM 节点。它可以用于获取表单的 <code>value</code> 以及用于 DOM 的测量。例如，假设要在当前组件加载完时获取当前 DOM，则可以使用 <code>findDOMNode</code>：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">ReactDOM</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-dom'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  componentDidMount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// this 为当前组件的实例</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> dom </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactDOM</span><span class="pun">.</span><span class="pln">findDOMNode</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>如果在 <code>render</code> 中返回 <code>null</code>，那么 <code>findDOMNode</code> 也返回 <code>null</code>。<code>findDOMNode</code> 只对已经挂载的组件有效。</p>
<p>涉及复杂操作时，还有非常多的原生 DOM API 可以用。但是需要严格限制场景，在使用之前多问自己为什么要操作 DOM。</p>
<p><strong>2. <code>render</code></strong></p>
<p>为什么说只有在顶层组件我们才不得不使用 ReactDOM 呢？这是因为要把 React 渲染的 Virtual DOM 渲染到浏览器的 DOM 当中，就要使用 <code>render</code> 方法了：</p>
<pre class="代码无行号 prettyprint"><code><span class="typ">ReactComponent</span><span class="pln"> render</span><span class="pun">(</span><span class="pln">
  </span><span class="typ">ReactElement</span><span class="pln"> element</span><span class="pun">,</span><span class="pln">
  </span><span class="typ">DOMElement</span><span class="pln"> container</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">[</span><span class="kwd">function</span><span class="pln"> callback</span><span class="pun">]</span><span class="pln">
</span><span class="pun">)</span><span class="pln">
</span></code></pre>
<p>该方法把元素挂载到 <code>container</code> 中，并且返回 <code>element</code> 的实例（即 <code>refs</code> 引用）。当然，如果是无状态组件，<code>render</code> 会返回 <code>null</code>。当组件装载完毕时，<code>callback</code> 就会被调用。</p>
<p>当组件在初次渲染之后再次更新时，React 不会把整个组件重新渲染一次，而会用它高效的 DOM diff 算法做局部的更新。这也是 React 最大的亮点之一！</p>
<p>此外，与 <code>render</code> 相反，React 还提供了一个很少使用的 <code>unmountComponentAtNode</code> 方法来进行卸载操作。</p>
<h3><strong>1.6.2　ReactDOM 的不稳定方法</strong></h3>
<p>ReactDOM 中有两个不稳定方法，其中一个方法与 <code>render</code> 方法颇为相似。讲起它，还得从我们常用的 Dialog 组件在 React 中的实现讲起。</p>
<p>我们先来回忆一下 Dialog 组件的特点，它是不在文档流中的弹出框，一般会绝对定位在屏幕的正中央，背后有一层半透明的遮罩。因此，它往往直接渲染在 <code>document.body</code> 下，然而我们并不知道如何在 React 组件外进行操作。这就要从实现 Dialog 的思路以及涉及 DOM 部分的实现讲起。</p>
<p>这里我们引入 Portal 组件，这是一个经典的实现，最初的实现来源于 React Bootstrap 组件库中的 Overlay Mixin，后来使用越来越广泛。我们截取关键部分的源码：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">ReactDOM</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> findDOMNode </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-dom'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">CSSPropertyOperations</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react/lib/CSSPropertyOperations'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">default</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Portal</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// ...</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  openPortal</span><span class="pun">(</span><span class="pln">props </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln"> active</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">});</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">renderPortal</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">onOpen</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">node</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  closePortal</span><span class="pun">(</span><span class="pln">isUnmounted </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> resetPortalState </span><span class="pun">=</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">node</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="typ">ReactDOM</span><span class="pun">.</span><span class="pln">unmountComponentAtNode</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">node</span><span class="pun">);</span><span class="pln">
        document</span><span class="pun">.</span><span class="pln">body</span><span class="pun">.</span><span class="pln">removeChild</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">node</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">portal </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">node </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">isUnmounted </span><span class="pun">!==</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln"> active</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">false</span><span class="pln"> </span><span class="pun">});</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">active</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">beforeClose</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">beforeClose</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">node</span><span class="pun">,</span><span class="pln"> resetPortalState</span><span class="pun">);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        resetPortalState</span><span class="pun">();</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">onClose</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  renderPortal</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">node</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">node </span><span class="pun">=</span><span class="pln"> document</span><span class="pun">.</span><span class="pln">createElement</span><span class="pun">(</span><span class="str">'div'</span><span class="pun">);</span><span class="pln">
      </span><span class="com">// 在节点增加到 DOM 之前，执行 CSS 防止无效的重绘</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">applyClassNameAndStyle</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">
      document</span><span class="pun">.</span><span class="pln">body</span><span class="pun">.</span><span class="pln">appendChild</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">node</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="com">// 当新的 props 传下来的时候，更新 CSS</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">applyClassNameAndStyle</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    let children </span><span class="pun">=</span><span class="pln"> props</span><span class="pun">.</span><span class="pln">children</span><span class="pun">;</span><span class="pln">
    </span><span class="com">// https://gist.github.com/jimfb/d99e0678e9da715ccf6454961ef04d1b</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">typeof</span><span class="pln"> props</span><span class="pun">.</span><span class="pln">children</span><span class="pun">.</span><span class="pln">type </span><span class="pun">===</span><span class="pln"> </span><span class="str">'function'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      children </span><span class="pun">=</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="pln">cloneElement</span><span class="pun">(</span><span class="pln">props</span><span class="pun">.</span><span class="pln">children</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> closePortal</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">closePortal </span><span class="pun">});</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">portal </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactDOM</span><span class="pun">.</span><span class="pln">unstable_renderSubtreeIntoContainer</span><span class="pun">(</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">,</span><span class="pln">
      children</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">node</span><span class="pun">,</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">onUpdate
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">openByClickOn</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="pln">cloneElement</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">openByClickOn</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> onClick</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleWrapperClick </span><span class="pun">});</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>从 Portal 组件可以看出，我们实现了一个“壳”，其中包括触发事件、渲染的位置以及暴露的方法，但它并不关心子组件的内容。当我们使用它的时候，可以这么写：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;Portal</span><span class="pln"> </span><span class="atn">ref</span><span class="pun">=</span><span class="atv">"myPortal"</span><span class="tag">&gt;</span><span class="pln">
  </span><span class="tag">&lt;Modal</span><span class="pln"> </span><span class="atn">title</span><span class="pun">=</span><span class="atv">"My modal"</span><span class="tag">&gt;</span><span class="pln">
    Modal content
  </span><span class="tag">&lt;/Modal&gt;</span><span class="pln">
</span><span class="tag">&lt;/Portal&gt;</span><span class="pln">
</span></code></pre>
<p>这个组件可以说是 Dialog 实现的精髓，我们为 Dialog 的行为抽象了 Portal 这个父组件。</p>
<p>当调用上述代码时，可以注意到在运行到 <code>componentDidMount</code> 生命周期方法时，最后调用了 <code>this.renderPortal()</code> 方法，这个方法把子组件里的内容插入到 <code>document.body</code> 下，这就实现了子组件不在标准文档流的渲染。</p>
<p>这就说到了 ReactDOM 中不稳定的 API 方法 <code>unstable_renderSubtreeIntoContainer</code>。它的作用很简单，就是更新组件到传入的 DOM 节点上，我们在这里使用它完成了在组件内实现跨组件的 DOM 操作。</p>
<p>这个方法与 <code>render</code> 方法很相似，但 <code>render</code> 方法缺少一个插入某个节点的参数。从最终 ReactDOM 方法实现的源代码 react/src/renderers/dom/client/ReactMount.js 中可以了解到， <code>unstable_renderSubtreeIntoContainer</code> 与 <code>render</code> 方法对应调用的方法如下。</p>
<ul>
<li><p><strong><code>render</code></strong>： <code>ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback)</code>。</p>
</li>
<li><p><strong><code>unstable_renderSubtreeIntoContainer</code></strong>： <code>ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback)</code>。</p>
</li>
</ul>
<p>源码证明了我们的猜想，这也说明了两者的区别在于是否传入父节点。</p>
<p>此外，另一个 ReactDOM 中的不稳定方法 <code>unstable_batchedUpdates</code> 是关于 <code>setState</code> 的更新策略，我们会在 3.4.5 中详细介绍。</p>
<h3><strong>1.6.3　<code>refs</code></strong></h3>
<p>刚才我们已经详述了 ReactDOM 的 <code>render</code> 方法，比如我们渲染了一个 App 组件到 <code>root</code> 节点下：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> myAppInstance </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactDOM</span><span class="pun">.</span><span class="pln">render</span><span class="pun">(&lt;</span><span class="typ">App</span><span class="pln"> </span><span class="pun">/&gt;,</span><span class="pln"> document</span><span class="pun">.</span><span class="pln">getElementById</span><span class="pun">(</span><span class="str">'root'</span><span class="pun">));</span><span class="pln">
myAppInstance</span><span class="pun">.</span><span class="pln">doSth</span><span class="pun">();</span><span class="pln">
</span></code></pre>
<p>我们利用 <code>render</code> 方法得到了 App 组件的实例，然后就可以对它做一些操作。但在组件内，JSX 是不会返回一个组件的实例的！它只是一个 ReactElement ，只是告诉 React 被挂载的组件应该长什么样：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> myApp </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;</span><span class="typ">App</span><span class="pln"> </span><span class="pun">/&gt;;</span><span class="pln">
</span></code></pre>
<p><code>refs</code> 就是为此而生的，它是 React 组件中非常特殊的 prop，可以附加到任何一个组件上。从字面意思来看，<code>refs</code> 即 reference，组件被调用时会新建一个该组件的实例，而 <code>refs</code> 就会指向这个实例。</p>
<p>它可以是一个回调函数，这个回调函数会在组件被挂载后立即执行。例如：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">ReactDOM</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-dom'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">){</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  handleClick</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">myTextInput </span><span class="pun">!==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">myTextInput</span><span class="pun">.</span><span class="pln">focus</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="str">&lt;div&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">input type</span><span class="pun">=</span><span class="str">"text"</span><span class="pln"> </span><span class="kwd">ref</span><span class="pun">={(</span><span class="kwd">ref</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">myTextInput </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">ref</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">input
          type</span><span class="pun">=</span><span class="str">"button"</span><span class="pln">
          value</span><span class="pun">=</span><span class="str">"Focus the text input"</span><span class="pln">
          onClick</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick</span><span class="pun">}</span><span class="pln">
        </span><span class="pun">/&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>在这个例子里，我们得到 input 组件的真正实例，所以可以在按钮被按下后调用输入框的 <code>focus()</code> 方法。这个例子把 <code>refs</code> 放到原生的 DOM 组件 input 中，我们可以通过 <code>refs</code> 得到 DOM 节点；而如果把 <code>refs</code> 放到 React 组件，比如 <code>&lt;TextInput /&gt;</code>，我们获得的就是 TextInput 的实例，因此就可以调用 TextInput 的实例方法。</p>
<p><code>refs</code> 同样支持字符串。对于 DOM 操作，不仅可以使用 <code>findDOMNode</code> 获得该组件 DOM，还可以使用 <code>refs</code> 获得组件内部的 DOM。比如：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  componentDidMount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// myComp 是 Comp 的一个实例，因此需要用 findDOMNode 转换为相应的 DOM</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> myComp </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">refs</span><span class="pun">.</span><span class="pln">myComp</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> dom </span><span class="pun">=</span><span class="pln"> findDOMNode</span><span class="pun">(</span><span class="pln">myComp</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="str">&lt;div&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">Comp</span><span class="pln"> </span><span class="kwd">ref</span><span class="pun">=</span><span class="str">"myComp"</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>要获取一个 React 组件的引用，既可以使用 <code>this</code> 来获取当前 React 组件，也可以使用 <code>refs</code> 来获取你拥有的子组件的引用。</p>
<p>我们回到 1.6.2 节中 Portal 组件里暴露的两个方法 <code>openPortal</code> 和 <code>closePortal</code>。这两个方法的调用方式为：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">this</span><span class="pun">.</span><span class="pln">refs</span><span class="pun">.</span><span class="pln">myPortal</span><span class="pun">.</span><span class="pln">openPortal</span><span class="pun">();</span><span class="pln">
</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">refs</span><span class="pun">.</span><span class="pln">myPortal</span><span class="pun">.</span><span class="pln">closePortal</span><span class="pun">();</span><span class="pln">
</span></code></pre>
<p>这种命令式调用的方式，尽管说并不是 React 推崇的，但我们仍然可以使用。原则上，在组件状态维护中不建议用这种方式。</p>
<p>为了防止内存泄漏，当卸载一个组件的时候，组件里所有的 <code>refs</code> 就会变为 <code>null</code>。</p>
<p>值得注意的是，<code>findDOMNode</code> 和 <code>refs</code> 都无法用于无状态组件中，原因在前面已经说过。无状态组件挂载时只是方法调用，没有新建实例。</p>
<p>对于 React 组件来说，<code>refs</code> 会指向一个组件类的实例，所以可以调用该类定义的任何方法。如果需要访问该组件的真实 DOM，可以用 <code>ReactDOM.findDOMNode</code> 来找到 DOM 节点，但我们并不推荐这样做。因为这在大部分情况下都打破了封装性，而且通常都能用更清晰的办法在 React 中构建代码。</p>
<h3><strong>1.6.4　React 之外的 DOM 操作</strong></h3>
<p>DOM 操作可以归纳为对 DOM 的增、删、改、查。这里的“查”指的是对 DOM 属性、样式的查看，比如查看 DOM 的位置、宽、高等信息。而要对 DOM 进行增、删、改，就要先到 DOM 中查询元素。</p>
<p>React 的声明式渲染机制把复杂的 DOM 操作抽象为简单的 state 和 props 的操作，因此避免了很多直接的 DOM 操作。不过，仍然有一些 DOM 操作是 React 无法避免或者正在努力避免的。</p>
<p>举一个明显的例子，如果要调用 HTML5 Audio/Video 的 <code>play</code> 方法和 input 的 <code>focus</code> 方法，React 就无能为力了，这时只能使用相应的 DOM 方法来实现。</p>
<p>React 提供了事件绑定的功能，但是仍然有一些特殊情况需要自行绑定事件，例如 Popup 等组件，当点击组件其他区域时可以收缩此类组件。这就要求我们对组件以外的区域（一般指 <code>document</code> 和 <code>body</code>）进行事件绑定。例如：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">componentDidUpdate</span><span class="pun">(</span><span class="pln">prevProps</span><span class="pun">,</span><span class="pln"> prevState</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">isActive </span><span class="pun">&amp;&amp;</span><span class="pln"> prevState</span><span class="pun">.</span><span class="pln">isActive</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    document</span><span class="pun">.</span><span class="pln">removeEventListener</span><span class="pun">(</span><span class="str">'click'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">hidePopup</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">isActive </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">!</span><span class="pln">prevState</span><span class="pun">.</span><span class="pln">isActive</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    document</span><span class="pun">.</span><span class="pln">addEventListener</span><span class="pun">(</span><span class="str">'click'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">hidePopup</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
componentWillUnmount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  document</span><span class="pun">.</span><span class="pln">removeEventListener</span><span class="pun">(</span><span class="str">'click'</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">hidePopup</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
hidePopup</span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">isMounted</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> node </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactDOM</span><span class="pun">.</span><span class="pln">findDOMNode</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> target </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">target </span><span class="pun">||</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">srcElement</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> isInside </span><span class="pun">=</span><span class="pln"> node</span><span class="pun">.</span><span class="pln">contains</span><span class="pun">(</span><span class="pln">target</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">isActive </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">!</span><span class="pln">isInside</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
      isActive</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>React 中使用 DOM 最多的还是计算 DOM 的尺寸（即位置信息）。我们可以提供像 <code>width</code> 或 <code>height</code> 这样的工具函数：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">function</span><span class="pln"> width</span><span class="pun">(</span><span class="pln">el</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> styles </span><span class="pun">=</span><span class="pln"> el</span><span class="pun">.</span><span class="pln">ownerDocument</span><span class="pun">.</span><span class="pln">defaultView</span><span class="pun">.</span><span class="pln">getComputedStyle</span><span class="pun">(</span><span class="pln">el</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> width </span><span class="pun">=</span><span class="pln"> parseFloat</span><span class="pun">(</span><span class="pln">styles</span><span class="pun">.</span><span class="pln">width</span><span class="pun">.</span><span class="pln">indexOf</span><span class="pun">(</span><span class="str">'px'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!==</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> styles</span><span class="pun">.</span><span class="pln">width </span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> boxSizing </span><span class="pun">=</span><span class="pln"> styles</span><span class="pun">.</span><span class="pln">boxSizing </span><span class="pun">||</span><span class="pln"> </span><span class="str">'content-box'</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">boxSizing </span><span class="pun">===</span><span class="pln"> </span><span class="str">'border-box'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> width</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> borderLeftWidth </span><span class="pun">=</span><span class="pln"> parseFloat</span><span class="pun">(</span><span class="pln">styles</span><span class="pun">.</span><span class="pln">borderLeftWidth</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> borderRightWidth </span><span class="pun">=</span><span class="pln"> parseFloat</span><span class="pun">(</span><span class="pln">styles</span><span class="pun">.</span><span class="pln">borderRightWidth</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> paddingLeft </span><span class="pun">=</span><span class="pln"> parseFloat</span><span class="pun">(</span><span class="pln">styles</span><span class="pun">.</span><span class="pln">paddingLeft</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> paddingRight </span><span class="pun">=</span><span class="pln"> parseFloat</span><span class="pun">(</span><span class="pln">styles</span><span class="pun">.</span><span class="pln">paddingRight</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> width </span><span class="pun">-</span><span class="pln"> borderRightWidth </span><span class="pun">-</span><span class="pln"> borderLeftWidth </span><span class="pun">-</span><span class="pln"> paddingLeft </span><span class="pun">-</span><span class="pln"> paddingRight</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>但上述计算方法并不能完全覆盖所有情况，这需要付出不少的成本去实现。值得高兴的是，React 正在自己构建一个 DOM 排列模型，来努力避免这些 React 之外的 DOM 操作。我们相信在不久的将来，React 的使用者就可以完全抛弃掉 jQuery 等 DOM 操作库。</p>
<p>可以说在 React 组件开发中，还有很多意料之外的情形。在这些情形中，应该如何运用 React 的方式优雅地解决问题是我们需要一直思考的。</p>
<h2><strong>1.7　组件化实例：Tabs 组件</strong></h2>
<p>前面我们穿插介绍了 Tabs 组件的关键实现，现在将把完整的例子展示出来：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pun">,</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">,</span><span class="pln"> cloneElement </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> classnames </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'classnames'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> style </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./tabs.scss'</span><span class="pun">;</span><span class="pln">
</span></code></pre>
<p>这段代码是最基本的引用。除了引用 React 之外，还引用了操作 class 的库 classnames 以及样式文件。这归功于 webpack 强大的加载机制，详情请参考附录 A 中对 webpack 配置的讲解。</p>
<p>Tabs 组件的封装逻辑在之前已经讲解得很清晰了，即把必要的 props 克隆到 TabNav 或 TabContent 组件中，并把它们组装到一起渲染出来。</p>
<p>值得注意的是，我们在 Tabs 组件中设计了切换 tab 时的 <code>onChange</code> 函数，通过传递 <code>onChange</code> prop 到 TabNav 子组件中，在子组件中完成对节点上事件的绑定：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">class</span><span class="pln"> </span><span class="typ">Tabs</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> propTypes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 在主节点上增加可选 class</span><span class="pln">
    className</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">string</span><span class="pun">,</span><span class="pln">
    </span><span class="com">// class 前缀</span><span class="pln">
    classPrefix</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">string</span><span class="pun">,</span><span class="pln">
    children</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">oneOfType</span><span class="pun">([</span><span class="pln">
      </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">arrayOf</span><span class="pun">(</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">node</span><span class="pun">),</span><span class="pln">
      </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">node</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">]),</span><span class="pln">
    </span><span class="com">// 默认激活索引，组件内更新</span><span class="pln">
    defaultActiveIndex</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">number</span><span class="pun">,</span><span class="pln">
    </span><span class="com">// 默认激活索引，组件外更新</span><span class="pln">
    activeIndex</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">number</span><span class="pun">,</span><span class="pln">
    </span><span class="com">// 切换时回调函数</span><span class="pln">
    onChange</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">func</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> defaultProps </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    classPrefix</span><span class="pun">:</span><span class="pln"> </span><span class="str">'tabs'</span><span class="pun">,</span><span class="pln">
    onChange</span><span class="pun">:</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{},</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">
    </span><span class="com">// 对事件方法的绑定</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleTabClick </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleTabClick</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> currProps </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
    let activeIndex</span><span class="pun">;</span><span class="pln">
    </span><span class="com">// 初始化 activeIndex state</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="str">'activeIndex'</span><span class="pln"> </span><span class="kwd">in</span><span class="pln"> currProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      activeIndex </span><span class="pun">=</span><span class="pln"> currProps</span><span class="pun">.</span><span class="pln">activeIndex</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="str">'defaultActiveIndex'</span><span class="pln"> </span><span class="kwd">in</span><span class="pln"> currProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      activeIndex </span><span class="pun">=</span><span class="pln"> currProps</span><span class="pun">.</span><span class="pln">defaultActiveIndex</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      activeIndex</span><span class="pun">,</span><span class="pln">
      prevIndex</span><span class="pun">:</span><span class="pln"> activeIndex</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  componentWillReceiveProps</span><span class="pun">(</span><span class="pln">nextProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 如果 props 传入 activeIndex，则直接更新</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="str">'activeIndex'</span><span class="pln"> </span><span class="kwd">in</span><span class="pln"> nextProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
        activeIndex</span><span class="pun">:</span><span class="pln"> nextProps</span><span class="pun">.</span><span class="pln">activeIndex</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">});</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  handleTabClick</span><span class="pun">(</span><span class="pln">activeIndex</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> prevIndex </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">activeIndex</span><span class="pun">;</span><span class="pln">
    </span><span class="com">// 如果当前 activeIndex 与传入的 activeIndex 不一致，</span><span class="pln">
    </span><span class="com">// 并且 props 中存在 defaultActiveIndex 时，则更新</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">activeIndex </span><span class="pun">!==</span><span class="pln"> activeIndex </span><span class="pun">&amp;&amp;</span><span class="pln">
        </span><span class="str">'defaultActiveIndex'</span><span class="pln"> </span><span class="kwd">in</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
        activeIndex</span><span class="pun">,</span><span class="pln">
        prevIndex</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">});</span><span class="pln">
      </span><span class="com">// 更新后执行回调函数，抛出当前索引和上一次索引</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">onChange</span><span class="pun">({</span><span class="pln"> activeIndex</span><span class="pun">,</span><span class="pln"> prevIndex </span><span class="pun">});</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  renderTabNav</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> classPrefix</span><span class="pun">,</span><span class="pln"> children </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="typ">TabNav</span><span class="pln">
        key</span><span class="pun">=</span><span class="str">"tabBar"</span><span class="pln">
        classPrefix</span><span class="pun">={</span><span class="pln">classPrefix</span><span class="pun">}</span><span class="pln">
        onTabClick</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleTabClick</span><span class="pun">}</span><span class="pln">
        panels</span><span class="pun">={</span><span class="pln">children</span><span class="pun">}</span><span class="pln">
        activeIndex</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">activeIndex</span><span class="pun">}</span><span class="pln">
      </span><span class="pun">/&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  renderTabContent</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> classPrefix</span><span class="pun">,</span><span class="pln"> children </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="typ">TabContent</span><span class="pln">
        key</span><span class="pun">=</span><span class="str">"tabcontent"</span><span class="pln">
        classPrefix</span><span class="pun">={</span><span class="pln">classPrefix</span><span class="pun">}</span><span class="pln">
        panels</span><span class="pun">={</span><span class="pln">children</span><span class="pun">}</span><span class="pln">
        activeIndex</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">activeIndex</span><span class="pun">}</span><span class="pln">
      </span><span class="pun">/&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> className </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
    </span><span class="com">// classnames 用于合并 class</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> classes </span><span class="pun">=</span><span class="pln"> classnames</span><span class="pun">(</span><span class="pln">className</span><span class="pun">,</span><span class="pln"> </span><span class="str">'ui-tabs'</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="pln">div className</span><span class="pun">={</span><span class="pln">classes</span><span class="pun">}&gt;</span><span class="pln">
        </span><span class="pun">{</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">renderTabNav</span><span class="pun">()}</span><span class="pln">
        </span><span class="pun">{</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">renderTabContent</span><span class="pun">()}</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>我们看到，两个子组件 TabNav 和 TabContent 的渲染起到了至关重要的作用。而 TabNav 组件与 TabContent 组件处理的逻辑类似，不同的是前者是从 TabPane 组件的 <code>tab</code> prop 中取得内容，后者是从 TabPane 组件的 <code>children</code> 中取得内容。</p>
<p>我们来看一下 TabNav 组件的实现：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">class</span><span class="pln"> </span><span class="typ">TabNav</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> propTypes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    classPrefix</span><span class="pun">:</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">string</span><span class="pun">,</span><span class="pln">
    panels</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">node</span><span class="pun">,</span><span class="pln">
    activeIndex</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">number</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
  getTabs</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> panels</span><span class="pun">,</span><span class="pln"> classPrefix</span><span class="pun">,</span><span class="pln"> activeIndex </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">Children</span><span class="pun">.</span><span class="pln">map</span><span class="pun">(</span><span class="pln">panels</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln">child</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">child</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln">
      </span><span class="kwd">const</span><span class="pln"> order </span><span class="pun">=</span><span class="pln"> parseInt</span><span class="pun">(</span><span class="pln">child</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">order</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">);</span><span class="pln">
      </span><span class="com">// 利用 class 控制显示和隐藏</span><span class="pln">
      let classes </span><span class="pun">=</span><span class="pln"> classnames</span><span class="pun">({</span><span class="pln">
        </span><span class="pun">[</span><span class="str">`${classPrefix}-tab`</span><span class="pun">]:</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln">
        </span><span class="pun">[</span><span class="str">`${classPrefix}-active`</span><span class="pun">]:</span><span class="pln"> activeIndex </span><span class="pun">===</span><span class="pln"> order</span><span class="pun">,</span><span class="pln">
        </span><span class="pun">[</span><span class="str">`${classPrefix}-disabled`</span><span class="pun">]:</span><span class="pln"> child</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">disabled</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">});</span><span class="pln">
      let events </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{};</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">child</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">disabled</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        events </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
          onClick</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">onTabClick</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> order</span><span class="pun">),</span><span class="pln">
        </span><span class="pun">};</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
      </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">ref</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{};</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">activeIndex </span><span class="pun">===</span><span class="pln"> order</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">ref</span><span class="pun">.</span><span class="kwd">ref</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">'activeTab'</span><span class="pun">;</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">li
          role</span><span class="pun">=</span><span class="str">"tab"</span><span class="pln">
          aria</span><span class="pun">-</span><span class="pln">disabled</span><span class="pun">={</span><span class="pln">child</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">disabled </span><span class="pun">?</span><span class="pln"> </span><span class="str">'true'</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="str">'false'</span><span class="pun">}</span><span class="pln">
          aria</span><span class="pun">-</span><span class="pln">selected</span><span class="pun">={</span><span class="pln">activeIndex </span><span class="pun">===</span><span class="pln"> order</span><span class="pun">?</span><span class="pln"> </span><span class="str">'true'</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="str">'false'</span><span class="pun">}</span><span class="pln">
          </span><span class="pun">{...</span><span class="pln">events</span><span class="pun">}</span><span class="pln">
          className</span><span class="pun">={</span><span class="pln">classes</span><span class="pun">}</span><span class="pln">
          key</span><span class="pun">={</span><span class="pln">order</span><span class="pun">}</span><span class="pln">
          </span><span class="pun">{...</span><span class="kwd">ref</span><span class="pun">}</span><span class="pln">
        </span><span class="pun">&gt;</span><span class="pln">
          </span><span class="pun">{</span><span class="pln">  child</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">tab</span><span class="pun">}</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="str">/li&gt;
      );
    });
  }
  render() {
    const { classPrefix } = this.props;
    const rootClasses = classnames({
      [`${classPrefix}-bar`]: true,
    });
    const classes = classnames({
      [`${classPrefix}-nav`]: true,
    });
    return (
      &lt;div className={rootClasses} role="tablist"&gt;
        &lt;ul className={classes}&gt;
          {this.getTabs()}
        &lt;/</span><span class="pln">ul</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>然后是 TabContent 组件，仔细对比它与前者的不同。再次推敲 TabContent 组件中的 <code>getTabPanes</code> 方法，看似简单，实则精妙：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">class</span><span class="pln"> </span><span class="typ">TabContent</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> propTypes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    classPrefix</span><span class="pun">:</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">string</span><span class="pun">,</span><span class="pln">
    panels</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">node</span><span class="pun">,</span><span class="pln">
    activeIndex</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">number</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
  getTabPanes</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> classPrefix</span><span class="pun">,</span><span class="pln"> activeIndex</span><span class="pun">,</span><span class="pln"> panels </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">Children</span><span class="pun">.</span><span class="pln">map</span><span class="pun">(</span><span class="pln">panels</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln">child</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">child</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln">
      </span><span class="kwd">const</span><span class="pln"> order </span><span class="pun">=</span><span class="pln"> parseInt</span><span class="pun">(</span><span class="pln">child</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">order</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">);</span><span class="pln">
      </span><span class="kwd">const</span><span class="pln"> isActive </span><span class="pun">=</span><span class="pln"> activeIndex </span><span class="pun">===</span><span class="pln"> order</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="pln">cloneElement</span><span class="pun">(</span><span class="pln">child</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        classPrefix</span><span class="pun">,</span><span class="pln">
        isActive</span><span class="pun">,</span><span class="pln">
        children</span><span class="pun">:</span><span class="pln"> child</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">children</span><span class="pun">,</span><span class="pln">
        key</span><span class="pun">:</span><span class="pln"> </span><span class="str">`tabpane-${order}`</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">});</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> classPrefix </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> classes </span><span class="pun">=</span><span class="pln"> classnames</span><span class="pun">({</span><span class="pln">
      </span><span class="pun">[</span><span class="str">`${classPrefix}-content`</span><span class="pun">]:</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="pln">div className</span><span class="pun">={</span><span class="pln">classes</span><span class="pun">}&gt;</span><span class="pln">
        </span><span class="pun">{</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">getTabPanes</span><span class="pun">()}</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>最后是 TabPane 组件，它是最末端的节点，只有最基本的渲染：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">class</span><span class="pln"> </span><span class="typ">TabPane</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> propTypes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    tab</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">oneOfType</span><span class="pun">([</span><span class="pln">
      </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">string</span><span class="pun">,</span><span class="pln">
      </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">node</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">]).</span><span class="pln">isRequired</span><span class="pun">,</span><span class="pln">
    order</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">string</span><span class="pun">.</span><span class="pln">isRequired</span><span class="pun">,</span><span class="pln">
    disable</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">bool</span><span class="pun">,</span><span class="pln">
    isActive</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">bool</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> classPrefix</span><span class="pun">,</span><span class="pln"> className</span><span class="pun">,</span><span class="pln"> isActive</span><span class="pun">,</span><span class="pln"> children </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> classes </span><span class="pun">=</span><span class="pln"> classnames</span><span class="pun">({</span><span class="pln">
      </span><span class="pun">[</span><span class="pln">className</span><span class="pun">]:</span><span class="pln"> className</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">[</span><span class="str">`${classPrefix}-panel`</span><span class="pun">]:</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">[</span><span class="str">`${classPrefix}-active`</span><span class="pun">]:</span><span class="pln"> isActive</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="pln">div
        role</span><span class="pun">=</span><span class="str">"tabpanel"</span><span class="pln">
        className</span><span class="pun">={</span><span class="pln">classes</span><span class="pun">}</span><span class="pln">
        aria</span><span class="pun">-</span><span class="pln">hidden</span><span class="pun">={!</span><span class="pln">isActive</span><span class="pun">}&gt;</span><span class="pln">
        </span><span class="pun">{</span><span class="pln">children</span><span class="pun">}</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>自此，Tabs 组件就开发完毕了。</p>
<h2><strong>1.8　小结</strong></h2>
<p>本章通过穿插 Tabs 组件的实现介绍了 React 的主要概念及 API，为读者开启了通向 React 的大门。</p>
<p>随着章节的深入，我们会陆续介绍 React 高阶使用方法、背后的运行机制、处理数据的架构 Flux 与 Redux。相信从现在开始，你已经做好在 React 的海洋里遨游的准备了。</p>



