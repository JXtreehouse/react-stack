            <h1><strong>第 2 章　漫谈 React</strong></h1>
<p>本章中，我们会从一个视图库所必备的事件系统入手，结合样式处理、组件间抽象的方法以及组件性能优化等，继续展开那些神奇的语法，带领各位漫步于 React 的世界当中。之后，详述实际开发中比较重要的动画与自动化测试。最后，通过一个组件化实例来总结本章的内容。</p>
<p>本章各节之间并没有很强的关联性，读者可以选择感兴趣的直接阅读。但每一节的内容都至关重要，在组件开发中缺一不可，希望读者可以在阅读及练习中领略它的非凡之处。</p>
<h2><strong>2.1　事件系统</strong></h2>
<p>Virtual DOM 在内存中是以对象的形式存在的，如果想要在这些对象上添加事件，就会非常简单。React 基于 Virtual DOM 实现了一个 <code>SyntheticEvent</code> （合成事件）层，我们所定义的事件处理器会接收到一个 <code>SyntheticEvent</code> 对象的实例，它完全符合 W3C 标准，不会存在任何 IE 标准的兼容性问题。并且与原生的浏览器事件一样拥有同样的接口，同样支持事件的冒泡机制，我们可以使用 <code>stopPropagation()</code> 和 <code>preventDefault()</code> 来中断它。</p>
<p>所有事件都自动绑定到最外层上。如果需要访问原生事件对象，可以使用 <code>nativeEvent</code> 属性。</p>
<h3><strong>2.1.1　合成事件的绑定方式</strong></h3>
<p>React 事件的绑定方式在写法上与原生的 HTML 事件监听器属性很相似，并且含义和触发的场景也全都是一致的。比如，下面的 JSX 代码表示为按钮添加点击事件：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;button</span><span class="pln"> </span><span class="atn">onClick</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick</span><span class="pun">}</span><span class="tag">&gt;</span><span class="pln">Test</span><span class="tag">&lt;/button&gt;</span><span class="pln">
</span></code></pre>
<p>仔细观察，我们会发现这种写法与 DOM0 级事件中直接设置 HTML 标签属性为事件处理器的做法还是有很大不同的。在 JSX 中，我们必须使用驼峰的形式来书写事件的属性名（比如<code>onClick</code>），而 HTML 事件则需要使用全部小写的属性名（比如 <code>onclick</code>）。此外，HTML 的属性值只能是 JavaScript 代码字符串，而在 JSX 中，props 的值则可以是任意类型，这里是一个函数指针。如果使用 DOM0 级事件的写法，会是这样的：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;button</span><span class="pln"> </span><span class="atn">onclick</span><span class="pun">=</span><span class="atv">"</span><span class="pln">handleClick</span><span class="pun">()</span><span class="atv">"</span><span class="tag">&gt;</span><span class="pln">Test</span><span class="tag">&lt;/button&gt;</span><span class="pln">
</span></code></pre>
<p>React 并不会像 DOM0 级事件那样将事件处理器直接绑定到 HTML 元素之上。React 仅仅是借鉴了这种写法而已。下面我们来详细看一下事件的内部机制。</p>
<h3><strong>2.1.2　合成事件的实现机制</strong></h3>
<p>在 React 底层，主要对合成事件做了两件事：事件委派和自动绑定。</p>
<p><strong>1. 事件委派</strong></p>
<p>在使用 React 事件前，一定要熟悉它的事件代理机制。它并不会把事件处理函数直接绑定到真实的节点上，而是把所有事件绑定到结构的最外层，使用一个统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象；当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。这样做简化了事件处理和回收机制，效率也有很大提升。</p>
<p><strong>2. 自动绑定</strong></p>
<p>在 React 组件中，每个方法的上下文都会指向该组件的实例，即自动绑定 <code>this</code> 为当前组件。而且 React 还会对这种引用进行缓存，以达到 CPU 和内存的最优化。在使用 ES6 classes 或者纯函数时，这种自动绑定就不复存在了，我们需要手动实现 <code>this</code> 的绑定。</p>
<p>现在我们来看几种绑定的方法。</p>
<ul>
<li><p><strong><code>bind</code> 方法</strong>。这个方法可以帮助我们绑定事件处理器内的 <code>this</code> ，并可以向事件处理器中传递参数，比如：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
　
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  handleClick</span><span class="pun">(</span><span class="pln">e</span><span class="pun">,</span><span class="pln"> arg</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">e</span><span class="pun">,</span><span class="pln"> arg</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
　
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 通过bind方法实现，可以传递参数</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">button onClick</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> </span><span class="str">'test'</span><span class="pun">)}&gt;</span><span class="typ">Test</span><span class="pun">&lt;/</span><span class="pln">button</span><span class="pun">&gt;;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>如果方法只绑定，不传参，那 stage 0 草案中提供了一个便捷的方案<span class="注释编号">1</span>——双冒号语法，其作用与 <code>this.handleClick.bind(this)</code> 一致，并且 Babel 已经实现了该提案。比如：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
　
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  handleClick</span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">e</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
　
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">button onClick</span><span class="pun">={::</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick</span><span class="pun">}&gt;</span><span class="typ">Test</span><span class="pun">&lt;/</span><span class="pln">button</span><span class="pun">&gt;;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
</li>
<li><p><strong>构造器内声明</strong>。在组件的构造器内完成了 <code>this</code> 的绑定，这种绑定方式的好处在于仅需要进行一次绑定，而不需要每次调用事件监听器时去执行绑定操作：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
　
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">

    thishandleClick </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
　
  handleClick</span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">e</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">button onClick</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick</span><span class="pun">}&gt;</span><span class="typ">Test</span><span class="pun">&lt;/</span><span class="pln">button</span><span class="pun">&gt;;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
</li>
<li><p><strong>箭头函数</strong>。箭头函数不仅是函数的“语法糖”，它还自动绑定了定义此函数作用域的 <code>this</code>，因此我们不需要再对它使用 <code>bind</code> 方法。比如，以下方式就能运行：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
　
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> handleClick </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">e</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
　
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">button onClick</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick</span><span class="pun">}&gt;</span><span class="typ">Test</span><span class="pun">&lt;/</span><span class="pln">button</span><span class="pun">&gt;;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>或</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
　
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  handleClick</span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">e</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
　
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">button onClick</span><span class="pun">={()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick</span><span class="pun">()}&gt;</span><span class="typ">Test</span><span class="pun">&lt;/</span><span class="pln">button</span><span class="pun">&gt;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>使用上述几种方式，都能够实现在类定义的组件中绑定 <code>this</code> 上下文的效果。</p>
</li>
</ul>
<p class="注释内容"><span class="注释编号下">1</span>ECMAScrip This-Binding Syntanx，详见 <a href="https://github.com/zenparsing/es-function-bind">https://github.com/zenparsing/es-function-bind</a>。</p>
<h3><strong>2.1.3　在React中使用原生事件</strong></h3>
<p>React 提供了很好用的合成事件系统，但这并不意味着在 React 架构下无法使用原生事件。React 提供了完备的生命周期方法，其中 <code>componentDidMount</code> 会在组件已经完成安装并且在浏览器中存在真实的 DOM 后调用，此时我们就可以完成原生事件的绑定。比如：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">NativeEventDemo</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  componentDidMount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">refs</span><span class="pun">.</span><span class="pln">button</span><span class="pun">.</span><span class="pln">addEventListener</span><span class="pun">(</span><span class="str">'click'</span><span class="pun">,</span><span class="pln"> e </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick</span><span class="pun">(</span><span class="pln">e</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  handleClick</span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">e</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  componentWillUnmount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">refs</span><span class="pun">.</span><span class="pln">button</span><span class="pun">.</span><span class="pln">removeEventListener</span><span class="pun">(</span><span class="str">'click'</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">button </span><span class="kwd">ref</span><span class="pun">=</span><span class="str">"button"</span><span class="pun">&gt;</span><span class="typ">Test</span><span class="pun">&lt;/</span><span class="pln">button</span><span class="pun">&gt;;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>值得注意的是，在 React 中使用 DOM 原生事件时，一定要在组件卸载时手动移除，否则很可能出现内存泄漏的问题。而使用合成事件系统时则不需要，因为 React 内部已经帮你妥善地处理了。</p>
<h3><strong>2.1.4　合成事件与原生事件混用</strong></h3>
<p>既然 React 合成事件系统有这么多的好处，那是不是 React 中就不需要原生事件了呢？当然不是，因为还有很多应用场景只能借助原生事件的帮助才能完成。比如，在 Web 页面中添加一个使用移动设备扫描二维码的功能，在点击按钮时显示二维码，点击非二维码区域时将其隐藏起来。示例代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">QrCode</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClickQr </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClickQr</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      active</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  componentDidMount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    document</span><span class="pun">.</span><span class="pln">body</span><span class="pun">.</span><span class="pln">addEventListener</span><span class="pun">(</span><span class="str">'click'</span><span class="pun">,</span><span class="pln"> e </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
        active</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">});</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  componentWillUnmount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    document</span><span class="pun">.</span><span class="pln">body</span><span class="pun">.</span><span class="pln">removeEventListener</span><span class="pun">(</span><span class="str">'click'</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  handleClick</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
      active</span><span class="pun">:</span><span class="pln"> </span><span class="pun">!</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">active</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  handleClickQr</span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    e</span><span class="pun">.</span><span class="pln">stopPropagation</span><span class="pun">();</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="pln">div className</span><span class="pun">=</span><span class="str">"qr-wrapper"</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">button className</span><span class="pun">=</span><span class="str">"qr"</span><span class="pln"> onClick</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick</span><span class="pun">}&gt;二维码&lt;/</span><span class="pln">button</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">div
          className</span><span class="pun">=</span><span class="str">"code"</span><span class="pln">
          style</span><span class="pun">={{</span><span class="pln"> display</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">active </span><span class="pun">?</span><span class="pln"> </span><span class="str">'block'</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="str">'none'</span><span class="pln"> </span><span class="pun">}}</span><span class="pln">
          onClick</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClickQr</span><span class="pun">}</span><span class="pln">
        </span><span class="pun">&gt;</span><span class="pln">
          </span><span class="pun">&lt;</span><span class="pln">img src</span><span class="pun">=</span><span class="str">"qr.jpg"</span><span class="pln"> alt</span><span class="pun">=</span><span class="str">"qr"</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="str">/div&gt;
      &lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>上述代码的逻辑很简单，点击按钮可以切换二维码的显示与隐藏，而在按钮之外的区域同样可以达到隐藏的效果。然而，我们无法在组件中将事件绑定到 <code>body</code> 上，因为 <code>body</code> 在组件范围之外，只能使用原生绑定事件来实现。</p>
<p>逻辑似乎很简单，但 React 所表现的似乎与你所想的并不一致，实际效果是在你点击二维码区域时二维码依然会隐藏起来。原因也很简单，就是 React 合成事件系统的委托机制，在合成事件内部仅仅对最外层的容器进行了绑定，并且依赖事件的冒泡机制完成了委派。也就是说，事件并没有直接绑定到 <code>div.qr</code> 元素上，所以在这里使用 <code>e.stopPropagation()</code> 并没有用。当然，解决方法也很简单。</p>
<ul>
<li><p><strong>不要将合成事件与原生事件混用</strong>。比如：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">componentDidMount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  document</span><span class="pun">.</span><span class="pln">body</span><span class="pun">.</span><span class="pln">addEventListener</span><span class="pun">(</span><span class="str">'click'</span><span class="pun">,</span><span class="pln"> e </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
      active</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">
　
  document</span><span class="pun">.</span><span class="pln">querySelector</span><span class="pun">(</span><span class="str">'.code'</span><span class="pun">).</span><span class="pln">addEventListener</span><span class="pun">(</span><span class="str">'click'</span><span class="pun">,</span><span class="pln"> e </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    e</span><span class="pun">.</span><span class="pln">stopPropagation</span><span class="pun">();</span><span class="pln">
  </span><span class="pun">})</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

componentWillUnmount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  document</span><span class="pun">.</span><span class="pln">body</span><span class="pun">.</span><span class="pln">removeEventListener</span><span class="pun">(</span><span class="str">'click'</span><span class="pun">);</span><span class="pln">
  document</span><span class="pun">.</span><span class="pln">querySelector</span><span class="pun">(</span><span class="str">'.qr'</span><span class="pun">).</span><span class="pln">removeEventListener</span><span class="pun">(</span><span class="str">'click'</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></code></pre>
</li>
<li><p><strong>通过 <code>e.target</code> 判断来避免</strong>。示例代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">componentDidMount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  document</span><span class="pun">.</span><span class="pln">body</span><span class="pun">.</span><span class="pln">addEventListener</span><span class="pun">(</span><span class="str">'click'</span><span class="pun">,</span><span class="pln"> e </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">e</span><span class="pun">.</span><span class="pln">target </span><span class="pun">&amp;&amp;</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">target</span><span class="pun">.</span><span class="pln">matches</span><span class="pun">(</span><span class="str">'div.code'</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
　
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
      active</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
</li>
</ul>
<p>所以，请尽量避免在 React 中混用合成事件和原生 DOM 事件。另外，用 <code>reactEvent.nativeEvent.stopPropagation()</code> 来阻止冒泡是不行的。阻止 React 事件冒泡的行为只能用于 React 合成事件系统中，且没办法阻止原生事件的冒泡。反之，在原生事件中的阻止冒泡行为，却可以阻止 React 合成事件的传播。</p>
<p>实际上，React 的合成事件系统只是原生 DOM 事件系统的一个子集。它仅仅实现了 DOM Level 3 的事件接口，并且统一了浏览器间的兼容问题。有些事件 React 并没有实现，或者受某些限制没办法去实现，比如 <code>window</code> 的 <code>resize</code> 事件。</p>
<p>对于无法使用 React 合成事件的场景，我们还需要使用原生事件来完成。</p>
<h3><strong>2.1.5　对比React合成事件与JavaScript原生事件</strong></h3>
<p>下面我们从 4 个方面来对比 React 合成事件与 JavaScript 原生事件。</p>
<p><strong>1. 事件传播与阻止事件传播</strong></p>
<p>浏览器原生 DOM 事件的传播可以分为 3 个阶段：事件捕获阶段、目标对象本身的事件处理程序调用以及事件冒泡。事件捕获会优先调用结构树最外层的元素上绑定的事件监听器，然后依次向内调用，一直调用到目标元素上的事件监听器为止。可以在将 <code>e.addEventListener()</code> 的第三个参数设置为 <code>true</code> 时，为元素 <code>e</code> 注册捕获事件处理程序，并且在事件传播的第一个阶段调用。此外，事件捕获并不是一个通用的技术，在低于 IE9 版本的浏览器中无法使用。而事件冒泡则与事件捕获的表现相反，它会从目标元素向外传播事件，由内而外直到最外层。</p>
<p>可以看出，事件捕获在程序开发中的意义并不大，更致命的是它的兼容性问题。所以，React 的合成事件则并没有实现事件捕获，仅仅支持了事件冒泡机制。这种 API 设计方式统一而简洁，符合“二八原则”。</p>
<p>阻止原生事件传播需要使用 <code>e.preventDefault()</code>，不过对于不支持该方法的浏览器（IE9 以下），只能使用 <code>e.cancelBubble = true</code> 来阻止。而在 React 合成事件中，只需要使用 <code>e.preventDefault()</code> 即可。</p>
<p><strong>2. 事件类型</strong></p>
<p>React 合成事件的事件类型是 JavaScript 原生事件类型的一个子集。</p>
<p><strong>3. 事件绑定方式</strong></p>
<p>受到 DOM 标准的影响，绑定浏览器原生事件的方式也有很多种，具体如下所示。</p>
<ul>
<li><p>直接在 DOM 元素中绑定：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;button</span><span class="pln"> </span><span class="atn">onclick</span><span class="pun">=</span><span class="atv">"</span><span class="pln">alert</span><span class="pun">(</span><span class="lit">1</span><span class="pun">);</span><span class="atv">"</span><span class="tag">&gt;</span><span class="pln">Test</span><span class="tag">&lt;/button&gt;</span></code></pre>
</li>
<li><p>在 JavaScript 中，通过为元素的事件属性赋值的方式实现绑定：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">el</span><span class="pun">.</span><span class="pln">onclick </span><span class="pun">=</span><span class="pln"> e </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">e</span><span class="pun">);</span><span class="pln"> </span><span class="pun">}</span></code></pre>
</li>
<li><p>通过事件监听函数来实现绑定：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">el</span><span class="pun">.</span><span class="pln">addEventListener</span><span class="pun">(</span><span class="str">'click'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{},</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
el</span><span class="pun">.</span><span class="pln">attachEvent</span><span class="pun">(</span><span class="str">'onclick'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{});</span><span class="pln">
</span></code></pre>
</li>
</ul>
<p>相比而言，React 合成事件的绑定方式则简单得多：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;button</span><span class="pln"> </span><span class="atn">onClick</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick</span><span class="pun">}</span><span class="tag">&gt;</span><span class="pln">Test</span><span class="tag">&lt;/button&gt;</span><span class="pln">
</span></code></pre>
<p><strong>4. 事件对象</strong></p>
<p>原生 DOM 事件对象在 W3C 标准和 IE 标准下存在着差异。在低版本的 IE 浏览器中，只能使用 <code>window.event</code> 来获取事件对象。而在 React 合成事件系统中，不存在这种兼容性问题，在事件处理函数中可以得到一个合成事件对象。</p>
<h2><strong>2.2　表单</strong></h2>
<p>在 Web 应用开发中，表单的作用尤为重要。正是因为表单的存在，才使得用户能够与 Web 应用进行富交互。打开搜索引擎输入关键字进行检索，这个过程就是一次基于表单的交互。而在 React 中，一切数据都是状态，当然也包括表单数据。在这一节中，我们将讲述 React 是如何处理表单的。</p>
<h3><strong>2.2.1　应用表单组件</strong></h3>
<p>HTML 表单中的所有组件在 React 的 JSX 都有相应的实现，只是它们在用法上有些区别，有些是 JSX 语法上的，有些则是由于 React 对状态处理上导致的一些区别。</p>
<p><strong>1. 文本框</strong></p>
<p>这里的文本框包括单行文本输入框 <code>input</code> 以及多行文本输入框 <code>textarea</code>。下面先看一个关于这两种文本框的示例：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleInputChange </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleInputChange</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleTextareaChange </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleTextareaChange</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      inputValue</span><span class="pun">:</span><span class="pln"> </span><span class="str">''</span><span class="pun">,</span><span class="pln">
      textareaValue</span><span class="pun">:</span><span class="pln"> </span><span class="str">''</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  handleInputChange</span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
      inputValue</span><span class="pun">:</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">target</span><span class="pun">.</span><span class="pln">value</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  handleTextareaChange</span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
      textareaValue</span><span class="pun">:</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">target</span><span class="pun">.</span><span class="pln">value</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> inputValue</span><span class="pun">,</span><span class="pln"> textareaValue </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="str">&lt;div&gt;</span><span class="pln">
        </span><span class="str">&lt;p&gt;</span><span class="pun">单行输入框：&lt;</span><span class="pln">input type</span><span class="pun">=</span><span class="str">"text"</span><span class="pln"> value</span><span class="pun">={</span><span class="pln">inputValue</span><span class="pun">}</span><span class="pln">
          onChange</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleInputChange</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;&lt;/</span><span class="pln">p</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="str">&lt;p&gt;</span><span class="pun">多行输入框：&lt;</span><span class="pln">textarea value</span><span class="pun">={</span><span class="pln">textareaValue</span><span class="pun">}</span><span class="pln">
          onChange</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleTextareaChange</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;&lt;/</span><span class="pln">p</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>值得注意的是，我们可以看到，JSX 中的 <code>textarea</code> 组件与类型为 <code>text</code> 的 <code>input</code> 组件的用法很类似。同样有一个 <code>value</code> prop 用来表示表单的值，而在 HTML 中 <code>textarea</code> 的值则是通过 <code>children</code> 来表示的。此外，得益于 JSX 语法特性，我们可以在标签没有子元素的时候使用单个标签自闭合的语法。</p>
<p><strong>2. 单选按钮与复选框</strong></p>
<p>在 HTML 中，用类型为 <code>radio</code> 的 <code>input</code> 标签表示单选按钮。类似地，用类型为 <code>checkbox</code> 的<code>input</code> 标签表示复选框。这两种表单的 <code>value</code> 值一般是不会改变的，而是通过一个布尔类型的<code>checked</code> prop 来表示是否为选中状态。当然，在 JSX 中这些也是相同的，不过用法上还是有些区别。</p>
<p>下面看一下单选按钮的示例：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handeChange </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      radioValue</span><span class="pun">:</span><span class="pln"> </span><span class="str">''</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  handleChange</span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
      radioValue</span><span class="pun">:</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">target</span><span class="pun">.</span><span class="pln">value</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> radioValue </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="str">&lt;div&gt;</span><span class="pln">
        </span><span class="str">&lt;p&gt;</span><span class="pln">gender</span><span class="pun">:&lt;/</span><span class="pln">p</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="str">&lt;label&gt;</span><span class="pln">
          male</span><span class="pun">:</span><span class="pln">
          </span><span class="pun">&lt;</span><span class="pln">input
            type</span><span class="pun">=</span><span class="str">"radio"</span><span class="pln">
            value</span><span class="pun">=</span><span class="str">"male"</span><span class="pln">
            </span><span class="kwd">checked</span><span class="pun">={</span><span class="pln">radioValue </span><span class="pun">===</span><span class="pln"> </span><span class="str">'male'</span><span class="pun">}</span><span class="pln">
            onChange</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange</span><span class="pun">}</span><span class="pln">
          </span><span class="pun">/&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="str">/label&gt;
        &lt;label&gt;
          female:
          &lt;input
            type="radio"
            value="female"
            checked={radioValue === 'female'}
            onChange={this.handleChange}
          /</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="str">/label&gt;
      &lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>下面看一下复选框的示例：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      coffee</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[],</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  handleChange</span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">checked</span><span class="pun">,</span><span class="pln"> value </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">target</span><span class="pun">;</span><span class="pln">
    let </span><span class="pun">{</span><span class="pln"> coffee </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">checked</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> coffee</span><span class="pun">.</span><span class="pln">indexOf</span><span class="pun">(</span><span class="pln">value</span><span class="pun">)</span><span class="pln"> </span><span class="pun">===</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      coffee</span><span class="pun">.</span><span class="pln">push</span><span class="pun">(</span><span class="pln">value</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      coffee </span><span class="pun">=</span><span class="pln"> coffee</span><span class="pun">.</span><span class="pln">filter</span><span class="pun">(</span><span class="pln">i </span><span class="pun">=&gt;</span><span class="pln"> i </span><span class="pun">!==</span><span class="pln"> value</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
      coffee</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> coffee </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="str">&lt;div&gt;</span><span class="pln">
        </span><span class="str">&lt;p&gt;</span><span class="pun">请选择你最喜欢的咖啡：&lt;/</span><span class="pln">p</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="str">&lt;label&gt;</span><span class="pln">
          </span><span class="pun">&lt;</span><span class="pln">input
            type</span><span class="pun">=</span><span class="str">"checkbox"</span><span class="pln">
            value</span><span class="pun">=</span><span class="str">"Cappuccino"</span><span class="pln">
            </span><span class="kwd">checked</span><span class="pun">={</span><span class="pln">coffee</span><span class="pun">.</span><span class="pln">indexOf</span><span class="pun">(</span><span class="str">'Cappuccino'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!==</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">}</span><span class="pln">
            onChange</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange</span><span class="pun">}</span><span class="pln">
          </span><span class="pun">/&gt;</span><span class="pln">
          </span><span class="typ">Cappuccino</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="str">/label&gt;
        &lt;br/</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="str">&lt;label&gt;</span><span class="pln">
          </span><span class="pun">&lt;</span><span class="pln">input
            type</span><span class="pun">=</span><span class="str">"checkbox"</span><span class="pln">
            value</span><span class="pun">=</span><span class="str">"CafeMocha"</span><span class="pln">
            </span><span class="kwd">checked</span><span class="pun">={</span><span class="pln">coffee</span><span class="pun">.</span><span class="pln">indexOf</span><span class="pun">(</span><span class="str">'CafeMocha'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!==</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">}</span><span class="pln">
            onChange</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange</span><span class="pun">}</span><span class="pln">
          </span><span class="pun">/&gt;</span><span class="pln">
          </span><span class="typ">CafeMocha</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="str">/label&gt;
        &lt;br/</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="str">&lt;label&gt;</span><span class="pln">
          </span><span class="pun">&lt;</span><span class="pln">input
            type</span><span class="pun">=</span><span class="str">"checkbox"</span><span class="pln">
            value</span><span class="pun">=</span><span class="str">"CaffeLatte"</span><span class="pln">
            </span><span class="kwd">checked</span><span class="pun">={</span><span class="pln">coffee</span><span class="pun">.</span><span class="pln">indexOf</span><span class="pun">(</span><span class="str">'CaffeLatte'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!==</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">}</span><span class="pln">
            onChange</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange</span><span class="pun">}</span><span class="pln">
          </span><span class="pun">/&gt;</span><span class="pln">
          </span><span class="typ">Caff</span><span class="pun">è</span><span class="pln"> </span><span class="typ">Latte</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="str">/label&gt;
        &lt;br/</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="str">&lt;label&gt;</span><span class="pln">
          </span><span class="pun">&lt;</span><span class="pln">input
            type</span><span class="pun">=</span><span class="str">"checkbox"</span><span class="pln">
            value</span><span class="pun">=</span><span class="str">"Machiatto"</span><span class="pln">
            </span><span class="kwd">checked</span><span class="pun">={</span><span class="pln">coffee</span><span class="pun">.</span><span class="pln">indexOf</span><span class="pun">(</span><span class="str">'Machiatto'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">!==</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">}</span><span class="pln">
            onChange</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange</span><span class="pun">}</span><span class="pln">
          </span><span class="pun">/&gt;</span><span class="pln">
          </span><span class="typ">Machiatto</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="str">/label&gt;
      &lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>如果之前没有了解过，一定会对 React 的处理方式产生疑问。在 HTML 中，很简单的单选按钮和复选框好像变得很复杂了。确实，因为 React 对表单的状态进行了控制，相应地多了一些处理 <code>onChange</code> 的代码。另外，状态里面已经可以拿到复选框所表示的选中值的列表，这一步在 HTML 表单处理中同样需要我们通过 JavaScript 手动处理。</p>
<p><strong>3. Select 组件</strong></p>
<p>在 HTML 的 <code>select</code> 元素中，存在单选和多选两种。在 JSX 语法中，同样可以通过设置 <code>select</code> 标签的 <code>multiple={true}</code> 来实现一个多选下拉列表。Select 组件与单选按钮和复选框组件有些类似。下面我们来看下 React 中 <code>select</code> 元素的用法：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      area</span><span class="pun">:</span><span class="pln"> </span><span class="str">''</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  handleChange</span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
      area</span><span class="pun">:</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">target</span><span class="pun">.</span><span class="pln">value</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> area </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="kwd">select</span><span class="pln"> value</span><span class="pun">={</span><span class="pln">area</span><span class="pun">}</span><span class="pln"> onChange</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange</span><span class="pun">}&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">option value</span><span class="pun">=</span><span class="str">"beijing"</span><span class="pun">&gt;北京&lt;/</span><span class="pln">option</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">option value</span><span class="pun">=</span><span class="str">"shanghai"</span><span class="pun">&gt;上海&lt;/</span><span class="pln">option</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">option value</span><span class="pun">=</span><span class="str">"hangzhou"</span><span class="pun">&gt;杭州&lt;/</span><span class="pln">option</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="kwd">select</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>接下来，看看给 <code>select</code> 元素设置 <code>multiple={true}</code> 的示例：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      area</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[</span><span class="str">'beijing'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'shanghai'</span><span class="pun">],</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  handleChange</span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> options </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">target</span><span class="pun">;</span><span class="pln">
    </span><span class="com">// 注意，这里返回的 options 是一个对象，并非数组</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> area </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Object</span><span class="pun">.</span><span class="pln">keys</span><span class="pun">(</span><span class="pln">options</span><span class="pun">)</span><span class="pln">
      </span><span class="pun">.</span><span class="pln">filter</span><span class="pun">(</span><span class="pln">i </span><span class="pun">=&gt;</span><span class="pln"> options</span><span class="pun">[</span><span class="pln">i</span><span class="pun">].</span><span class="pln">selected </span><span class="pun">===</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">)</span><span class="pln">
      </span><span class="pun">.</span><span class="pln">map</span><span class="pun">(</span><span class="pln">i </span><span class="pun">=&gt;</span><span class="pln"> options</span><span class="pun">[</span><span class="pln">i</span><span class="pun">].</span><span class="pln">value</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
      area</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> area </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="kwd">select</span><span class="pln"> multiple</span><span class="pun">={</span><span class="kwd">true</span><span class="pun">}</span><span class="pln"> value</span><span class="pun">={</span><span class="pln">area</span><span class="pun">}</span><span class="pln"> onChange</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange</span><span class="pun">}&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">option value</span><span class="pun">=</span><span class="str">"beijing"</span><span class="pun">&gt;北京&lt;/</span><span class="pln">option</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">option value</span><span class="pun">=</span><span class="str">"shanghai"</span><span class="pun">&gt;上海&lt;/</span><span class="pln">option</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">option value</span><span class="pun">=</span><span class="str">"hangzhou"</span><span class="pun">&gt;杭州&lt;/</span><span class="pln">option</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="kwd">select</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>这里，我们再来对比一下 React 处理 <code>select</code> 的方式与 HTML 原生方式的区别。在 HTML 的<code>option</code> 组件中需要一个 <code>selected</code> 属性来表示默认选中的列表项，而 React 的处理方式则是通过为 <code>select</code> 组件添加 <code>value</code> prop 来表示选中的 <code>option</code> ，在设置了 <code>multiple={true}</code> 的情况下，该<code>value</code> 值是一个数组，表示选中的一组值。这一点与 <code>textarea</code> 的处理方式一致，这在一定程度上统一了接口。</p>
<p>实际上，上述 select 组件也可以写成下面这种形式：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;select</span><span class="pln"> </span><span class="atn">multiple</span><span class="pun">=</span><span class="atv">{true}</span><span class="pln"> </span><span class="atn">onChange</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange</span><span class="pun">}</span><span class="tag">&gt;</span><span class="pln">
  </span><span class="tag">&lt;option</span><span class="pln"> </span><span class="atn">value</span><span class="pun">=</span><span class="atv">"beijing"</span><span class="pln"> </span><span class="atn">selected</span><span class="pun">=</span><span class="atv">{area.indexOf('beijing'</span><span class="pln">) !</span><span class="atv">=</span><span class="pun">=</span><span class="pln"> -1}</span><span class="tag">&gt;</span><span class="pln">北京</span><span class="tag">&lt;/option&gt;</span><span class="pln">
  </span><span class="tag">&lt;option</span><span class="pln"> </span><span class="atn">value</span><span class="pun">=</span><span class="atv">"shanghai"</span><span class="pln"> </span><span class="atn">selected</span><span class="pun">=</span><span class="atv">{area.indexOf('shanghai'</span><span class="pln">) !</span><span class="atv">=</span><span class="pun">=</span><span class="pln"> -1}</span><span class="tag">&gt;</span><span class="pln">上海</span><span class="tag">&lt;/option&gt;</span><span class="pln">
  </span><span class="tag">&lt;option</span><span class="pln"> </span><span class="atn">value</span><span class="pun">=</span><span class="atv">"hangzhou"</span><span class="pln"> </span><span class="atn">selected</span><span class="pun">=</span><span class="atv">{area.indexOf('hangzhou'</span><span class="pln">) !</span><span class="atv">=</span><span class="pun">=</span><span class="pln"> -1}</span><span class="tag">&gt;</span><span class="pln">杭州</span><span class="tag">&lt;/option&gt;</span><span class="pln">
</span><span class="tag">&lt;/select&gt;</span><span class="pln">
</span></code></pre>
<p>不过开发体验就会差很多，同时 React 也会报如下的警告：</p>
<pre class="代码无行号 prettyprint"><code><span class="typ">Warning</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Use</span><span class="pln"> the defaultValue </span><span class="kwd">or</span><span class="pln"> value props on </span><span class="str">&lt;select&gt;</span><span class="pln"> instead of setting selected on </span><span class="str">&lt;option&gt;</span><span class="pln">
</span></code></pre>
<h3><strong>2.2.2　受控组件</strong></h3>
<p>读完了上面的几个示例，你心中一定会有疑问，为何每一个 <code>&lt;input&gt;</code> 或 <code>&lt;select&gt;</code> 都要绑定一个 <code>change</code> 事件呢？</p>
<p>在上面的示例中，每当表单的状态发生变化时，都会被写入到组件的 state 中，这种组件在 React 中被称为受控组件（controlled component）。在受控组件中，组件渲染出的状态与它的 <code>value</code> 或 <code>checked</code> prop 相对应。React 通过这种方式消除了组件的局部状态，使得应用的整个状态更加可控。React 官方同样推荐使用受控表单组件。总结下 React 受控组件更新 state 的流程：</p>
<p>(1) 可以通过在初始 state 中设置表单的默认值。</p>
<p>(2) 每当表单的值发生变化时，调用 <code>onChange</code> 事件处理器。</p>
<p>(3) 事件处理器通过合成事件对象 <code>e</code> 拿到改变后的状态，并更新应用的 state。</p>
<p>(4) <code>setState</code> 触发视图的重新渲染，完成表单组件值的更新。</p>
<p>在 React 中，数据是单向流动的。从示例中，我们能看出来表单的数据源于组件的 state，并通过 props 传入，这也称为单向数据绑定。然后，我们又通过 <code>onChange</code> 事件处理器将新的表单数据写回到组件的 state，完成了双向数据绑定。</p>
<p>与原生表单组件相比，受控组件的模式确实复杂了很多。每次表单值发生变化时，都会执行上面几步，这样统一了组件内部状态，使得表单的状态更可靠。这也意味着我们可以在执行最后一步 <code>setState</code> 前，对表单值进行清洗和校验。示例如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">handleChange</span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
    value</span><span class="pun">:</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">target</span><span class="pun">.</span><span class="pln">value</span><span class="pun">.</span><span class="pln">substring</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">140</span><span class="pun">).</span><span class="pln">toUpperCase</span><span class="pun">(),</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>上面的代码做到了截取用户输入的前 140 个字符，并转为大写。实际上，在 React 内部拦截了浏览器的原生事件，这得益于 Virtual DOM 以及合成事件系统。</p>
<h3><strong>2.2.3　非受控组件</strong></h3>
<p>上面的所有示例都使用了 React 的受控组件来写，但这并不意味着它不支持非受控组件。那么什么是非受控组件（uncontrolled component）呢？</p>
<p>简单地说，如果一个表单组件没有 value props（单选按钮和复选框对应的是 <code>checked</code> prop）时，就可以称为非受控组件。相应地，你可以使用 <code>defaultValue</code> 和 <code>defaultChecked</code> prop 来表示组件的默认状态。下面通过一个简单的示例来描述非受控组件：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleSubmit </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleSubmit</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  handleSubmit</span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    e</span><span class="pun">.</span><span class="pln">preventDefault</span><span class="pun">();</span><span class="pln">

    </span><span class="com">// 这里使用 React 提供的 ref prop 来操作 DOM</span><span class="pln">
    </span><span class="com">// 当然，也可以使用原生的接口，如 document.querySelector</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> value </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">refs</span><span class="pun">.</span><span class="pln">name</span><span class="pun">;</span><span class="pln">
    console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">value</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="pln">form onSubmit</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleSubmit</span><span class="pun">}&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">input </span><span class="kwd">ref</span><span class="pun">=</span><span class="str">"name"</span><span class="pln"> type</span><span class="pun">=</span><span class="str">"text"</span><span class="pln"> defaultValue</span><span class="pun">=</span><span class="str">"Hangzhou"</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">button type</span><span class="pun">=</span><span class="str">"submit"</span><span class="pun">&gt;</span><span class="typ">Submit</span><span class="pun">&lt;</span><span class="str">/button&gt;
      &lt;/</span><span class="pln">form</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>在 React 中，非受控组件是一种反模式，它的值不受组件自身的 state 或 props 控制。通常，需要通过为其添加 <code>ref</code> prop 来访问渲染后的底层 DOM 元素。</p>
<h3><strong>2.2.4　对比受控组件和非受控组件</strong></h3>
<p>受控组件与非受控组件到底各自有什么特点和适用场景呢？</p>
<p>我们刚才看到通过 <code>defaultValue</code> 或者 <code>defaultChecked</code> 来设置表单的默认值，它仅会被渲染一次，在后续的渲染时并不起作用。下面对比以下两个示例。</p>
<p>将输入的字母转化为大写展示：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;input</span><span class="pln">
  </span><span class="atn">value</span><span class="pun">=</span><span class="atv">{this.state.value}</span><span class="pln">
  </span><span class="atn">onChange</span><span class="pun">={</span><span class="pln">e </span><span class="tag">=&gt;</span><span class="pln"> {
    this.setState({ value: e.target.value.toUpperCase() })
  }}
/&gt;
</span></code></pre>
<p>直接展示输入的字母：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;input</span><span class="pln">
  </span><span class="atn">defaultValue</span><span class="pun">=</span><span class="atv">{this.state.value}</span><span class="pln">
  </span><span class="atn">onChange</span><span class="pun">={</span><span class="pln">e </span><span class="tag">=&gt;</span><span class="pln"> {
    this.setState({ value: e.target.value.toUpperCase() })
  }}
/&gt;
</span></code></pre>
<p>在受控组件中，可以将用户输入的英文字母转化为大写后输出展示，而在非受控组件中则不会。而如果不对受控组件绑定 <code>change</code> 事件，我们在文本框中输入任何值都不会起作用。多数情况下，对于非受控组件，我们并不需要提供 <code>change</code> 事件。通过上面的示例可以看出，受控组件和非受控组件的最大区别是：非受控组件的状态并不会受应用状态的控制，应用中也多了局部组件状态，而受控组件的值来自于组件的 state。</p>
<p><strong>1. 性能上的问题</strong></p>
<p>在受控组件中，每次表单的值发生变化时，都会调用一次 <code>onChange</code> 事件处理器，这确实会有一些性能上的损耗。虽然使用非受控组件不会出现这些问题，但仍然不提倡在 React 中使用非受控组件。这个问题可以通过 Flux/Redux 应用架构等方式来达到统一组件状态的目的。</p>
<p><strong>2. 是否需要事件绑定</strong></p>
<p>使用受控组件最令人头疼的就是，我们需要为每个组件绑定一个 <code>change</code> 事件，并且定义一个事件处理器来同步表单值和组件的状态，这是一个必要条件。当然，在某些简单的情况下，也可以使用一个事件处理器来处理多个表单域：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">FormApp</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      name</span><span class="pun">:</span><span class="pln"> </span><span class="str">''</span><span class="pun">,</span><span class="pln">
      age</span><span class="pun">:</span><span class="pln"> </span><span class="lit">18</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  handleChange</span><span class="pun">(</span><span class="pln">name</span><span class="pun">,</span><span class="pln"> e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> value </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> e</span><span class="pun">.</span><span class="pln">target</span><span class="pun">;</span><span class="pln">
    </span><span class="com">// 这里只能处理直接赋值这种简单的情况，复杂的处理建议使用 switch(name) 语句</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
      </span><span class="pun">[</span><span class="pln">name</span><span class="pun">]:</span><span class="pln"> value</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">


  render </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> name</span><span class="pun">,</span><span class="pln"> age </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="str">&lt;div&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">input value</span><span class="pun">={</span><span class="pln">name</span><span class="pun">}</span><span class="pln"> onChange</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> </span><span class="str">'name'</span><span class="pun">)}</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">input value</span><span class="pun">={</span><span class="pln">age</span><span class="pun">}</span><span class="pln"> onChange</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> </span><span class="str">'age'</span><span class="pun">)}</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<h3><strong>2.2.5　表单组件的几个重要属性</strong></h3>
<p>在这一节中，我们简要介绍一下表单组件的状态属性和事件属性。</p>
<p><strong>1. 状态属性</strong></p>
<p>React 的 form 组件提供了几个重要的属性，用于展示组件的状态。</p>
<ul>
<li><p><strong><code>value</code></strong>：类型为 <code>text</code> 的 input 组件、textarea 组件以及 select 组件都借助 <code>value</code> prop 来展示应用的状态。</p>
</li>
<li><p><strong><code>checked</code></strong>：类型为 <code>radio</code> 或 <code>checkbox</code> 的组件借助值为 <code>boolean</code> 类型的 <code>selected</code> prop 来展示应用的状态。</p>
</li>
<li><p><strong><code>selected</code></strong>：该属性可作用于 select 组件下面的 <code>option</code> 上，React 并不建议使用这种方式表示状态，而推荐在 select 组件上使用 <code>value</code> 的方式。</p>
</li>
</ul>
<p><strong>2. 事件属性</strong></p>
<p>刚刚提到的状态属性与事件属性存在一定的关联——在状态属性发生变化时，会触发 <code>onChange</code> 事件属性。实际上，受控组件中的 <code>change</code> 事件与 HTML DOM 中提供的 <code>input</code> 事件更为类似<span class="注释编号">2</span>。同样，React 支持 DOM Level 3 中定义的所有表单事件。</p>
<p class="注释内容"><span class="注释编号下">2</span>GlobalEventHandlers.oninput，详见 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/oninput">https://developer.mozilla.org/zh-CN/docs/Web/API/GlobalEventHandlers/oninput</a>。</p>
<h2><strong>2.3　样式处理</strong></h2>
<p>在 React 中，处理样式是至关重要的一环，也是当下非常热门的话题。在这一节中，我们除了介绍基本样式设置之外，还会讲到现在业界很火的 CSS Modules 的概念及用法。</p>
<h3><strong>2.3.1　基本样式设置</strong></h3>
<p>React 组件最终会生成 HTML，所以你可以使用给普通 HTML 设置 CSS 一样的方法来设置样式。如果我们想给组件添加类名，为了避免命名冲突，React 中需要设置 <code>className</code> prop。此外，也可以通过 <code>style</code> prop 来给组件设置行内样式，这里要注意 <code>style</code> prop 需要的是一个对象。</p>
<p>设置样式时，需要注意以下几点：</p>
<ul>
<li><p>自定义组件建议支持 <code>className</code> prop，以让用户使用时添加自定义样式；</p>
</li>
<li><p>设置行内样式时要使用对象。</p>
</li>
</ul>
<p>设置样式的示例代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> style </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  color</span><span class="pun">:</span><span class="pln"> </span><span class="str">'white'</span><span class="pun">,</span><span class="pln">
  backgroundImage</span><span class="pun">:</span><span class="pln"> </span><span class="str">`url(${imgUrl})`</span><span class="pun">,</span><span class="pln">
  </span><span class="com">// 注意这里大写的 W，会转换成 -webkit-transition</span><span class="pln">
  </span><span class="typ">WebkitTransition</span><span class="pun">:</span><span class="pln"> </span><span class="str">'all'</span><span class="pun">,</span><span class="pln">
  </span><span class="com">// ms 是唯一小写的浏览器前缀</span><span class="pln">
  msTransition</span><span class="pun">:</span><span class="pln"> </span><span class="str">'all'</span><span class="pun">,</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> component </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;</span><span class="typ">Component</span><span class="pln"> style</span><span class="pun">={</span><span class="pln">style</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;;</span><span class="pln">
</span></code></pre>
<p><strong>1. 样式中的像素值</strong></p>
<p>当设置 <code>width</code> 和 <code>height</code> 这类与大小有关的样式时，大部分会以像素为单位，此时若重复输入 <code>px</code>，会很麻烦。为了提高效率，React 会自动对这样的属性添加 <code>px</code>。比如：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">// 渲染成 height: 10px</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> style </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> height</span><span class="pun">:</span><span class="pln"> </span><span class="lit">10</span><span class="pln"> </span><span class="pun">};</span><span class="pln">

</span><span class="typ">ReactDOM</span><span class="pun">.</span><span class="pln">render</span><span class="pun">(&lt;</span><span class="typ">Component</span><span class="pln"> style</span><span class="pun">={</span><span class="pln">style</span><span class="pun">}&gt;</span><span class="typ">Hello</span><span class="pun">&lt;/</span><span class="typ">Component</span><span class="pun">&gt;,</span><span class="pln"> mountNode</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>注意，有些属性除了支持 <code>px</code> 为单位的像素值，还支持数字直接作为值，此时 React 并不添加 <code>px</code>，如 <code>lineHeight</code><span class="注释编号">3</span>。</p>
<p class="注释内容"><span class="注释编号下">3</span>Shorthand for Specifying Pixel Values in style props，详见 <a href="https://facebook.github.io/react/tips/style-props-value-px.html">https://facebook.github.io/react/tips/style-props-value-px.html</a>。</p>
<p><strong>2. 使用 classnames 库</strong></p>
<p>在 React 0.13 版本之前，React 官方提供 React.addons.classSet 插件来给组件动态设置 <code>className</code>，这在后续版本中被移除（为了精简 API ）。我们可以使用 classnames 库来操作类。</p>
<p>如果不使用 classnames 库，就需要这样处理动态类名：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Button</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// ...</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    let btnClass </span><span class="pun">=</span><span class="pln"> </span><span class="str">'btn'</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">isPressed</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> btnClass </span><span class="pun">+=</span><span class="pln"> </span><span class="str">' btn-pressed'</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">isHovered</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> btnClass </span><span class="pun">+=</span><span class="pln"> </span><span class="str">' btn-over'</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">button className</span><span class="pun">={</span><span class="pln">btnClass</span><span class="pun">}&gt;{</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">label</span><span class="pun">}&lt;/</span><span class="pln">button</span><span class="pun">&gt;;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span></code></pre>
<p>使用了 classnames 库代码后，就可以变得很简单：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> classNames </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'classnames'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Button</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// ...</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> btnClass </span><span class="pun">=</span><span class="pln"> classNames</span><span class="pun">({</span><span class="pln">
      </span><span class="str">'btn'</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln">
      </span><span class="str">'btn-pressed'</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">isPressed</span><span class="pun">,</span><span class="pln">
      </span><span class="str">'btn-over'</span><span class="pun">:</span><span class="pln"> </span><span class="pun">!</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">isPressed </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">isHovered</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">button className</span><span class="pun">={</span><span class="pln">btnClass</span><span class="pun">}&gt;{</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">label</span><span class="pun">}&lt;/</span><span class="pln">button</span><span class="pun">&gt;;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">});</span><span class="pln">
</span></code></pre>
<h3><strong>2.3.2　CSS Modules</strong></h3>
<p>CSS 是前端领域中进化最慢的一块。由于 ES6 的快速普及以及 Babel 与 webpack 等工具的迅猛发展，相较于 JavaScript ，CSS 被远远甩在了后面，逐渐成为各类大型项目工程化的痛点，也变成了前端走向彻底模块化前必须要解决的一个难题。</p>
<p>CSS 模块化的解决方案有很多，但主要有两类。</p>
<ul>
<li><p><strong>Inline Style</strong>。这种方案彻底抛弃 CSS，使用 JavaScript 或 JSON 来写样式，能给 CSS 提供 JavaScript 同样强大的模块化能力。但缺点同样明显，Inline Style 几乎不能利用 CSS 本身的特性，比如级联、媒体查询（media query）等，<code>:hover</code> 和 <code>:active</code> 等伪类处理起来比较复杂。另外，这种方案需要依赖框架实现，其中与 React 相关的有 Radium、jsxstyle 和 react-style。</p>
</li>
<li><p><strong>CSS Modules</strong>。依旧使用 CSS，但使用 JavaScript 来管理样式依赖。CSS Modules 能最大化地结合现有 CSS 生态和 JavaScript 模块化能力，其 API 非常简洁，学习成本几乎为零。发布时依旧编译出单独的 JavaScript 和 CSS 文件。现在，webpack css-loader 内置 CSS Modules 功能。</p>
</li>
</ul>
<p>下面我们详细介绍一下 CSS Modules 。</p>
<p><strong>1. CSS 模块化遇到了哪些问题？</strong></p>
<p>CSS 模块化重要的是解决好以下两个问题：CSS 样式的导入与导出。灵活按需导入以便复用代码，导出时要能够隐藏内部作用域，以免造成全局污染。Sass、Less、PostCSS 等试图解决 CSS 编程能力弱的问题，但这并没有解决模块化这个问题。Facebook 工程师 Vjeux 抛出了 React 开发中遇到的一系列 CSS 相关问题，结合实际开发的问题有以下几点。</p>
<ul>
<li><p><strong>全局污染</strong>：CSS 使用全局选择器机制来设置样式，优点是方便重写样式。缺点是所有的样式都是全局生效，样式可能被错误覆盖，因此产生了非常丑陋的 <code>!important</code>，甚至 inline <code>!important</code> 和复杂的选择器权重计数表<span class="注释编号">4</span>，提高犯错概率和使用成本。Web Components 标准中的 Shadow DOM 能彻底解决这个问题，但它把样式彻底局部化，造成外部无法重写样式，损失了灵活性。</p>
</li>
<li><p><strong>命名混乱</strong>：由于全局污染的问题，多人协同开发时为了避免样式冲突，选择器越来越复杂，容易形成不同的命名风格，很难统一。样式变多后，命名将更加混乱。</p>
</li>
<li><p><strong>依赖管理不彻底</strong>：组件应该相互独立，引入一个组件时，应该只引入它所需要的 CSS 样式。现在的做法是除了要引入 JavaScript，还要再引入它的 CSS，而且 Saas/Less 很难实现对每个组件都编译出单独的 CSS，引入所有模块的 CSS 又造成浪费。JavaScript 的模块化已经非常成熟，如果能让 JavaScript 来管理 CSS 依赖是很好的解决办法，而 webpack 的 css-loader 提供了这种能力。</p>
</li>
<li><p><strong>无法共享变量</strong>：复杂组件要使用 JavaScript 和 CSS 来共同处理样式，就会造成有些变量在 JavaScript 和 CSS 中冗余，而预编译语言不能提供跨 JavaScript 和 CSS 共享变量的这种能力。</p>
</li>
<li><p><strong>代码压缩不彻底</strong>：由于移动端网络的不确定性，现代工程项目对 CSS 压缩的要求已经到了变态的程度。很多压缩工具为了节省一个字节，会把 <code>16px</code> 转成 <code>1pc</code>，但是这对非常长的类名却无能为力。</p>
</li>
</ul>
<p class="注释内容"><span class="注释编号下">4</span>Calculating a selector's specificity，详见 <a href="https://www.w3.org/TR/selectors/#specificity">https://www.w3.org/TR/selectors/#specificity</a>。</p>
<p>上述问题只凭 CSS 自身是无法解决的，如果通过 JavaScript 来管理 CSS，就很好解决。因此，Vjuex 给出的解决方案是完全的 CSS in JS<span class="注释编号">5</span>，但这相当于完全抛弃 CSS，在 JavaScript 中以 hash 映射来写 CSS，但这种做法未免有些激进，直到出现了 CSS Modules。</p>
<p class="注释内容"><span class="注释编号下">5</span>React: CSS in JS – NationJS，详见 <a href="http://blog.vjeux.com/2014/javascript/react-css-in-js-nationjs.html" target="_blank">http://blog.vjeux.com/2014/javascript/react-css-in-js-nationjs.html</a>。</p>
<p><strong>2. CSS Modules 模块化方案</strong></p>
<p>CSS Modules 内部通过 ICSS 来解决样式导入和导出这两个问题，分别对应 <code>:import</code> 和 <code>:export</code> 两个新增的伪类：</p>
<pre class="代码无行号 prettyprint"><code><span class="pun">:</span><span class="kwd">import</span><span class="pun">(</span><span class="str">"path/to/dep.css"</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  localAlias</span><span class="pun">:</span><span class="pln"> keyFromDep</span><span class="pun">;</span><span class="pln">
  </span><span class="com">/* ... */</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="pun">:</span><span class="kwd">export</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  exportedKey</span><span class="pun">:</span><span class="pln"> exportedValue</span><span class="pun">;</span><span class="pln">
  </span><span class="com">/* ... */</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>但直接使用这两个关键字编程太烦琐，项目中很少会直接使用它们，我们需要的是用 JavaScript 来管理 CSS 的能力。结合 webpack 的 css-loader，就可以在 CSS 中定义样式，在 JavaScript 文件中导入。</p>
<ul>
<li><p><strong>启用 CSS Modules</strong></p>
<p>启用 CSS Modules 的代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">// webpack.config.js</span><span class="pln">
css</span><span class="pun">?</span><span class="pln">modules</span><span class="pun">&amp;</span><span class="pln">localIdentName</span><span class="pun">=[</span><span class="pln">name</span><span class="pun">]</span><span class="pln">__</span><span class="pun">[</span><span class="kwd">local</span><span class="pun">]-[</span><span class="pln">hash</span><span class="pun">:</span><span class="pln">base64</span><span class="pun">:</span><span class="lit">5</span><span class="pun">]</span><span class="pln">
</span></code></pre>
<p>加上 <code>modules</code> 即为启用，其中 <code>localIdentName</code> 是设置生成样式的命名规则。</p>
<p>下面我们直接看看怎么引用 CSS，webpack 又是怎么转化 class 名的：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">/* components/Button.css */</span><span class="pln">
</span><span class="pun">.</span><span class="pln">normal </span><span class="pun">{</span><span class="pln"> </span><span class="com">/* normal 相关的所有样式 */</span><span class="pln"> </span><span class="pun">}</span><span class="pln">
</span><span class="pun">.</span><span class="pln">disabled </span><span class="pun">{</span><span class="pln"> </span><span class="com">/* disabled 相关的所有样式 */</span><span class="pln"> </span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>将以上 CSS 保存好，然后用 <code>import</code> 的方法在 JavaScript 文件中引用：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">/* components/Button.js */</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> styles </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./Button.css'</span><span class="pun">;</span><span class="pln">
　
console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">styles</span><span class="pun">);</span><span class="pln">
</span><span class="com">// =&gt;</span><span class="pln">
</span><span class="com">// Object {</span><span class="pln">
</span><span class="com">//  normal: 'button--normal-abc5436',</span><span class="pln">
</span><span class="com">//  disabled: 'button--disabled-def884',</span><span class="pln">
</span><span class="com">// }</span><span class="pln">
　
buttonElem</span><span class="pun">.</span><span class="pln">outerHTML </span><span class="pun">=</span><span class="pln"> </span><span class="str">`&lt;button class=${styles.normal}&gt;Submit&lt;/button&gt;`</span><span class="pln">
</span></code></pre>
<p>我们看到，最终生成的 HTML 是这样的：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;button</span><span class="pln"> </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"button--normal-abc5436"</span><span class="tag">&gt;</span><span class="pln"> Processing... </span><span class="tag">&lt;/button&gt;</span><span class="pln">
</span></code></pre>
<p>注意到 <code>button--normal-abc5436</code> 是 CSS Modules 按照 <code>localIdentName</code> 自动生成的 <code>class</code> 名称，其中 <code>abc5436</code> 是按照给定算法生成的序列码。经过这样混淆处理后，<code>class</code> 的名称基本就是唯一的，大大降低了项目中样式覆盖的几率。同时在生产环境下修改规则，生成更短的 <code>class</code> 名，可以提高 CSS 的压缩率。</p>
<p>CSS Modules 对 CSS 中的 <code>class</code> 名都做了处理，使用对象来保存原 <code>class</code> 和混淆后 <code>class</code> 的对应关系。通过这些简单的处理，CSS Modules 实现了以下几点：</p>
<ul>
<li><p>所有样式都是局部化的，解决了命名冲突和全局污染问题；</p>
</li>
<li><p><code>class</code> 名的生成规则配置灵活，可以以此来压缩 <code>class</code> 名；</p>
</li>
<li><p>只需引用组件的 JavaScript，就能搞定组件所有的 JavaScript 和 CSS；</p>
</li>
<li><p>依然是 CSS，学习成本几乎为零。</p>
</li>
</ul>
</li>
<li><p><strong>样式默认局部</strong></p>
<p>使用了 CSS Modules 后，就相当于给每个 <code>class</code> 名外加了 <code>:local</code>，以此来实现样式的局部化。如果我们想切换到全局模式，可以使用 <code>:global</code> 包裹。示例代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="pun">.</span><span class="pln">normal </span><span class="pun">{</span><span class="pln">
  color</span><span class="pun">:</span><span class="pln"> green</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
　
</span><span class="com">/* 以上与下面等价 */</span><span class="pln">
</span><span class="pun">:</span><span class="kwd">local</span><span class="pun">(.</span><span class="pln">normal</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  color</span><span class="pun">:</span><span class="pln"> green</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
　
</span><span class="com">/* 定义全局样式 */</span><span class="pln">
</span><span class="pun">:</span><span class="kwd">global</span><span class="pun">(.</span><span class="pln">btn</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  color</span><span class="pun">:</span><span class="pln"> red</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
　
</span><span class="com">/* 定义多个全局样式 */</span><span class="pln">
</span><span class="pun">:</span><span class="kwd">global</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="pun">.</span><span class="pln">link </span><span class="pun">{</span><span class="pln">
    color</span><span class="pun">:</span><span class="pln"> green</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">.</span><span class="pln">box </span><span class="pun">{</span><span class="pln">
    color</span><span class="pun">:</span><span class="pln"> yellow</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
</li>
<li><p><strong>使用 <code>composes</code> 来组合样式</strong></p>
<p>对于样式复用，CSS Modules 只提供了唯一的方式来处理——<code>composes</code> 组合。示例代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">/* components/Button.css */</span><span class="pln">
</span><span class="pun">.</span><span class="kwd">base</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="com">/* 所有通用的样式 */</span><span class="pln"> </span><span class="pun">}</span><span class="pln">
　
</span><span class="pun">.</span><span class="pln">normal </span><span class="pun">{</span><span class="pln">
  composes</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">base</span><span class="pun">;</span><span class="pln">
  </span><span class="com">/* normal 其他样式 */</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
　
</span><span class="pun">.</span><span class="pln">disabled </span><span class="pun">{</span><span class="pln">
  composes</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">base</span><span class="pun">;</span><span class="pln">
  </span><span class="com">/* disabled 其他样式 */</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
　
</span><span class="kwd">import</span><span class="pln"> styles </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./Button.css'</span><span class="pun">;</span><span class="pln">
　
buttonElem</span><span class="pun">.</span><span class="pln">outerHTML </span><span class="pun">=</span><span class="pln"> </span><span class="str">`&lt;button class=${styles.normal}&gt;Submit&lt;/button&gt;`</span><span class="pln">
</span></code></pre>
<p>生成的 HTML 变为：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;button</span><span class="pln"> </span><span class="atn">class</span><span class="pun">=</span><span class="atv">"button--base-abc53 button--normal-abc53"</span><span class="tag">&gt;</span><span class="pln"> Processing... </span><span class="tag">&lt;/button&gt;</span><span class="pln">
</span></code></pre>
<p>由于在 <code>.normal</code> 中组合了 <code>.base</code>，所以编译后的 <code>normal</code> 会变成两个 <code>class</code>。</p>
<p>此外，使用 <code>composes</code> 还可以组合外部文件中的样式：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">/* settings.css */</span><span class="pln">
</span><span class="pun">.</span><span class="pln">primary</span><span class="pun">-</span><span class="pln">color </span><span class="pun">{</span><span class="pln">
  color</span><span class="pun">:</span><span class="pln"> </span><span class="com">#f40;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
　
</span><span class="com">/* components/Button.css */</span><span class="pln">
</span><span class="pun">.</span><span class="kwd">base</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="com">/* 所有通用的样式 */</span><span class="pln"> </span><span class="pun">}</span><span class="pln">
　
</span><span class="pun">.</span><span class="pln">primary </span><span class="pun">{</span><span class="pln">
  composes</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">base</span><span class="pun">;</span><span class="pln">
  composes</span><span class="pun">:</span><span class="pln"> $primary</span><span class="pun">-</span><span class="pln">color </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./settings.css'</span><span class="pun">;</span><span class="pln">
  </span><span class="com">/* primary 其他样式 */</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>对于大多数项目，有了 <code>composes</code> 后，已经不再需要预编译处理器了。但如果想用的话，由于 <code>composes</code> 不是标准的 CSS 语法，编译时会报错，此时就只能使用预处理器自己的语法来做样式复用了。</p>
</li>
<li><p><strong><code>class</code> 命名技巧</strong></p>
<p>CSS Modules 的命名规范是从 BEM 扩展而来的。BEM 把样式名分为 3 个级别，具体如下所示。</p>
<ul>
<li><p><strong>Block</strong>：对应模块名，如 Dialog。</p>
</li>
<li><p><strong>Element</strong>：对应模块中的节点名 Confirm Button。</p>
</li>
<li><p><strong>Modifier</strong>：对应节点相关的状态，如 disabled 和 highlight。</p>
</li>
</ul>
<p>BEM 最终得到的 <code>class</code> 名为 <code>dialog__confirm-button--highlight</code>。使用双符号 <code>__</code> 和 <code>--</code> 是为了与区块内单词间的分隔符区分开来。虽然看起来有些奇特，但 BEM 被非常多的大型项目采用。</p>
<p>CSS Modules 中 CSS 文件名恰好对应 Block 名，只需要再考虑 Element 和 Modifier 即可。BEM 对应到 CSS Modules 的做法是：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">/* .dialog.css */</span><span class="pln">
</span><span class="pun">.</span><span class="typ">ConfirmButton</span><span class="pun">--</span><span class="pln">disabled </span><span class="pun">{}</span><span class="pln">
</span></code></pre>
<p>我们也可以不遵循完整的命名规范，使用小驼峰的写法把 Block 和 Modifier 放到一起：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">/* .dialog.css */</span><span class="pln">
</span><span class="pun">.</span><span class="pln">disabledConfirmButton </span><span class="pun">{}</span></code></pre>
</li>
<li><p><strong>实现 CSS 与 JavaScript 变量共享</strong></p>
<p>上面提到的 <code>:export</code> 关键字可以把 CSS 中的变量输出到 JavaScript 中，例如：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">/* config.scss */</span><span class="pln">
$primary</span><span class="pun">-</span><span class="pln">color</span><span class="pun">:</span><span class="pln"> </span><span class="com">#f40;</span><span class="pln">
　
</span><span class="pun">:</span><span class="kwd">export</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  primaryColor</span><span class="pun">:</span><span class="pln"> $primary</span><span class="pun">-</span><span class="pln">color</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
　
</span><span class="com">/* app.js */</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> style </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'config.scss'</span><span class="pun">;</span><span class="pln">
　
</span><span class="com">// 会输出 #F40</span><span class="pln">
console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">style</span><span class="pun">.</span><span class="pln">primaryColor</span><span class="pun">);</span><span class="pln">
</span></code></pre>
</li>
</ul>
<p><strong>3. CSS Modules 使用技巧</strong></p>
<p>CSS Modules 是对现有的 CSS 做减法。为了追求简单可控，作者建议遵循如下原则：</p>
<ul>
<li><p>不使用选择器，只使用 <code>class</code> 名来定义样式；</p>
</li>
<li><p>不层叠多个 <code>class</code>，只使用一个 <code>class</code> 把所有样式定义好；</p>
</li>
<li><p>所有样式通过 <code>composes</code> 组合来实现复用；</p>
</li>
<li><p>不嵌套。</p>
</li>
</ul>
<p>其中前两条原则相当于削弱了样式中最灵活的部分，初学者很难接受。第一条实践起来难度不大，但第二条中模块状态过多时，<code>class</code> 数量将成倍上升。</p>
<p>上面之所以说“建议”，是因为 CSS Modules 并不强制我们一定要这么做。这听起来有些矛盾。由于多数 CSS 项目存在深厚的历史遗留问题，过多的限制就意味着增加迁移成本和与外部合作的成本。初期使用肯定需要一些折中。幸运的是，CSS Modules 这点做得很好。下面我们来列举一些常见问题。</p>
<p>(1) <strong>如果我对一个元素使用多个 <code>class</code> 呢？</strong></p>
<p>样式照样生效。</p>
<p>(2) <strong>如果我在一个 style 文件中使用同名 <code>class</code> 呢？</strong></p>
<p>这些同名 <code>class</code> 编译后虽然可能是随机码，但仍是同名的。</p>
<p>(3) <strong>如果我在 style 文件中使用了 <code>id</code> 选择器、伪类和标签选择器等呢？</strong></p>
<p>所有这些选择器将不被转换，原封不动地出现在编译后的 CSS 中。也就是说，CSS Modules 只会转换 <code>class</code> 名相关的样式。</p>
<p><strong>4. CSS Modules 结合历史遗留项目实践</strong></p>
<p>好的技术方案除了功能强大、炫酷，还要能做到现有项目能平滑迁移，CSS Modules 在这一点上表现得非常灵活。</p>
<ul>
<li><p><strong>外部如何覆盖局部样式</strong></p>
<p>当生成混淆的 <code>class</code> 名后，可以解决命名冲突，但因为无法预知最终的 <code>class</code> 名，不能通过一般选择器覆盖。我们现在在项目中的实践是可以给组件关键节点加上 data-role 属性，然后通过属性选择器来覆盖样式：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">// dialog.js</span><span class="pln">
</span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
  </span><span class="pun">&lt;</span><span class="pln">div className</span><span class="pun">={</span><span class="pln">styles</span><span class="pun">.</span><span class="pln">root</span><span class="pun">}</span><span class="pln"> data</span><span class="pun">-</span><span class="pln">role</span><span class="pun">=</span><span class="str">"dialog-root"</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">&lt;</span><span class="pln">a className</span><span class="pun">={</span><span class="pln">styles</span><span class="pun">.</span><span class="pln">disabledConfirm</span><span class="pun">}</span><span class="pln"> data</span><span class="pun">-</span><span class="pln">role</span><span class="pun">=</span><span class="str">"dialog-confirm-btn"</span><span class="pun">&gt;</span><span class="typ">Confirm</span><span class="pun">&lt;</span><span class="str">/a&gt;
    ...
  &lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
</span><span class="pun">);</span><span class="pln">
　
</span><span class="com">// dialog.css</span><span class="pln">
</span><span class="pun">[</span><span class="pln">data</span><span class="pun">-</span><span class="pln">role</span><span class="pun">=</span><span class="str">"dialog-root"</span><span class="pun">]</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// override style</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>因为 CSS Modules 只会转变类选择器，所以这里的属性选择器不需要添加 <code>:global</code>。</p>
</li>
<li><p><strong>如何与全局样式共存</strong></p>
<p>前端项目不可避免地会引入 normalize.css 或其他一类全局 CSS 文件，使用 webpack 可以让全局样式和 CSS Modules 的局部样式和谐共存。下面是具体项目中使用的 webpack 部分配置代码：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">module</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  loaders</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[{</span><span class="pln">
    test</span><span class="pun">:</span><span class="pln"> </span><span class="str">/\.jsx?$/</span><span class="pun">,</span><span class="pln">
    loader</span><span class="pun">:</span><span class="pln"> </span><span class="str">'babel'</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">},</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    test</span><span class="pun">:</span><span class="pln"> </span><span class="str">/\.scss$/</span><span class="pun">,</span><span class="pln">
    exclude</span><span class="pun">:</span><span class="pln"> path</span><span class="pun">.</span><span class="pln">resolve</span><span class="pun">(</span><span class="pln">__dirname</span><span class="pun">,</span><span class="pln"> </span><span class="str">'src/styles'</span><span class="pun">),</span><span class="pln">
    loader</span><span class="pun">:</span><span class="pln"> </span><span class="str">'style!css?modules&amp;localIdentName=[name]__[local]!sass?sourceMap=true'</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">},</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    test</span><span class="pun">:</span><span class="pln"> </span><span class="str">/\.scss$/</span><span class="pun">,</span><span class="pln">
    include</span><span class="pun">:</span><span class="pln"> path</span><span class="pun">.</span><span class="pln">resolve</span><span class="pun">(</span><span class="pln">__dirname</span><span class="pun">,</span><span class="pln"> </span><span class="str">'src/styles'</span><span class="pun">),</span><span class="pln">
    loader</span><span class="pun">:</span><span class="pln"> </span><span class="str">'style!css!sass?sourceMap=true'</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">}]</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
　
</span><span class="com">/* src/app.js */</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="str">'./styles/app.scss'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./view/Component'</span><span class="pln">
　
</span><span class="com">/* src/views/Component.js */</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="str">'./Component.scss'</span><span class="pun">;</span><span class="pln">
</span></code></pre>
<p>目录结构如下：</p>
<p>src<br>├── app.js<br>├── styles<br>│　　├── app.scss<br>│　　└── normalize.scss<br>└── views<br>├── Component.js<br>└── Component.scss</p>
<p>这样所有全局的样式都放到 src/styles/app.scss 中引入就可以了，其他所有目录（包括src/views）中的样式都是局部的。</p>
<p>CSS Modules 很好地解决了 CSS 目前面临的模块化难题。支持与预编译语言搭配使用，能充分利用现有技术，同时也能和全局样式灵活搭配。CSS Modules 的实现也属轻量级，未来有标准解决方案后，可以低成本迁移。</p>
</li>
</ul>
<p><strong>5. CSS Modules 结合 React 实践</strong></p>
<p>在 <code>className</code> 处直接使用 CSS 中的 <code>class</code> 名即可：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">/* dialog.css */</span><span class="pln">
</span><span class="pun">.</span><span class="pln">root </span><span class="pun">{}</span><span class="pln">
</span><span class="pun">.</span><span class="pln">confirm </span><span class="pun">{}</span><span class="pln">
</span><span class="pun">.</span><span class="pln">disabledConfirm </span><span class="pun">{}</span><span class="pln">

</span><span class="com">/* dialog.js */</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln">  nmfrom </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> classNames </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'classnames'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> styles </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./dialog.css'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Dialog</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> cx </span><span class="pun">=</span><span class="pln"> classNames</span><span class="pun">({</span><span class="pln">
      confirm</span><span class="pun">:</span><span class="pln"> </span><span class="pun">!</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">disabled</span><span class="pun">,</span><span class="pln">
      disabledConfirm</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">disabled</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="pln">div className</span><span class="pun">={</span><span class="pln">styles</span><span class="pun">.</span><span class="pln">root</span><span class="pun">}&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">a className</span><span class="pun">={</span><span class="pln">styles</span><span class="pun">[</span><span class="pln">cx</span><span class="pun">]}&gt;</span><span class="typ">Confirm</span><span class="pun">&lt;</span><span class="str">/a&gt;
        ...
      &lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>注意，一般把组件最外层节点对应的 <code>class</code> 名称为 <code>root</code>。</p>
<p>React 本身处理样式与其他 View 库并没有太多区别，主要是直接操作样式或是操作 classname 间接操作样式的不同罢了。而与 CSS Modules 的深度结合可能是 React 的一大特点。想象一下 CSS 模块化的远景，我们离成熟的 Web 组件化梦想的道路越来越近了。</p>
<p>如果不想频繁地输入 <code>styles.**</code>，可以使用 react-css-modules 库。它通过高阶组件的形式来避免重复输入 <code>styles.**</code>。我们来重写上述例子：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> classNames </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'classnames'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">CSSModules</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-css-modules'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> styles </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./dialog.css'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Dialog</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> cx </span><span class="pun">=</span><span class="pln"> classNames</span><span class="pun">({</span><span class="pln">
      confirm</span><span class="pun">:</span><span class="pln"> </span><span class="pun">!</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">disabled</span><span class="pun">,</span><span class="pln">
      disabledConfirm</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">disabled</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="pln">div styleName</span><span class="pun">=</span><span class="str">"root"</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">a styleName</span><span class="pun">={</span><span class="pln">cx</span><span class="pun">}&gt;</span><span class="typ">Confirm</span><span class="pun">&lt;</span><span class="str">/a&gt;
        ...
      &lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">default</span><span class="pln"> </span><span class="typ">CSSModules</span><span class="pun">(</span><span class="typ">Dialog</span><span class="pun">,</span><span class="pln"> styles</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>此外，对比原始的 CSS Modules，有以下几个优点：</p>
<ul>
<li><p>我们不用再关注是否使用驼峰来命名 <code>class</code> 名；</p>
</li>
<li><p>我们不用每一次使用 CSS Modules 的时候都关联 <code>style</code> 对象；</p>
</li>
<li><p>使用 CSS Modules，容易使用 <code>:global</code> 去解决特殊情况，使用 react-css-modules 可写成 <code>&lt;div className="global-css" styleName="local-module"&gt;&lt;/div&gt;</code>，这种形式轻松对应全局和局部；</p>
</li>
<li><p>当 <code>styleName</code> 关联了一个 undefined CSS Modules 时，我们会得到一个警告；</p>
</li>
<li><p>我们可以强迫使用单一的 CSS Modules。</p>
</li>
</ul>
<h2><strong>2.4　组件间通信</strong></h2>
<p>React 是以组合组件的形式组织的，组件因为彼此是相互独立的，从传递信息的内容上看，几乎所有类型的信息都可以实现传递，例如字符串、数组、对象、方法或自定义组件等。所以，在嵌套关系上，就会有 3 种不同的可能性：父组件向子组件通信、子组件向父组件通信和没有嵌套关系的组件之间通信。</p>
<p>接下来，我们会重点讨论这 3 种不同的通信方式。其中在父组件向子组件通信后，我们还扩展了一种特殊形式——跨级组件通信。</p>
<h3><strong>2.4.1　父组件向子组件通信</strong></h3>
<p>这种方式在 1.4 节中已经有较为详细的说明，React 数据流动是单向的，父组件向子组件的通信也是最常见的方式。父组件通过 props 向子组件传递需要的信息。我们通过一个列表组件 List，并将其中的项抽象成 ListItem 组件来温习这个过程：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> </span><span class="typ">ListItem</span><span class="pun">({</span><span class="pln"> value </span><span class="pun">})</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
    </span><span class="str">&lt;li&gt;</span><span class="pln">
      </span><span class="str">&lt;span&gt;</span><span class="pun">{</span><span class="pln">value</span><span class="pun">}&lt;/</span><span class="pln">span</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">&lt;</span><span class="str">/li&gt;
  );
}

function List({ list, title }) {
  return (
    &lt;div&gt;
      &lt;ListTitle title={title} /</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="str">&lt;ul&gt;</span><span class="pln">
        </span><span class="pun">{</span><span class="pln">list</span><span class="pun">.</span><span class="pln">map</span><span class="pun">((</span><span class="pln">entry</span><span class="pun">,</span><span class="pln"> index</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
          </span><span class="pun">&lt;</span><span class="typ">ListItem</span><span class="pln"> key</span><span class="pun">={</span><span class="str">`list-${index}`</span><span class="pun">}</span><span class="pln"> value</span><span class="pun">={</span><span class="pln">entry</span><span class="pun">.</span><span class="pln">text</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
        </span><span class="pun">))}</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="str">/ul&gt;
    &lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
  </span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>当我们需要传递每一个 ListItem 的值时，先通过向 List 传递一个数组，然后遍历数组中的值传递给子组件 ListItem 来完成渲染。</p>
<h3><strong>2.4.2　子组件向父组件通信</strong></h3>
<p>在用 React 之前的组件开发模式时，常常需要接收组件运行时的状态，这时我们常用的方法有以下两种。</p>
<ul>
<li><p><strong>利用回调函数</strong>：这是 JavaScript 灵活方便之处，这样就可以拿到运行时状态。</p>
</li>
<li><p><strong>利用自定义事件机制</strong>：这种方法更通用，使用也更广泛。设计组件时，考虑加入事件机制往往可以达到简化组件 API 的目的。</p>
</li>
</ul>
<p>在 React 中，子组件向父组件通信可以使用上面的任意一种方法，但在这种简单的场景下利用自定义事件显然过于复杂，为了达到目的，一般会选择较为简单的方法。</p>
<p>现在我们在 ListItem 组件上加上 <code>checkbox</code>，并要求勾选动作触发后把选中的项暴露出来：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">ListItem</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> defaultProps </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    text</span><span class="pun">:</span><span class="pln"> </span><span class="str">''</span><span class="pun">,</span><span class="pln">
    </span><span class="kwd">checked</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="str">&lt;li&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">input type</span><span class="pun">=</span><span class="str">"checkbox"</span><span class="pln"> </span><span class="kwd">checked</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="kwd">checked</span><span class="pun">}</span><span class="pln">
          onChange</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">onChange</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
        </span><span class="str">&lt;span&gt;</span><span class="pun">{</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">value</span><span class="pun">}&lt;/</span><span class="pln">span</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="str">/li&gt;
    );
  }
}

class List extends Component {
  static defaultProps = {
    list: [],
    handleItemChange: () =&gt; {},
  };

  constructor(props) {
    super(props);

    this.state = {
      list: this.props.list.map(entry =&gt; ({
        text: entry.text,
        checked: entry.checked,
      })),
    };
  }

  onItemChange(entry) {
    const { list } = this.state;

    this.setState({
      list: list.map(prevEntry =&gt; ({
        text: prevEntry.text,
        checked: prevEntry.text === entry.text ?
          !prevEntry.checked : prevEntry.checked,
      })),
    });

    this.props.handleItemChange(entry);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;ul&gt;
          {this.state.list.map((entry, index) =&gt; (
            &lt;ListItem
              key={`list-${index}`}
              value={entry.text}
              checked={entry.checked}
              onChange={this.onItemChange.bind(this, entry)}
            /</span><span class="pun">&gt;</span><span class="pln">
          </span><span class="pun">))}</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="str">/ul&gt;
      &lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>在上述例子中，我们在 List 组件中构造了 <code>handleItemChange</code> 方法，这样在使用 List 组件时，就可以在运行时拿到改变的项对应的值。比如：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleItemChange </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleItemChange</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  handleItemChange</span><span class="pun">(</span><span class="pln">item</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// console.log(item);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="typ">List</span><span class="pln">
        list</span><span class="pun">={[{</span><span class="pln">text</span><span class="pun">:</span><span class="pln"> </span><span class="lit">1</span><span class="pun">},</span><span class="pln"> </span><span class="pun">{</span><span class="pln">text</span><span class="pun">:</span><span class="pln"> </span><span class="lit">2</span><span class="pun">}]}</span><span class="pln">
        handleItemChange</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleItemChange</span><span class="pun">}</span><span class="pln">
      </span><span class="pun">/&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>观察一下实现方法，可以发现它与传统回调函数的实现方法一样。在前端开发过程中，普适的方法在任何库或框架下都是适用的。此外，我们看到 <code>setState</code> 一般与回调函数均会成对出现，这是因为回调函数即是转换内部状态时的函数传统。</p>
<h3><strong>2.4.3　跨级组件通信</strong></h3>
<p>当需要让子组件跨级访问信息时，我们可以像之前说的方法那样向更高级别的组件层层传递 props，但此时的代码显得不那么优雅，甚至有些冗余。在 React 中，我们还可以使用 <code>context</code> 来实现跨级父子组件间的通信：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">class</span><span class="pln"> </span><span class="typ">ListItem</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> contextTypes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    color</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">string</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> value </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="pln">li style</span><span class="pun">={{</span><span class="pln">background</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">context</span><span class="pun">.</span><span class="pln">color</span><span class="pun">}}&gt;</span><span class="pln">
        </span><span class="str">&lt;span&gt;</span><span class="pun">{</span><span class="pln">value</span><span class="pun">}&lt;/</span><span class="pln">span</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="str">/li&gt;
    );
  }
}

class List extends Component {
  static childContextTypes = {
    color: PropTypes.string,
  };

  getChildContext() {
    return {
      color: 'red',
    };
  }

  render() {
    const { list } = this.props;
    return (
      &lt;div&gt;
        &lt;ListTitle title={title} /</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="str">&lt;ul&gt;</span><span class="pln">
          </span><span class="pun">{</span><span class="pln">list</span><span class="pun">.</span><span class="pln">map</span><span class="pun">((</span><span class="pln">entry</span><span class="pun">,</span><span class="pln"> index</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
            </span><span class="pun">&lt;</span><span class="typ">ListItem</span><span class="pln"> key</span><span class="pun">={</span><span class="str">`list-${index}`</span><span class="pun">}</span><span class="pln"> value</span><span class="pun">={</span><span class="pln">entry</span><span class="pun">.</span><span class="pln">text</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
          </span><span class="pun">))}</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="str">/ul&gt;
      &lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>可以看到，我们并没有给 ListItem 传递 props，而是在父组件中定义了 ChildContext，这样从这一层开始的子组件都可以拿到定义的 <code>context</code>，例如这里的 <code>color</code>。</p>
<p>事实上，<code>context</code> 一直存在于 React 的源码中，但直到 React 0.14 版本才被正式记录在官方文档里。不过 React 官方并不建议大量使用 <code>context</code>，因为尽管它可以减少逐层传递，但当组件结构复杂的时候，我们并不知道 <code>context</code> 是从哪里传过来的。<code>Context</code> 就像一个全局变量一样，而全局变量正是导致应用走向混乱的罪魁祸首之一，给组件带来了外部依赖的副作用。在大部分情况下，我们并不推荐使用 <code>context</code> 。使用 <code>context</code> 比较好的场景是真正意义上的全局信息且不会更改，例如界面主题、用户信息等。</p>
<p>Redux 作者 Dan Abramov 对于这个不稳定的属性总结了一个非常有意思的 cheatsheet：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">function</span><span class="pln"> shouldIUseReactContextFeature</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">amILirarayAuthor</span><span class="pun">()</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> doINeedToPassSomethingDownDeeply</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 一个自定义的 &lt;option&gt; 组件可能想与它的 &lt;select&gt; 对话</span><span class="pln">
    </span><span class="com">// 这是可以的，但要记住，这是一个实验性的 API，如果在一些情况下不能更新成功，</span><span class="pln">
    </span><span class="com">// 那么可能需要回滚更改它</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> amIFineWith</span><span class="pun">(</span><span class="pln">API_CHANGES </span><span class="pun">&amp;&amp;</span><span class="pln"> BUGGY_UPDATES</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">myUseCase </span><span class="pun">===</span><span class="pln"> </span><span class="str">'theming'</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> myUseCase </span><span class="pun">===</span><span class="pln"> </span><span class="str">'localization'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 在应用中，context 一般用于不太会改变的全局变量</span><span class="pln">
    </span><span class="com">// 如果你坚持使用它，可以提供一个高阶组件</span><span class="pln">
    </span><span class="com">// 当我们要更改这个 API 的时候，只需要改一个地方就可以了</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> iPromiseToWriteHOCInsteadOfUsingItDirecly</span><span class="pun">();</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">libraryAskMeToUseContext</span><span class="pun">())</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 向它们提供一个高阶组件</span><span class="pln">
    </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Error</span><span class="pun">(</span><span class="str">'File an issue with this library.'</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">// 祝你好运</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> yolo</span><span class="pun">();</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>因此，总体的原则是如果我们真的需要它，那么建议写成高阶组件来实现。有关高阶组件的内容，在 2.5 节中就会讲到。</p>
<h3><strong>2.4.4　没有嵌套关系的组件通信</strong></h3>
<p>没有嵌套关系的，那只能通过可以影响全局的一些机制去考虑。刚才讲到的自定义事件机制不失为一种上佳的方法。</p>
<p>我们在处理事件的过程中需要注意，在 <code>componentDidMount</code> 事件中，如果组件挂载完成，再订阅事件；当组件卸载的时候，在 <code>componentWillUnmount</code> 事件中取消事件的订阅。</p>
<p>我们就以常用的发布/订阅模式来举例，这里借用 Node.js Events 模块的浏览器版实现。</p>
<p>对于 React 使用的场景来说，<code>EventEmitter</code> 只需要单例就可以了，因此我们需要单独初始化 <code>EventEmitter</code> 实例：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">EventEmitter</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'events'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">default</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">EventEmitter</span><span class="pun">();</span><span class="pln">
</span></code></pre>
<p>然后把 EventEmitter 实例输出到各组件中使用：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">ReactDOM</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-dom'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pun">,</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> emitter </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./events'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">ListItem</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> defaultProps </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">checked</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="str">&lt;li&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">input type</span><span class="pun">=</span><span class="str">"checkbox"</span><span class="pln"> </span><span class="kwd">checked</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="kwd">checked</span><span class="pun">}</span><span class="pln"> onChange</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">onChange</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
        </span><span class="str">&lt;span&gt;</span><span class="pun">{</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">value</span><span class="pun">}&lt;/</span><span class="pln">span</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="str">/li&gt;
    );
  }
}

class List extends Component {
  constructor(props) {
    super(props);

    this.state = {
      list: this.props.list.map(entry =&gt; ({
        text: entry.text,
        checked: entry.checked || false,
      })),
    };
  }

  onItemChange(entry) {
    const { list } = this.state;

    this.setState({
      list: list.map(prevEntry =&gt; ({
        text: prevEntry.text,
        checked: prevEntry.text === entry.text ?
          !prevEntry.checked : prevEntry.checked,
      }))
    });

    emitter.emit('ItemChange', entry);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;ul&gt;
          {this.state.list.map((entry, index) =&gt; (
            &lt;ListItem
              key={`list-${index}`}
              value={entry.text}
              checked={entry.checked}
              onChange={this.onItemChange.bind(this, entry)}
            /</span><span class="pun">&gt;</span><span class="pln">
          </span><span class="pun">))}</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="str">/ul&gt;
      &lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  componentDidMount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">itemChange </span><span class="pun">=</span><span class="pln"> emitter</span><span class="pun">.</span><span class="pln">on</span><span class="pun">(</span><span class="str">'ItemChange'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln">data</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">data</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  componentWillUnmount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    emitter</span><span class="pun">.</span><span class="pln">removeListener</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">itemChange</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="typ">List</span><span class="pln"> list</span><span class="pun">={[{</span><span class="pln">text</span><span class="pun">:</span><span class="pln"> </span><span class="lit">1</span><span class="pun">},</span><span class="pln"> </span><span class="pun">{</span><span class="pln">text</span><span class="pun">:</span><span class="pln"> </span><span class="lit">2</span><span class="pun">}]}</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>为了方便开发者对比，这里还是借用上述例子，尽管是有嵌套关系的，但原理是一致的。</p>
<p>一般情况下，组件之间的通信尽可能保持简洁。如果说程序中出现多级传递或跨级传递时，那么首先要重新审视一下是否有更合理的方式。Pub/Sub 模式实现的过程非常容易理解，即利用全局对象来保存事件，用广播的方式去处理事件。这种常规的设计方法在软件开发中处处可见，但这种模式带来的问题就是逻辑关系混乱。</p>
<p>在上述几种通信模式中，跨级通信往往是反模式的典型案例。对于应用开发来说，应该尽力避免仅仅通过例如 Pub/Sub 实现的设计思路，加入强依赖与约定来进一步梳理流程是更好的方法，这将在第 4 章再深入讨论。</p>
<h2><strong>2.5　组件间抽象</strong></h2>
<p>在 React 组件的构建过程中，常常有这样的场景，有一类功能需要被不同的组件公用，此时就涉及抽象的话题。在不同的设计理念下，有许多的抽象方法，而针对 React，我们重点讨论两种：mixin 和高阶组件。</p>
<h3><strong>2.5.1　mixin</strong></h3>
<p>首先，我们就从 mixin 的来源和含义来解说如何抽象公共方法。</p>
<p><strong>1. 使用 mixin 的缘由</strong></p>
<p>mixin 的特性一直广泛存在于各种面向对象语言中。尤其在脚本语言中，大都有原生的支持，比如 Perl、Ruby、Python，甚至连 Sass 也支持。先来看一个在 Ruby 中使用 mixin 的简单例子：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">module</span><span class="pln"> D
  </span><span class="kwd">def</span><span class="pln"> initialize</span><span class="pun">(</span><span class="pln">name</span><span class="pun">)</span><span class="pln">
    </span><span class="lit">@name</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> name
  </span><span class="kwd">end</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> to_s
    </span><span class="lit">@name</span><span class="pln">
  </span><span class="kwd">end</span><span class="pln">
</span><span class="kwd">end</span><span class="pln">

</span><span class="kwd">module</span><span class="pln"> </span><span class="typ">Debug</span><span class="pln">
  include D
  </span><span class="kwd">def</span><span class="pln"> who_am_i</span><span class="pun">?</span><span class="pln">
    </span><span class="str">"#{self.class.name} (\##{self.object_id}): #{self.to_s}"</span><span class="pln">
  </span><span class="kwd">end</span><span class="pln">
</span><span class="kwd">end</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Phonograph</span><span class="pln">
  include </span><span class="typ">Debug</span><span class="pln">
  </span><span class="com"># ...</span><span class="pln">
</span><span class="kwd">end</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">EightTrack</span><span class="pln">
  include </span><span class="typ">Debug</span><span class="pln">
  </span><span class="com"># ...</span><span class="pln">
</span><span class="kwd">end</span><span class="pln">

ph </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Phonograph</span><span class="pun">.</span><span class="kwd">new</span><span class="pun">(</span><span class="str">"West End Blues"</span><span class="pun">)</span><span class="pln">
et </span><span class="pun">=</span><span class="pln"> </span><span class="typ">EightTrack</span><span class="pun">.</span><span class="kwd">new</span><span class="pun">(</span><span class="str">"Real Pillow"</span><span class="pun">)</span><span class="pln">
puts ph</span><span class="pun">.</span><span class="pln">who_am_i</span><span class="pun">?</span><span class="pln">  </span><span class="com"># Phonograph (#-72640448): West End Blues</span><span class="pln">
puts et</span><span class="pun">.</span><span class="pln">who_am_i</span><span class="pun">?</span><span class="pln">  </span><span class="com"># EightTrack (#-72640468): Real Pillow</span><span class="pln">
</span></code></pre>
<p>在 Ruby 中，<code>include</code> 关键词即是 mixin，是将一个模块混入到一个另一个模块中，或是一个类中。为什么编程语言要引入这样一种特性呢？事实上，包括 C++ 等一些年龄较大的 OOP 语言，它们都有一个强大但危险的多重继承特性。现代语言为了权衡利弊，大都舍弃了多重继承，只采用单继承，但单继承在实现抽象时有诸多不便之处。为了弥补缺失，Java 引入了接口（interface），其他一些语言则引入了像 mixin 的技巧，方法虽然不同，但都是为创造一种<strong>类似多重继承</strong>的效果，事实上说它是<strong>组合</strong>更为贴切。</p>
<p>在 ECMAScript 历史中，并没有严格的类实现，早期 YUI、MooTools 这些类库中都有自己封装类的实现，并引入了 mixin 混用模块的方法。直到今天，ES6 引入 class 语法，各种类库也在向着标准化靠拢。</p>
<p><strong>2. 封装 mixin 方法</strong></p>
<p>看到这里，我们已经知道了广义的 mixin 方法的作用，现在试着自己封装一个 mixin 方法来感受一下：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> mixin </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">obj</span><span class="pun">,</span><span class="pln"> mixins</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> newObj </span><span class="pun">=</span><span class="pln"> obj</span><span class="pun">;</span><span class="pln">
  newObj</span><span class="pun">.</span><span class="pln">prototype </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Object</span><span class="pun">.</span><span class="pln">create</span><span class="pun">(</span><span class="pln">obj</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">);</span><span class="pln">

  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">let prop </span><span class="kwd">in</span><span class="pln"> mixins</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">mixins</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="pln">prop</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      newObj</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">[</span><span class="pln">prop</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> mixins</span><span class="pun">[</span><span class="pln">prop</span><span class="pun">];</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="kwd">return</span><span class="pln"> newObj</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> </span><span class="typ">BigMixin</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  fly</span><span class="pun">:</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">'I can fly'</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">};</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> </span><span class="typ">Big</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="str">'new big'</span><span class="pun">);</span><span class="pln">
</span><span class="pun">};</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> </span><span class="typ">FlyBig</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> mixin</span><span class="pun">(</span><span class="typ">Big</span><span class="pun">,</span><span class="pln"> </span><span class="typ">BigMixin</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> flyBig </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">FlyBig</span><span class="pun">();</span><span class="pln"> </span><span class="com">// =&gt; 'new big'</span><span class="pln">
flyBig</span><span class="pun">.</span><span class="pln">fly</span><span class="pun">();</span><span class="pln"> </span><span class="com">// =&gt; 'I can fly'</span><span class="pln">
</span></code></pre>
<p>对于广义的 mixin 方法，就是用赋值的方式将 mixin 对象里的方法都挂载到原对象上，来实现对对象的混入。</p>
<p>看到上述实现，是否会联想到 underscore 库中的 <code>extend</code> 或 lodash 库中的 <code>assign</code> 方法，或者说 ES6中的 <code>Object.assign()</code> 方法？它的作用是什么呢？MDN 上的解释是把任意多个源对象所拥有的自身可枚举属性复制给目标对象，然后返回目标对象。</p>
<p>因为 JavaScript 这门语言比较特别，在没有提到 ES6 classes 之前，并没有真正的类，仅是用方法去模拟对象，其中 <code>new</code> 方法用于创建实例。正因为对类的支持或限制这样弱，它才会那么灵活，上述 mixin 的过程就像复制对象一样。</p>
<p>那问题是组件中的 mixin 也是这样的吗？</p>
<p><strong>3. 在 React 中使用 mixin</strong></p>
<p>React 在使用 <code>createClass</code> 构建组件时提供了 mixin 属性，比如官方封装的 <code>PureRenderMixin</code>：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">PureRenderMixin</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-addons-pure-render-mixin'</span><span class="pun">;</span><span class="pln">

</span><span class="typ">React</span><span class="pun">.</span><span class="pln">createClass</span><span class="pun">({</span><span class="pln">
  mixins</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[</span><span class="typ">PureRenderMixin</span><span class="pun">],</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="str">&lt;div&gt;</span><span class="pln">foo</span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">});</span><span class="pln">
</span></code></pre>
<p>在 <code>createClass</code> 对象参数中传入数组 <code>mixins</code>，里面封装了我们所需要的模块。<code>mixins</code> 数组也可以增加多个 mixin，其每一个 mixin 方法之间的有重合，对于普通方法和生命周期方法是有所区分的。</p>
<p>在不同的 mixin 里实现两个名字一样的普通方法，按理说，后面的方法应该会覆盖前面的方法。那么，在 React 中是否一样会覆盖呢？事实上，它并不会覆盖，而是在控制台里报了一个在 <code>ReactClassInterface</code> 里的错误，指出你尝试在组件中多次定义一个方法，这会造成冲突。因此，在 React 中是不允许出现重名普通方法的 mixin。</p>
<p>如果是 React 生命周期定义的方法，则会将各个模块的生命周期方法叠加在一起顺序执行。</p>
<p>我们看到，使用 <code>createClass</code> 实现的 mixin 为组件做了两件事。</p>
<ul>
<li><p><strong>工具方法</strong>。这是 mixin 的基本功能，如果你想共享一些工具类方法，就可以定义它们，直接在各个组件中使用。</p>
</li>
<li><p><strong>生命周期继承，props 与 state 合并</strong>。这是 mixin 特别重要的功能，它能够合并生命周期方法。如果有很多 mixin 来定义 <code>componentDidMount</code> 这个周期，那么 React 会非常智能地将它们都合并起来执行。同样，mixin 也可以作用在 <code>getInitialState</code> 的结果上，作 state 的合并，而 props 也是这样合并的。</p>
</li>
</ul>
<p><strong>4. ES6 Classes 与 decorator</strong></p>
<p>然而，使用我们推荐的 ES6 classes 形式构建组件时，它并不支持 mixin。React 文档中也未能给出解决方法，但如此重要的特性没有解决方案，也是一件令人十分困扰的事情。为了可以使用这个强大的功能，我们还得想想是否有其他方法，可以用来达到重用模块的目的。先回归到 ES6 classes，我们来想想如何封装 mixin。</p>
<p>要在 class 的基础上封装 mixin，就要说到 class 的本质。ES6 并没有改变 JavaScript 面向对象方法基于原型的本质，不过在此之上提供了一些语法糖，class 就是其中之一。</p>
<p>对于实现 mixin 方法来说，这就没什么不一样了。但既然讲到了语法糖，就来讲讲另一个语法糖 decorator，正巧可以用来实现 class 上的 mixin。</p>
<p>decorator 是在 ES7 中定义的新特性，与 Java 中的 pre-defined annotation（预定义注解） 相似。但与 Java 的 annotation 不同的是，decorator 是运用在运行时的方法。在 Redux 或其他一些应用层框架中，越来越多地使用 decorator 以实现对组件的“修饰”。现在，我们使用 decorator 来实现 mixin。</p>
<p>core-decorators 库为开发者提供了一些实用的 decorator，其中实现了我们正想要的 <code>@mixin</code>。下面解读一下其核心实现：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> getOwnPropertyDescriptors </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./private/utils'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> defineProperty </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Object</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> handleClass</span><span class="pun">(</span><span class="pln">target</span><span class="pun">,</span><span class="pln"> mixins</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">mixins</span><span class="pun">.</span><span class="pln">length</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">SyntaxError</span><span class="pun">(</span><span class="str">`@mixin() class ${target.name} requires at least one mixin as an argument`</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">let i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> l </span><span class="pun">=</span><span class="pln"> mixins</span><span class="pun">.</span><span class="pln">length</span><span class="pun">;</span><span class="pln"> i </span><span class="pun">&lt;</span><span class="pln"> l</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 获取 mixins 的 attributes 对象</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> descs </span><span class="pun">=</span><span class="pln"> getOwnPropertyDescriptors</span><span class="pun">(</span><span class="pln">mixins</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]);</span><span class="pln">

    </span><span class="com">// 批量定义 mixins 的 attributes 对象</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">const</span><span class="pln"> key </span><span class="kwd">in</span><span class="pln"> descs</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!(</span><span class="pln">key </span><span class="kwd">in</span><span class="pln"> target</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        defineProperty</span><span class="pun">(</span><span class="pln">target</span><span class="pun">.</span><span class="pln">prototype</span><span class="pun">,</span><span class="pln"> key</span><span class="pun">,</span><span class="pln"> descs</span><span class="pun">[</span><span class="pln">key</span><span class="pun">]);</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">default</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> mixin</span><span class="pun">(...</span><span class="pln">mixins</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">typeof</span><span class="pln"> mixins</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">===</span><span class="pln"> </span><span class="str">'function'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> handleClass</span><span class="pun">(</span><span class="pln">mixins</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> </span><span class="pun">[]);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> target </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> handleClass</span><span class="pun">(</span><span class="pln">target</span><span class="pun">,</span><span class="pln"> mixins</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>可以看到，源代码十分简单，它将每一个 mixin 对象的方法都叠加到 <code>target</code> 对象的原型上以达到 mixin 的目的。这样，就可以用 <code>@mixin</code> 来做多个重用模块的叠加了。比如：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'React'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> mixin </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'core-decorators'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> </span><span class="typ">PureRender</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  shouldComponentUpdate</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{}</span><span class="pln">
</span><span class="pun">};</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> </span><span class="typ">Theme</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  setTheme</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{}</span><span class="pln">
</span><span class="pun">};</span><span class="pln">

</span><span class="lit">@mixin</span><span class="pun">(</span><span class="typ">PureRender</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Theme</span><span class="pun">)</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">MyComponent</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>细心的你应该已经发现了这个 mixin 与 <code>createClass</code> 中的 mixin 的区别。上述实现中，mixin 的逻辑和最早实现的简单逻辑很相似，之前直接给对象的 <code>prototype</code> 属性赋值，但这里用了 <code>getOwnPropertyDescriptor</code> 和 <code>defineProperty</code> 这两个方法，有什么区别呢？</p>
<p>事实上，这样实现的好处在于 <code>defineProperty</code> 这个方法，也就是定义与赋值的区别，定义是对已有的定义，赋值则是覆盖已有的定义。所以说前者并不会覆盖已有方法，但后者会。本质上与官方的 mixin 方法都很不一样，除了定义方法级别不能覆盖之外，还得加上对生命周期方法的继承，以及对 state 的合并。</p>
<p>再回到 decorator 身上，上述只是作用在类上的方法，还有作用在方法上的，它可以控制方法的自有属性，也可以作 decorator 的工厂方法。在其他语言里，decorator 用途广泛，具体扩展不在本书讨论的范围。</p>
<p>对于 React，我们自然可以用上述方法来实现 mixin。但不幸的是，社区从 0.14 版本开始渐渐开始剥离 mixin。那么，到底是什么原因导致 mixin 成为反模式了呢？</p>
<p><strong>5. mixin 的问题</strong></p>
<p>我们认可 mixin 给组件开发带来抽象的好处，但随着大量使用 mixin，它的问题也渐渐暴露出来了。Dan Abramov 是最早提出这个问题的人，他总结了 mixin 最大的一些问题<span class="注释编号">6</span>。</p>
<p class="注释内容"><span class="注释编号下">6</span>Mixins Considered Harmful，详见 <a href="https://facebook.github.io/react/blog/2016/07/13/mixins-considered-harmful.html">https://facebook.github.io/react/blog/2016/07/13/mixins-considered-harmful.html</a>。</p>
<ul>
<li><p><strong>破坏了原有组件的封装</strong></p>
<p>我们知道 mixin 方法会混入方法，给原有组件带来新的特性，比如 mixin 中有一个 <code>renderList</code>方法，给我们带来了渲染 List 的能力，但它也可能带来了新的 state 和 props，这意味着组件有一些“不可见”的状态需要我们去维护，但我们在使用的时候并不清楚。此外，<code>renderList</code> 中的方法会有调用组件中的方法，但很可能被其他 mixin 截获，带来很多不可知。</p>
<p>另外，mixin 也有可能去依赖其他的 mixin，这样会建立一个 mixin 的依赖链，当我们改动其中一个 mixin 的状态时，很可能会直接影响其他的 mixin。解决方法是可以约定好输入和输出。但不幸的是，mixin 是平面结构，所有方法都在同一个环境中，我们没法做到很好的约定。</p>
</li>
<li><p><strong>命名冲突</strong></p>
<p>刚才也提到了，mixin 是平面结构，那么不同 mixin 中的命名在不可知的情况，重用的情况是不可控的。尤其是像 <code>handleChange</code> 这样常见的名字，我们不能在两个 mixin 中同时使用，也不能在自己的组件中使用这个名字的方法。</p>
<p>尽管我们可以通过更改名字来解决，但遇到第三方引用，或已经引用了几个 mixin 的情况下，总是要花一定的成本去解决冲突。</p>
</li>
<li><p><strong>增加复杂性</strong></p>
<p>在过去写 mixin 的时候，是不是常遇到这样的情形：我们设计一个组件，引入名为 <code>PopupMixin</code> 的 mixin，这样就给组件引进了 <code>PopupMixin</code> 生命周期方法，还有 <code>hidePopup()</code>、<code>startPopup()</code> 等方法。当我们再引入<code>HoverMixin</code>时，将有更多的方法被引进，比如 <code>handleMouseEnter()</code>、<code>handleMouseLeave()</code>、<code>isHovering()</code>方法。当然，我们可以进一步抽象出 <code>TooltipMixin</code>，将两个整合在一起，但我们发现它们都有 <code>componentDidUpdate</code> 方法。</p>
<p>几个月后，再去看组件的实现时，会发现代码已经没法维护，它的逻辑已经复杂到难以理解。写 React 组件时，我们首先考虑的往往是单一的功能、简洁的设计和逻辑。当加入功能的时候，可以继续控制组件的输入和输出。如果说因为复杂性，我们不断加入新的状态，那么组件肯定会因此变得非常难以维护。</p>
<p>针对这些困扰，React 社区提出了新的方式来取代 mixin，那就是高阶组件。</p>
</li>
</ul>
<h3><strong>2.5.2　高阶组件</strong></h3>
<p>higher-order 这个单词相信各位开发者都很熟悉，higher-order function（高阶函数）在函数式编程中是一个基本的概念，它描述的是这样一种函数：这种函数接受函数作为输入，或是输出一个函数。比如，常用的工具方法 <code>map</code>、<code>reduce</code> 和 <code>sort</code> 等都是高阶函数。</p>
<p>高阶组件（higher-order component），类似于高阶函数，它接受 React 组件作为输入，输出一个新的 React 组件。我们用 Haskell 的函数签名来表达，那就是：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">hocFactory</span><span class="pun">::</span><span class="pln"> W</span><span class="pun">:</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">Component</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> E</span><span class="pun">:</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">Component</span><span class="pln">
</span></code></pre>
<p>用通俗的语言解释就是，当 React 组件被包裹时（wrapped），高阶组件会返回一个增强（enhanced）的 React 组件。可以想象，高阶组件让我们的代码更具有复用性、逻辑性与抽象特性。它可以对 <code>render</code> 方法作劫持，也可以控制 props 与 state。</p>
<p>实现高阶组件的方法有如下两种。</p>
<ul>
<li><p><strong>属性代理</strong>（props proxy）。高阶组件通过被包裹的 React 组件来操作 props。</p>
</li>
<li><p><strong>反向继承</strong>（inheritance inversion）。高阶组件继承于被包裹的 React 组件。</p>
</li>
</ul>
<p>接着，我们来讲述这两种方法。</p>
<p><strong>1. 属性代理</strong></p>
<p>属性代理是常见高阶组件的实现方法，我们通过一个例子来说明：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'React'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> </span><span class="typ">MyContainer</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">WrappedComponent</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln">
  </span><span class="kwd">class</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">&lt;</span><span class="typ">WrappedComponent</span><span class="pln"> </span><span class="pun">{...</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>从这里看到最重要的部分是 <code>render</code> 方法中返回了传入 WrappedComponent 的 React 组件。这样，我们就可以通过高阶组件来传递 props，这种方法即为属性代理。</p>
<p>自然，我们想要使用 MyContainer 这个高阶组件就变得非常容易：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'React'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">MyComponent</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// ...</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">default</span><span class="pln"> </span><span class="typ">MyContainer</span><span class="pun">(</span><span class="typ">MyComponent</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>这样组件就可以一层层地作为参数被调用，原始组件就具备了高阶组件对它的修饰。就这么简单，保持单个组件封装性的同时还保留了易用性。当然，我们也可以用 decorator 来转换：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'React'</span><span class="pun">;</span><span class="pln">

</span><span class="lit">@MyContainer</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">MyComponent</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">export</span><span class="pln"> </span><span class="kwd">default</span><span class="pln"> </span><span class="typ">MyComponent</span><span class="pun">;</span><span class="pln">
</span></code></pre>
<p>简单地替换成作用在类上的 decorator，即接收需要装饰的类为参数，返回一个新的内部类。这与高阶组件的定义完全一致。因此，可以认为作用在类上的 decorator 语法糖简化了高阶组件的调用。</p>
<p>当使用属性代理构建高阶组件时，调用顺序不同于 mixin。上述执行生命周期的过程类似于<strong>堆栈调用</strong>：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">didmount</span><span class="pun">→</span><span class="pln">HOC didmount</span><span class="pun">→(</span><span class="typ">HOCs</span><span class="pln"> didmount</span><span class="pun">)→(</span><span class="typ">HOCs</span><span class="pln"> will unmount</span><span class="pun">)→</span><span class="pln">HOC will unmount</span><span class="pun">→</span><span class="pln">unmount
</span></code></pre>
<p>从功能上，高阶组件一样可以做到像 mixin 对组件的控制，包括控制 props、通过 <code>refs</code> 使用引用、抽象 state 和使用其他元素包裹 WrappedComponent。</p>
<p>接着，我们对它的功能一一进行解释。</p>
<ul>
<li><p><strong>控制 props</strong></p>
<p>我们可以读取、增加、编辑或是移除从 WrappedComponent 传进来的 props，但需要小心删除与编辑重要的 props。我们应该尽可能对高阶组件的 props 作新的命名以防止混淆。</p>
<p>例如，我们需要增加一个新的 prop：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'React'</span><span class="pun">;</span><span class="pln">
　
</span><span class="kwd">const</span><span class="pln"> </span><span class="typ">MyContainer</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">WrappedComponent</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln">
  </span><span class="kwd">class</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">const</span><span class="pln"> newProps </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        text</span><span class="pun">:</span><span class="pln"> newText</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">};</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">&lt;</span><span class="typ">WrappedComponent</span><span class="pln"> </span><span class="pun">{...</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">}</span><span class="pln"> </span><span class="pun">{...</span><span class="pln">newProps</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>当调用高阶组件时，可以用 <code>text</code> 这个新的 props 了。对于原组件来说，只要套用这个高阶组件，我们的新组件中就会多一个 <code>text</code> 的 prop。</p>
</li>
<li><p><strong>通过 <code>refs</code> 使用引用</strong></p>
<p>在高阶组件中，我们可以接受 <code>refs</code> 使用 WrappedComponent 的引用。例如：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'React'</span><span class="pun">;</span><span class="pln">
　
</span><span class="kwd">const</span><span class="pln"> </span><span class="typ">MyContainer</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">WrappedComponent</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln">
  </span><span class="kwd">class</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    proc</span><span class="pun">(</span><span class="pln">wrappedComponentInstance</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      wrappedComponentInstance</span><span class="pun">.</span><span class="pln">method</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
　
    render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">const</span><span class="pln"> props </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Object</span><span class="pun">.</span><span class="pln">assign</span><span class="pun">({},</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">ref</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">proc</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">),</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">&lt;</span><span class="typ">WrappedComponent</span><span class="pln"> </span><span class="pun">{...</span><span class="pln">props</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>当 WrappedComponent 被渲染时，<code>refs</code> 回调函数就会被执行，这样就会拿到一份WrappedComponent 实例的引用。这就可以方便地用于读取或增加实例的 props，并调用实例的方法。</p>
</li>
<li><p><strong>抽象 state</strong></p>
<p>我们可以通过 WrappedComponent 提供的 props 和回调函数抽象 state，这个功能将在 4.1 节中解释。高阶组件可以将原组件抽象为展示型组件，分离内部状态。</p>
<p>下面通过抽象一个 input 组件来举例：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'React'</span><span class="pun">;</span><span class="pln">
　
</span><span class="kwd">const</span><span class="pln"> </span><span class="typ">MyContainer</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">WrappedComponent</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln">
  </span><span class="kwd">class</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        name</span><span class="pun">:</span><span class="pln"> </span><span class="str">''</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">};</span><span class="pln">
　
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">onNameChange </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">onNameChange</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
　
    onNameChange</span><span class="pun">(</span><span class="kwd">event</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
        name</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">event</span><span class="pun">.</span><span class="pln">target</span><span class="pun">.</span><span class="pln">value</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">})</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
　
    render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">const</span><span class="pln"> newProps </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        name</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
          value</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">name</span><span class="pun">,</span><span class="pln">
          onChange</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">onNameChange</span><span class="pun">,</span><span class="pln">
        </span><span class="pun">},</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">&lt;</span><span class="typ">WrappedComponent</span><span class="pln"> </span><span class="pun">{...</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">}</span><span class="pln"> </span><span class="pun">{...</span><span class="pln">newProps</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>在这个例子中，我们把 input 组件中对 <code>name</code> prop 的 <code>onChange</code> 方法提取到高阶组件中，这样就有效地抽象了同样的 state 操作。可以这么来使用它：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'React'</span><span class="pun">;</span><span class="pln">
　
</span><span class="lit">@MyContainer</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">MyComponent</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">input name</span><span class="pun">=</span><span class="str">"name"</span><span class="pln"> </span><span class="pun">{...</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">name</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>通过这样的封装，我们就得到了一个被控制的 input 组件。</p>
</li>
<li><p><strong>使用其他元素包裹 WrappedComponent</strong></p>
<p>此外，我们还可以使用其他元素来包裹 WrappedComponent，这既可以是为了加样式，也可以是为了布局。比如，我们增加一层来定义样式：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'React'</span><span class="pun">;</span><span class="pln">
　
</span><span class="kwd">const</span><span class="pln"> </span><span class="typ">MyContainer</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">WrappedComponent</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln">
  </span><span class="kwd">class</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">div style</span><span class="pun">={{</span><span class="pln">display</span><span class="pun">:</span><span class="pln"> </span><span class="str">'block'</span><span class="pun">}}&gt;</span><span class="pln">
          </span><span class="pun">&lt;</span><span class="typ">WrappedComponent</span><span class="pln"> </span><span class="pun">{...</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
        </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">)</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>下面我们再来讨论一下高阶组件与 mixin 的不同之处，如图 2-1 所示。</p>
<p><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/04.d02z.001.png" alt="{%}"></p>
<p><strong>图 2-1　mixin 与高阶组件的区别</strong></p>
<p>图 2-1 其实已经很清晰地表达了 mixin 与高阶组件的不同之处。简单来说，高阶组件符合函数式编程思想。对于原组件来说，并不会感知到高阶组件的存在，只需要把功能套在它之上就可以了，从而避免了使用 mixin 时产生的副作用。</p>
</li>
</ul>
<p><strong>2. 反向继承</strong></p>
<p>另一种构建高阶组件的方法称为反向继承，从字面意思上看，它一定与继承特性相关。我们同样来看一个简单的实现：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> </span><span class="typ">MyContainer</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">WrappedComponent</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln">
  </span><span class="kwd">class</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">WrappedComponent</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">super</span><span class="pun">.</span><span class="pln">render</span><span class="pun">();</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>正如所见，高阶组件返回的组件继承于 WrappedComponent。因为被动地继承了 <code>WrappedComponent</code>，所有的调用都会反向，这也是这种方法的由来。</p>
<p>这种方法与属性代理不太一样。它通过继承 WrappedComponent 来实现，方法可以通过 super 来顺序调用。因为依赖于继承的机制，HOC 的调用顺序和队列是一样的：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">didmount</span><span class="pun">→</span><span class="pln">HOC didmount</span><span class="pun">→(</span><span class="typ">HOCs</span><span class="pln"> didmount</span><span class="pun">)→</span><span class="pln">will unmount</span><span class="pun">→</span><span class="pln">HOC will unmount</span><span class="pun">→(</span><span class="typ">HOCs</span><span class="pln"> will unmount</span><span class="pun">)</span><span class="pln">
</span></code></pre>
<p>在反向继承方法中，高阶组件可以使用 WrappedComponent 引用，这意味着它可以使用WrappedComponent 的 state、props 、生命周期和 <code>render</code> 方法。但它不能保证完整的子组件树被解析。</p>
<p>它有两个比较大的特点，下面我们展开来讲一讲。</p>
<ul>
<li><p><strong>渲染劫持</strong></p>
<p>渲染劫持指的就是高阶组件可以控制 WrappedComponent 的渲染过程，并渲染各种各样的结果。我们可以在这个过程中在任何 React 元素输出的结果中读取、增加、修改、删除 props，或读取或修改 React 元素树，或条件显示元素树，又或是用样式控制包裹元素树。</p>
<p>正如之前说到的，反向继承不能保证完整的子组件树被解析，这意味着将限制渲染劫持功能。渲染劫持的经验法则是我们可以操控 WrappedComponent 的元素树，并输出正确的结果。但如果元素树中包括了函数类型的 React 组件，就不能操作组件的子组件。</p>
<p>我们先来看条件渲染的示例：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> </span><span class="typ">MyContainer</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">WrappedComponent</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln">
  </span><span class="kwd">class</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">WrappedComponent</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">loggedIn</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">super</span><span class="pun">.</span><span class="pln">render</span><span class="pun">();</span><span class="pln">
      </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>第二个示例是我们可以对 <code>render</code> 的输出结果进行修改：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> </span><span class="typ">MyContainer</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">WrappedComponent</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;;</span><span class="pln">
  </span><span class="kwd">class</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">WrappedComponent</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">const</span><span class="pln"> elementsTree </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">super</span><span class="pun">.</span><span class="pln">render</span><span class="pun">();</span><span class="pln">
      let newProps </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{};</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">elementsTree </span><span class="pun">&amp;&amp;</span><span class="pln"> elementsTree</span><span class="pun">.</span><span class="pln">type </span><span class="pun">===</span><span class="pln"> </span><span class="str">'input'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      newProps </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">value</span><span class="pun">:</span><span class="pln"> </span><span class="str">'may the force be with you'</span><span class="pun">};</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> props </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Object</span><span class="pun">.</span><span class="pln">assign</span><span class="pun">({},</span><span class="pln"> elementsTree</span><span class="pun">.</span><span class="pln">props</span><span class="pun">,</span><span class="pln"> newProps</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> newElementsTree </span><span class="pun">=</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="pln">cloneElement</span><span class="pun">(</span><span class="pln">elementsTree</span><span class="pun">,</span><span class="pln"> props</span><span class="pun">,</span><span class="pln"> elementsTree</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">children</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> newElementsTree</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>在这个例子中，WrappedComponent 的渲染结果中，顶层的 input 组件的 <code>value</code> 被改写为 <code>may the force be with you</code>。因此，我们可以做各种各样的事，甚至可以反转元素树，或是改变元素树中的 props。这也是 Radium 库构造的方法。</p>
</li>
<li><p><strong>控制 state</strong></p>
<p>高阶组件可以读取、修改或删除 WrappedComponent 实例中的 state，如果需要的话，也可以增加 state。但这样做，可能会让 WrappedComponent 组件内部状态变得一团糟。大部分的高阶组件都应该限制读取或增加 state，尤其是后者，可以通过重新命名 state，以防止混淆。</p>
<p>我们来看一个例子：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> </span><span class="typ">MyContainer</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="typ">WrappedComponent</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln">
  </span><span class="kwd">class</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">WrappedComponent</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
        </span><span class="str">&lt;div&gt;</span><span class="pln">
          </span><span class="str">&lt;h2&gt;</span><span class="pln">HOC </span><span class="typ">Debugger</span><span class="pln"> </span><span class="typ">Component</span><span class="pun">&lt;</span><span class="str">/h2&gt;
          &lt;p&gt;Props&lt;/</span><span class="pln">p</span><span class="pun">&gt;</span><span class="pln"> </span><span class="str">&lt;pre&gt;</span><span class="pun">{</span><span class="pln">JSON</span><span class="pun">.</span><span class="pln">stringify</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">)}&lt;/</span><span class="pln">pre</span><span class="pun">&gt;</span><span class="pln">
          </span><span class="str">&lt;p&gt;</span><span class="typ">State</span><span class="pun">&lt;</span><span class="str">/p&gt;&lt;pre&gt;{JSON.stringify(this.state, null, 2)}&lt;/</span><span class="pln">pre</span><span class="pun">&gt;</span><span class="pln">
          </span><span class="pun">{</span><span class="kwd">super</span><span class="pun">.</span><span class="pln">render</span><span class="pun">()}</span><span class="pln">
        </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>在这个例子中，显示了 WrappedComponent 的 props 和 state，以方便我们在程序中去调试它们。</p>
</li>
</ul>
<p><strong>3. 组件命名</strong></p>
<p>当包裹一个高阶组件时，我们失去了原始 WrappedComponent 的 <code>displayName</code>，而组件名字是方便我们开发与调试的重要属性。</p>
<p>那可以怎么做呢？这里可以参考 react-redux 库中的实现：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">HOC</span><span class="pun">.</span><span class="pln">displayName </span><span class="pun">=</span><span class="pln"> </span><span class="str">`HOC(${getDisplayName(WrappedComponent)})`</span><span class="pun">;</span><span class="pln">

</span><span class="com">// 或者</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> HOC </span><span class="kwd">extends</span><span class="pln"> </span><span class="pun">...</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> displayName </span><span class="pun">=</span><span class="pln"> </span><span class="str">`HOC(${getDisplayName(WrappedComponent)})`</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">...</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p><code>getDisplayName</code> 方法可以这样来实现：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">function</span><span class="pln"> getDisplayName</span><span class="pun">(</span><span class="typ">WrappedComponent</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">WrappedComponent</span><span class="pun">.</span><span class="pln">displayName </span><span class="pun">||</span><span class="pln">
         </span><span class="typ">WrappedComponent</span><span class="pun">.</span><span class="pln">name </span><span class="pun">||</span><span class="pln">
         </span><span class="str">'Component'</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>或可以使用 recompose 库，它已经帮我们实现了相应的方法。</p>
<p><strong>4. 组件参数</strong></p>
<p>有时，我们调用高阶组件时需要传入一些参数，这可以用非常简单的方式来实现：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'React'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> </span><span class="typ">HOCFactoryFactory</span><span class="pun">(...</span><span class="kwd">params</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// 可以做一些改变 params 的事</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">function</span><span class="pln"> </span><span class="typ">HOCFactory</span><span class="pun">(</span><span class="typ">WrappedComponent</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> HOC </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">&lt;</span><span class="typ">WrappedComponent</span><span class="pln"> </span><span class="pun">{...</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;;</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>当你使用的时候，可以这么写：</p>
<pre class="代码无行号 prettyprint"><code><span class="typ">HOCFactoryFactory</span><span class="pun">(</span><span class="kwd">params</span><span class="pun">)(</span><span class="typ">WrappedComponent</span><span class="pun">)</span><span class="pln">

</span><span class="com">// 或者</span><span class="pln">

</span><span class="lit">@HOCFatoryFactory</span><span class="pun">(</span><span class="kwd">params</span><span class="pun">)</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">WrappedComponent</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="typ">Component</span><span class="pun">{}</span><span class="pln">
</span></code></pre>
<p>这也是利用了函数式编程的特性。可见，在 React 抽象的过程中，处处可见它的影子。</p>
<h3><strong>2.5.3　组合式组件开发实践</strong></h3>
<p>之前我们多次提到，使用 React 开发组件时利用 props 传递参数。也就是说，用参数来配置组件是我们最常用的封装方式。在一般场景中，仅修改组件用于配置的 props，就可以满足需求。但随着场景发生变化，组件的形态也发生变化时，我们就必须不断增加 props 去应对变化，此时便会导致 props 的泛滥，而在扩展过程中又必须保证组件向下兼容，只增不减，使组件的可维护性降低。</p>
<p>因此，我们就可以利用上述高阶组件的思想，提出组件组合式开发模式，有效地解决了配置式所存在的一些问题。</p>
<p><strong>1. 组件再分离</strong></p>
<p>当然，我们期望组件是没有冗余的，组件与组件间视图重叠的部分应当被抽离出来，形成颗粒度更细小的原子组件，使组件组合充满更多的可能。先来看一下比较典型的 3 个公共组件，如图 2-2 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/04.d02z.002.png" alt="{%}"></p>
<p><strong>图 2-2　3 个公共组件</strong></p>
<p>这 3 个组件无论从 UI 还是逻辑上均存在一定的共性。在配置方式中，我们会将这 3 个组件通过一个组件的配置变换来实现，但这么做无疑会提高单个组件内部逻辑的复杂性。</p>
<p>我们来做一次分离，它们可由 SelectInput、SearchInput 与 List 三个颗粒度更细的组件来组合。对于颗粒度最小的组件而言，我们希望它是纯粹的、木偶式的组件。</p>
<p>例如，对于 SelectInput 组件，其状态完全依赖传入的 props，包括 <code>selectedItem</code>（显示用户所选项）、<code>isActive</code>（当前下拉状态）、<code>onClickHeader</code>（反馈下拉状态）以及 <code>placeholder</code>（下拉框提示）。我们来看一下它的简要实现：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">class</span><span class="pln"> </span><span class="typ">SelectInput</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> displayName </span><span class="pun">=</span><span class="pln"> </span><span class="str">'SelectInput'</span><span class="pun">;</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> selectedItem</span><span class="pun">,</span><span class="pln"> isActive</span><span class="pun">,</span><span class="pln"> onClickHeader</span><span class="pun">,</span><span class="pln"> placeholder </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> text </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> selectedItem</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="str">&lt;div&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">div onClick</span><span class="pun">={</span><span class="pln">onClickHeader</span><span class="pun">}&gt;</span><span class="pln">
          </span><span class="pun">&lt;</span><span class="typ">Input</span><span class="pln">
            type</span><span class="pun">=</span><span class="str">"text"</span><span class="pln">
            disabled
            value</span><span class="pun">={</span><span class="pln">text</span><span class="pun">}</span><span class="pln">
            placeholder</span><span class="pun">={</span><span class="pln">placeholder</span><span class="pun">}</span><span class="pln">
          </span><span class="pun">/&gt;</span><span class="pln">
          </span><span class="pun">&lt;</span><span class="typ">Icon</span><span class="pln"> className</span><span class="pun">={</span><span class="pln">isActive</span><span class="pun">}</span><span class="pln"> name</span><span class="pun">=</span><span class="str">"angle-down"</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="str">/div&gt;
      &lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>组件再次分离后，我们就可以根据在现实中的组件形态对其进行任意组合，形成统一层，摆脱在原有组件上扩展的模式，有效提高组件的灵活性。</p>
<p><strong>2. 逻辑再抽象</strong></p>
<p>组件层面的抽象不仅仅只停留在界面上，组件中的相同交互逻辑和业务逻辑也应该进行抽象。在组件中，同样贯穿着这种函数式思想，只是实现方式略有不同。现在基于高阶组件来完成组件逻辑上的抽象：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">// 完成 SearchInput 与 List 的交互</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> searchDecorator </span><span class="pun">=</span><span class="pln"> </span><span class="typ">WrappedComponent</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">SearchDecorator</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">

      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleSearch </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleSearch</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    handleSearch</span><span class="pun">(</span><span class="pln">keyword</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
        data</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">data</span><span class="pun">,</span><span class="pln">
        keyword</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">});</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">onSearch</span><span class="pun">(</span><span class="pln">keyword</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> data</span><span class="pun">,</span><span class="pln"> keyword </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">WrappedComponent</span><span class="pln">
          </span><span class="pun">{...</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">}</span><span class="pln">
          data</span><span class="pun">={</span><span class="pln">data</span><span class="pun">}</span><span class="pln">
          keyword</span><span class="pun">={</span><span class="pln">keyword</span><span class="pun">}</span><span class="pln">
          onSearch</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleSearch</span><span class="pun">}</span><span class="pln">
        </span><span class="pun">/&gt;</span><span class="pln">
      </span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">SearchDecorator</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="com">// 完成 List 数据请求</span><span class="pln">
</span><span class="kwd">const</span><span class="pln"> asyncSelectDecorator </span><span class="pun">=</span><span class="pln"> </span><span class="typ">WrappedComponent</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">AsyncSelectDecorator</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    componentDidMount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> url</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">params</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">

      fetch</span><span class="pun">(</span><span class="pln">url</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">params</span><span class="pln"> </span><span class="pun">}).</span><span class="kwd">then</span><span class="pun">(</span><span class="pln">data </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
          data</span><span class="pun">,</span><span class="pln">
        </span><span class="pun">});</span><span class="pln">
      </span><span class="pun">});</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">WrappedComponent</span><span class="pln">
          </span><span class="pun">{...</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">}</span><span class="pln">
          data</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">data</span><span class="pun">}</span><span class="pln">
        </span><span class="pun">/&gt;</span><span class="pln">
      </span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">AsyncSelectDecorator</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>最终，我们既可以用 decorator 的方式叠加套用，也可以利用 <code>compose</code> 方法将高阶组件层层包裹，将界面与逻辑完美地结合在一起：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> </span><span class="typ">FinalSelector</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> compose</span><span class="pun">(</span><span class="pln">asyncSelectDecorator</span><span class="pun">,</span><span class="pln"> searchDecorator</span><span class="pun">,</span><span class="pln">
selectedItemDecorator</span><span class="pun">)(</span><span class="typ">Selector</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">SearchSelect</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="typ">FinalSelector</span><span class="pln"> </span><span class="pun">{...</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">}&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">SelectInput</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">SearchInput</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">List</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="typ">FinalSelector</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>在配置式组件内部，组件与组件间以及组件与业务间是紧密关联的，而我们需要完成的仅仅是配置工作。如图 2-3 所示，组合式的方式意图打破这种关联，寻求单元化，通过颗粒度更细的基础组件与抽象组件共有交互与业务逻辑的高阶组件，使组件更灵活，更易扩展，也使我们能够完成对于基础组件的自由支配。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/04.d02z.003.png" alt="{%}"></p>
<p><strong>图 2-3　组合式组件架构</strong></p>
<p>从侵入组件到与组件解耦，React 一直推崇的声明式编程都优于命令式编程，正如 mixin 到高阶组件的发展。对于“重用”，从语言层面上来讲，都是为了可以更好地实现抽象，而实现的灵活性与写法之间也存在着一个微妙的平衡。</p>
<h2><strong>2.6　组件性能优化</strong></h2>
<p>从过往的经验与实践中，我们都知道影响网页性能最大的因素是浏览器的重绘（reflow）和重排版（repaint）。React 背后的 Virtual DOM 就是尽可能地减少浏览器的重绘与重排版。</p>
<p>对于性能优化这个主题，我们往往会基于“不信任”的前提，即我们需要提高 React Virtual DOM 的效率。从 React 的渲染过程来看，如何防止不避要的渲染可能是最需要去解决的问题。然而，针对这个问题，React 官方提供了一个便捷的方法来解决，那就是 PureRender。</p>
<h3><strong>2.6.1　纯函数</strong></h3>
<p>要理解 PureRender 中的 Pure，还要从函数式编程的基本概念“纯函数”讲起。纯函数由三大原则构成：</p>
<ul>
<li><p>给定相同的输入，它总是返回相同的输出；</p>
</li>
<li><p>过程没有副作用（side effect）<span class="注释编号">7</span>；</p>
</li>
<li><p>没有额外的状态依赖。</p>
</li>
</ul>
<p class="注释内容"><span class="注释编号下">7</span>side effect (computer science)，详见 <a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science">https://en.wikipedia.org/wiki/Side_effect_(computer_science</a>)。</p>
<p>我们都喜欢这样的方法。记得在计算机科学中有这样一条设计原则 KISS（Keep It Simple, Stupid），而纯函数正是在简洁性与傻瓜化方面做到了极致。</p>
<p>纯函数也是函数式编程的基础，它完全独立于外部状态，这样就避免了因为共享外部状态而导致的 bug。这种独立，让我们可以利用 CPU 在分布式集群上作并行计算，这对于多种科学计算和资源密集型计算任务是非常核心的一点，让计算机高效地处理这类任务变得可能。</p>
<p>此外，纯函数非常方便进行方法级别的测试以及重构，可以让程序具有良好的扩展性及适应性。</p>
<p>我们再来看看纯函数的第一个条件“给定相同的输入，它总是返回相同的输出”，这是什么意思呢？</p>
<p>假如我们定义一个“定义加法”的方法 <em><code>f</code></em>，然后改变它的输入为 <code><em>f</em>(2, 5)</code>，那么不管方法的上下文，不论什么时间调用或多少次的调用，它总是返回 7。用数学语言表达即为 <em>f</em> (<em>x</em>, <em>y</em>) = <em>z</em>，当给定变量 <em>x</em> 和 <em>y</em>，作用在 <em>f</em> 上，结果始终为 <em>z</em>。</p>
<p>但并不是所有方法都适应这个条件，有些方法的结果并不完全依赖于你所传入的参数。比如，</p>
<pre class="代码无行号 prettyprint"><code><span class="typ">Math</span><span class="pun">.</span><span class="pln">random</span><span class="pun">();</span><span class="pln"> </span><span class="com">// =&gt; 0.8982946265648812</span><span class="pln">
</span><span class="typ">Math</span><span class="pun">.</span><span class="pln">random</span><span class="pun">();</span><span class="pln"> </span><span class="com">// =&gt; 0.5326573647965065</span><span class="pln">
</span><span class="typ">Math</span><span class="pun">.</span><span class="pln">random</span><span class="pun">();</span><span class="pln"> </span><span class="com">// =&gt; 0.08841438748355146</span><span class="pln">
</span></code></pre>
<p>就算我们不传任何参数到方法中，该方法也依然总是会输出不同的结果。从这个意义上说，<code>Math.random()</code> 就不满足纯函数的条件。还有下面的例子：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">function</span><span class="pln"> time</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Date</span><span class="pun">().</span><span class="pln">toLocaleTimeString</span><span class="pun">();</span><span class="pln"> </span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>看到 <code>time</code> 一定恍然大悟了吧。获取时间的方法也是同样的，不论我们限定更新时间的区间在秒、分、时，甚至是年，它总是会在这个范围之外改变值而导致不能做到输入和输出一致。</p>
<p>还有我们常用的 <code>slice</code> 和 <code>splice</code> 方法，它们有相似的功能，都可以用来作数据截取。那么，它们的执行结果是一致的么？比如：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> stars </span><span class="pun">=</span><span class="pln"> </span><span class="pun">[</span><span class="str">'Earth'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'Mars'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'Mercury'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'Venus'</span><span class="pun">];</span><span class="pln">

stars</span><span class="pun">.</span><span class="pln">slice</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">);</span><span class="pln"> </span><span class="com">// =&gt; ['Earth', 'Mars']</span><span class="pln">
stars</span><span class="pun">.</span><span class="pln">slice</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">);</span><span class="pln"> </span><span class="com">// =&gt; ['Earth', 'Mars']</span><span class="pln">
stars</span><span class="pun">.</span><span class="pln">slice</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">);</span><span class="pln"> </span><span class="com">// =&gt; ['Earth', 'Mars']</span><span class="pln">

stars</span><span class="pun">.</span><span class="pln">splice</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">)</span><span class="pln"> </span><span class="com">// =&gt; ['Earth', 'Mars']</span><span class="pln">
stars</span><span class="pun">.</span><span class="pln">splice</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">)</span><span class="pln"> </span><span class="com">// =&gt; ['Mercury', 'Venus']</span><span class="pln">
stars</span><span class="pun">.</span><span class="pln">splice</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">)</span><span class="pln"> </span><span class="com">// =&gt; []</span><span class="pln">
</span></code></pre>
<p>我们清晰地看到 <code>slice</code> 方法在参数一定的情况下输出是完全一样的，而 <code>splice</code> 方法的执行结果会改变原数组。对于程序来说，<code>splice</code> 的隐藏行为是危险的，因为这是常会令人疏忽的隐式改变。在 Ruby 语言的设计中，会用 <code>!</code> 号来区分是否改变原始值，这是一个很好的提醒。</p>
<p>当然，还有很多情况是在不同的输入下会有相同的输出，但从概念上说，这个方法也还是纯函数。例如：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">function</span><span class="pln"> compare</span><span class="pun">(</span><span class="pln">val</span><span class="pun">,</span><span class="pln"> comparedVal</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> val </span><span class="pun">&lt;=</span><span class="pln"> comparedVal</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln">

compare</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">);</span><span class="pln"> </span><span class="com">// =&gt; true</span><span class="pln">
compare</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">5</span><span class="pun">);</span><span class="pln"> </span><span class="com">// =&gt; true</span><span class="pln">
compare</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">7</span><span class="pun">);</span><span class="pln"> </span><span class="com">// =&gt; true</span><span class="pln">

compare</span><span class="pun">(</span><span class="lit">7</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln"> </span><span class="com">// =&gt; false</span><span class="pln">
compare</span><span class="pun">(</span><span class="lit">9</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln"> </span><span class="com">// =&gt; false</span><span class="pln">
compare</span><span class="pun">(</span><span class="lit">11</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln"> </span><span class="com">// =&gt; false</span><span class="pln">
</span></code></pre>
<p>第二个条件“过程没有副作用”，其实很好理解，就是说在纯函数中我们不能改变外部状态。而在 JavaScript 中改变外部状态的情况比比皆是，就比如方法的参数是对象或数组，那么它本身就有可能被方法执行的过程改变。例如，</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> addToCart </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">cart</span><span class="pun">,</span><span class="pln"> item</span><span class="pun">,</span><span class="pln"> quantity</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  cart</span><span class="pun">.</span><span class="pln">items</span><span class="pun">.</span><span class="pln">push</span><span class="pun">({</span><span class="pln">
    item</span><span class="pun">,</span><span class="pln">
    quantity</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> cart</span><span class="pun">;</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span></code></pre>
<p>当我们调用方法的时候，</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> originalCart </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  items</span><span class="pun">:</span><span class="pln"> </span><span class="pun">[],</span><span class="pln">
</span><span class="pun">};</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> cart </span><span class="pun">=</span><span class="pln"> addToCart</span><span class="pun">(</span><span class="pln">
  originalCart</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">{</span><span class="pln">
    name</span><span class="pun">:</span><span class="pln"> </span><span class="str">"Digital SLR Camera"</span><span class="pun">,</span><span class="pln">
    price</span><span class="pun">:</span><span class="pln"> </span><span class="str">'1495'</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">},</span><span class="pln">
  </span><span class="lit">1</span><span class="pln">
</span><span class="pun">);</span><span class="pln">
</span></code></pre>
<p>这个例子很简单。这是一个加入到“购物车”的方法，但在执行 <code>addToCart</code> 方法的时候，改变了 <code>originalCart</code> 对象。尽管我们返回了新对象，但因为在 JavaScript 中对象是引用，因此原来的对象也改变了。这就产生了副作用。</p>
<p>因此，我们提出了 Immutable 的概念，让参数中的引用重新复制。这里我们借用了 lodash 的<code>cloneDeep</code> 方法来作深拷贝：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="str">'_'</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'lodash'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">const</span><span class="pln"> addToCart </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">cart</span><span class="pun">,</span><span class="pln"> item</span><span class="pun">,</span><span class="pln"> quantity</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> newCart </span><span class="pun">=</span><span class="pln"> _</span><span class="pun">.</span><span class="pln">cloneDeep</span><span class="pun">(</span><span class="pln">cart</span><span class="pun">);</span><span class="pln">

  newCart</span><span class="pun">.</span><span class="pln">items</span><span class="pun">.</span><span class="pln">push</span><span class="pun">({</span><span class="pln">
    item</span><span class="pun">,</span><span class="pln">
    quantity</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">

  </span><span class="kwd">return</span><span class="pln"> newCart</span><span class="pun">;</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span></code></pre>
<p>这样，我们就不会担心方法影响了外部参数。这也告诉了我们 Immutable 是多么重要。在本节后续部分，我们会重点讲述这一概念及其运用。</p>
<p>第三个条件“没有额外的状态依赖”，就是指方法内的状态都只在方法的生命周期内存活，这意味着我们不能在方法内使用共享变量，因为这会给方法带来不可知因素。</p>
<p>React 在设计时带有函数式编程的基因，因为 React 组件本身就是纯函数。React 的 <code>createElement</code> 方法保证了组件是纯净的，即传入指定 props 得到一定的 Virtual DOM，整个过程都是可预测的。</p>
<p>我们可以通过拆分组件为子组件，进而对组件做更细粒度的控制。这也是函数式编程的魅力之一，保持纯净状态，可以让方法或组件更加专注（focused），体积更小（small），更独立（independent），更具有复用性（reusability）和可测试性（testability）。</p>
<h3><strong>2.6.2　PureRender</strong></h3>
<p>PureRender 是 React 组件开发中一个重要的概念。上一节我们详解了纯函数，PureRender 中的 Pure 指的就是组件满足纯函数的条件，即组件的渲染是被相同的 props 和 state 渲染进而得到相同的结果。这个概念与上述给定相同的输入，它总是返回相同的输出一致。</p>
<p><strong>1. PureRender 本质</strong></p>
<p>怎么实现 PureRender 的过程呢？官方在早期就为开发者提供了名为 react-addons-pure-render-mixin 的插件。其原理为重新实现了 <code>shouldComponentUpdate</code> 生命周期方法，让当前传入的 props和 state 与之前的作浅比较，如果返回 <code>false</code>，那么组件就不会执行 <code>render</code> 方法。</p>
<p>这里讲到了用 <code>shouldComponentUpdate</code> 来作性能优化的方法。在理想情况下，不考虑 props 和 state 的类型，那么要作到充分比较，只能通过深比较，但是它实在是太昂贵了：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">shouldComponentUpdate</span><span class="pun">(</span><span class="pln">nextProps</span><span class="pun">,</span><span class="pln"> nextState</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// 太昂贵了</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> isDeepEqual</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">,</span><span class="pln"> nextProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln">
    isDeepEqual</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">,</span><span class="pln"> nextState</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>然而，PureRender 对 object 只作了引用比较，并没有作值比较。对于实现来说，这是一个取舍问题。PureRender 源代码中只对新旧 props 作了浅比较。以下是 <code>shallowEqual</code> 的示例代码：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">function</span><span class="pln"> shallowEqual</span><span class="pun">(</span><span class="pln">obj</span><span class="pun">,</span><span class="pln"> newObj</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">obj </span><span class="pun">===</span><span class="pln"> newObj</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="kwd">const</span><span class="pln"> objKeys </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Object</span><span class="pun">.</span><span class="pln">keys</span><span class="pun">(</span><span class="pln">obj</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> newObjKeys </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Object</span><span class="pun">.</span><span class="pln">keys</span><span class="pun">(</span><span class="pln">newObj</span><span class="pun">);</span><span class="pln">

  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">objKeys</span><span class="pun">.</span><span class="pln">length </span><span class="pun">!==</span><span class="pln"> newObjKeys</span><span class="pun">.</span><span class="pln">length</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="com">// 关键代码，只需关注 props 中每一个是否相等，无需深入判断</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> objKeys</span><span class="pun">.</span><span class="pln">every</span><span class="pun">(</span><span class="pln">key </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> newObj</span><span class="pun">[</span><span class="pln">key</span><span class="pun">]</span><span class="pln"> </span><span class="pun">===</span><span class="pln"> obj</span><span class="pun">[</span><span class="pln">key</span><span class="pun">];</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p><strong>2. 运用 PureRender</strong></p>
<p>利用 <code>createClass</code> 构建组件时，可以使用官方的插件，其名为 react-addons-pure-render-mixin。此外，用 ES6 classes 语法一样可以使用这个插件，比如：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">PureRenderMixin</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-addons-pure-render-mixin'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">shouldComponentUpdate </span><span class="pun">=</span><span class="pln"> </span><span class="typ">PureRenderMixin</span><span class="pun">.</span><span class="pln">shouldComponentUpdate</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">div className</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">className</span><span class="pun">}&gt;</span><span class="pln">foo</span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>当然，我们也可以用前面介绍的 decorator 来实现，其中 pure-render-decorator 库已经帮我们实现了所需要的功能。在组件化开发过程中，要尽可能地满足 Pure，这样才能保证对相应的变更作出最少的渲染。</p>
<p><strong>3. 优化 PureRender</strong></p>
<p>在使用 React 写组件的过程中，PureRender 可能是最重要也是最常见的性能优化方法。试想在数据可变的情况下，深比较的成本是相当昂贵的。但事实上，浅比较可以覆盖的场景并不是那么多。如果说 props 或 state 中有以下几种类型的情况，那么无论如何，它都会触发 PureRender 为<code>true</code>。</p>
<ul>
<li><p><strong>直接为 props 设置对象或数组</strong></p>
<p>我们知道，每次调用 React 组件其实都会重新创建组件。就算传入的数组或对象的值没有改变，它们引用的地址也会发生改变。比如，下面为 Account 组件设置一个 <code>style</code> prop：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;Account</span><span class="pln"> </span><span class="atn">style</span><span class="pun">={{</span><span class="pln"> </span><span class="atn">color</span><span class="pln">: </span><span class="atv">'black'</span><span class="pln"> }} </span><span class="tag">/&gt;</span><span class="pln">
</span></code></pre>
<p>这样设置 prop，则每次渲染时 <code>style</code> 都是新对象。对于这样的赋值操作，我们只需要提前赋值成常量，不直接使用字面量即可。再比如，我们为 <code>style</code> prop 设置一个默认值也是一样的道理：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;Account</span><span class="pln"> </span><span class="atn">style</span><span class="pun">={</span><span class="pln">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">style || {}} </span><span class="tag">/&gt;</span><span class="pln">
</span></code></pre>
<p>此时，我们只需要将默认值保存成同一份引用，就可以避免这个问题：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> defaultStyle </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{};</span><span class="pln">
</span><span class="pun">&lt;</span><span class="typ">Account</span><span class="pln"> style</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">style </span><span class="pun">||</span><span class="pln"> defaultStyle</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;</span><span class="pln">
</span></code></pre>
<p>同样，像在 props 中为对象或数据计算新值会使 PureRender 无效：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;Item</span><span class="pln"> </span><span class="atn">items</span><span class="pun">=</span><span class="atv">{this.props.items.filter(item</span><span class="pln"> </span><span class="tag">=&gt;</span><span class="pln"> item.val &gt; 30)} /&gt;
</span></code></pre>
<p>我们可以马上想到始终让对象或数组保持在内存中就可以增加命中率。但保持对象引用不符合函数式编程的原则，这为函数带来了副作用，下一节介绍的 Immutable.js 可以优雅地解决这类问题。</p>
</li>
<li><p><strong>设置 props 方法并通过事件绑定在元素上</strong></p>
<p>这与 2.1.2 节讲述的是同一件事，只是从优化的角度重新提起。比如：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
　
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">MyInput</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">){</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">
　
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
　
  handleChange</span><span class="pun">(</span><span class="pln">e</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">update</span><span class="pun">(</span><span class="pln">e</span><span class="pun">.</span><span class="pln">target</span><span class="pun">.</span><span class="pln">value</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
　
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln">input onChange</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleChange</span><span class="pun">}</span><span class="pln"> </span><span class="pun">/&gt;;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>我们不用每次都绑定事件，因此把绑定移到构造器内。如果绑定方法需要传递参数，那么可
以考虑通过抽象子组件或改变现有数据结构解决。</p>
</li>
<li><p><strong>设置子组件</strong></p>
<p>对于设置了子组件的 React 组件，在调用 <code>shouldComponentUpdate</code> 时，均返回 true。为什么呢？下面以 NameItem 组件为例来介绍：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">NameItem</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="typ">Item</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="str">&lt;span&gt;</span><span class="typ">Arcthur</span><span class="pun">&lt;</span><span class="str">/span&gt;
      &lt;Item/</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">)</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>上面的子组件 JSX 部分翻译过来，其实是：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;Item</span><span class="pln">
  </span><span class="atn">children</span><span class="pun">=</span><span class="atv">{React.createElement('span'</span><span class="pln">, {}, </span><span class="atv">'Arcthur'</span><span class="pln">)}
</span><span class="tag">/&gt;</span><span class="pln">
</span></code></pre>
<p>显然，Item 组件不论什么情况下都会重新渲染。那么，怎么避免 Item 组件的重复渲染呢？很简单，我们给 NameItem 设置 PureRender，也就是说提到父级来判断：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">PureRenderMixin</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-addons-pure-render-mixin'</span><span class="pun">;</span><span class="pln">
  　
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">NameItem</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">
  　
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">shouldComponentUpdate </span><span class="pun">=</span><span class="pln"> </span><span class="typ">PureRenderMixin</span><span class="pun">.</span><span class="pln">shouldComponentUpdate</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  　
  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="typ">Item</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="str">&lt;span&gt;</span><span class="typ">Arcthur</span><span class="pun">&lt;</span><span class="str">/span&gt;
      &lt;/</span><span class="typ">Item</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>如果 NameItem 再加兄弟组件，Item 组件不得不被影响到，解决方法同样是将 Item 抽象的 NameItem 提出。</p>
</li>
</ul>
<h3><strong>2.6.3　Immutable</strong></h3>
<p>在传递数据时，可以直接使用 Immutable Data 来进一步提升组件的渲染性能。</p>
<p>JavaScript 中的对象一般是可变的（mutable），因为使用了引用赋值，新的对象简单地引用了原始对象，改变新的对象将影响到原始对象。比如：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">foo </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> a</span><span class="pun">:</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">};</span><span class="pln">
bar </span><span class="pun">=</span><span class="pln"> foo</span><span class="pun">;</span><span class="pln">
bar</span><span class="pun">.</span><span class="pln">a </span><span class="pun">=</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span><span class="pln">
</span></code></pre>
<p>我们给 <code>bar.a</code> 赋值后，会发现此时 <code>foo.a</code> 也改成了 <code>2</code>。虽然这样做可以节约内存，但当应用复杂后，这就造成了非常大的隐患，可变性带来的优点变得得不偿失。为了解决这个问题，一般的做法是使用浅拷贝（shallowCopy）或深拷贝（deepCopy）来避免被修改，但这样做又造成了 CPU 和内存的浪费。</p>
<p>这时 Immutable 的出现很好地解决这些问题。</p>
<p><strong>1. Immutable Data</strong></p>
<p>Immutable Data 就是一旦创建，就不能再更改的数据。对 Immutable 对象进行修改、添加或删除操作，都会返回一个新的 Immutable 对象。Immutable 实现的原理是持久化的数据结构 （persistent data structure），也就是使用旧数据创建新数据时，要保证旧数据同时可用且不变。同时为了避免深拷贝把所有节点都复制一遍带来的性能损耗，Immutable 使用了结构共享（structural sharing），即如果对象树中一个节点发生变化，只修改这个节点和受它影响的父节点，其他节点则进行共享。</p>
<p>Facebook 工程师 Lee Byron 花费三年时间打造 Immutable.js 库，与 React 同期出现，但没有被默认放到 React 工具集里（React 提供了简化的 Helper）。它内部实现了一套完整的持久化数据结构，还有很多易用的数据类型，比如 <code>Collection</code>、<code>List</code>、<code>Map</code>、<code>Set</code>、<code>Record</code>、<code>Seq</code>。有非常全面的 <code>map</code>、<code>filter</code>、<code>groupBy</code>、<code>reduce</code>、<code>find</code> 等函数式操作方法。同时，API 也尽量与 JavaScript 的 <code>Object</code> 或 <code>Array</code> 类似。</p>
<p>其中有 3 种最重要的数据结构说明一下。</p>
<ul>
<li><p><strong><code>Map</code></strong>：键值对集合，对应于 <code>Object</code>，ES6 也有专门的 <code>Map</code> 对象。</p>
</li>
<li><p><strong><code>List</code></strong>：有序可重复的列表，对应于 <code>Array</code>。</p>
</li>
<li><p><strong><code>ArraySet</code></strong>：无序且不可重复的列表。</p>
</li>
</ul>
<p><strong>2. Immutable 的优点</strong></p>
<p>Immutable 的优点有如下几点。</p>
<ul>
<li><p><strong>降低了“可变”带来的复杂度</strong>。可变数据耦合了 time 和 value 的概念，造成了数据很难被回溯。比如：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">function</span><span class="pln"> touchAndLog</span><span class="pun">(</span><span class="pln">touchFn</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  let data </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> key</span><span class="pun">:</span><span class="pln"> </span><span class="str">'value'</span><span class="pln"> </span><span class="pun">};</span><span class="pln">
  touchFn</span><span class="pun">(</span><span class="pln">data</span><span class="pun">);</span><span class="pln">
  console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">data</span><span class="pun">.</span><span class="pln">key</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>在不查看 <code>touchFn</code> 的代码的情况下，因为不确定方法对 <code>data</code> 做了什么，我们是不可能知道结果是什么。但如果 <code>data</code> 是不可变的呢，你会很肯定地知道打印的结果是 <code>value</code>。</p>
</li>
<li><p><strong>节省内存</strong>。Immutable 使用结构共享尽量复用内存。没有被引用的对象会被垃圾回收：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Map</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'immutable'</span><span class="pun">;</span><span class="pln">
　
let a </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Map</span><span class="pun">({</span><span class="pln">
  </span><span class="kwd">select</span><span class="pun">:</span><span class="pln"> </span><span class="str">'users'</span><span class="pun">,</span><span class="pln">
  filter</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Map</span><span class="pun">({</span><span class="pln"> name</span><span class="pun">:</span><span class="pln"> </span><span class="str">'Cam'</span><span class="pln"> </span><span class="pun">}),</span><span class="pln">
</span><span class="pun">});</span><span class="pln">
let b </span><span class="pun">=</span><span class="pln"> a</span><span class="pun">.</span><span class="kwd">set</span><span class="pun">(</span><span class="str">'select'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'people'</span><span class="pun">);</span><span class="pln">
　
a </span><span class="pun">===</span><span class="pln"> b</span><span class="pun">;</span><span class="pln"> </span><span class="com">// =&gt; false</span><span class="pln">
　
a</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'filter'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">===</span><span class="pln"> b</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'filter'</span><span class="pun">);</span><span class="pln"> </span><span class="com">// =&gt; true</span><span class="pln">
</span></code></pre>
<p>上面 <code>a</code> 和 <code>b</code> 共享了没有变化的 <code>filter</code> 节点。</p>
</li>
<li><p><strong>撤销/重做，复制/粘贴，甚至时间旅行这些功能做起来都是小菜一碟</strong>。因为每次数据都是不一样的，那么只要把这些数据放到一个数组里存储起来，想回退到哪里，就拿出对应的数据，这很容易开发出撤销及重做这两种功能。</p>
</li>
<li><p><strong>并发安全</strong>。传统的并发非常难做，因为要处理各种数据不一致的问题，所以“聪明人”发明了各种锁来解决。但使用了 Immutable 之后，数据天生是不可变的，<strong>并发锁就不再需要了</strong>。然而现在并没有用，因为 JavaScript 还是单线程运行的。</p>
</li>
<li><p><strong>拥抱函数式编程</strong>。Immutable 本身就是函数式编程中的概念。只要输入一致，输出必然一致，这样开发的组件更易于调试和组装。</p>
</li>
</ul>
<p>像 ClojureScript、Elm 等函数式编程语言中的数据类型天生都是不可变的，这也是基于 ClojureScript 的 React 框架 Om 性能比 React 好的原因。</p>
<p><strong>3. 使用 Immutable 的缺点</strong></p>
<p>容易与原生对象混淆是使用 Immutable 的过程中遇到的最大的问题。</p>
<p>虽然 Immutable 尽量把 API 设计的原生对象类似，但还是很难区分到底是 Immutable 对象还是原生对象。</p>
<p>Immutable 中的 <code>Map</code> 和 <code>List</code> 虽然对应的是 JavaScript 的 <code>Object</code> 和 <code>Array</code>，但操作完全不同，比如取值时要用 <code>map.get('key')</code> 而不是 <code>map.key</code>，要用 <code>array.get(0)</code> 而不是 <code>array[0]</code>。另外，Immutable 每次修改都会返回新对象，很容易忘记赋值。</p>
<p>当使用第三方库的时候，一般需要使用原生对象，同样容易忘记转换对象。下面给出一些办法来避免类似问题的发生：</p>
<ul>
<li><p>使用 FlowType 或 TypeScript 静态类型检查工具；</p>
</li>
<li><p>约定变量命名规则，如所有 Immutable 类型对象以 <code>$$</code> 开头；</p>
</li>
<li><p>使用 <code>Immutable.fromJS</code> 而不是 <code>Immutable.Map</code> 或 <code>Immutable.List</code> 来创建对象，这样可以避免 Immutable 对象和原生对象间的混用。</p>
</li>
</ul>
<p><strong>4. Immutable.is</strong></p>
<p>两个 Immutable 对象可以使用 <code>===</code> 来比较，这样是直接比较内存地址，其性能最好。但是即使两个对象的值是一样的，也会返回 <code>false</code>：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">let map1 </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Immutable</span><span class="pun">.</span><span class="typ">Map</span><span class="pun">({</span><span class="pln">a</span><span class="pun">:</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> b</span><span class="pun">:</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> c</span><span class="pun">:</span><span class="lit">1</span><span class="pun">});</span><span class="pln">
let map2 </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Immutable</span><span class="pun">.</span><span class="typ">Map</span><span class="pun">({</span><span class="pln">a</span><span class="pun">:</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> b</span><span class="pun">:</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> c</span><span class="pun">:</span><span class="lit">1</span><span class="pun">});</span><span class="pln">
map1 </span><span class="pun">===</span><span class="pln"> map2</span><span class="pun">;</span><span class="pln"> </span><span class="com">// =&gt; false</span><span class="pln">
</span></code></pre>
<p>为了直接比较对象的值，Immutable 提供了 <code>Immutable.is</code> 来作“值比较”：</p>
<pre class="代码无行号 prettyprint"><code><span class="typ">Immutable</span><span class="pun">.</span><span class="kwd">is</span><span class="pun">(</span><span class="pln">map1</span><span class="pun">,</span><span class="pln"> map2</span><span class="pun">);</span><span class="pln">  </span><span class="com">// =&gt; true</span><span class="pln">
</span></code></pre>
<p><code>Immutable.is</code> 比较的是两个对象的 <code>hashCode</code> 或 <code>valueOf</code>（对于 JavaScript 对象）。由于 Immutable 内部使用了 <code>trie</code> 数据结构来存储，只要两个对象的 <code>hashCode</code> 相等，值就是一样的。这样的算法避免了深度遍历比较，因此性能非常好。</p>
<p>另外，还有 mori、cortex 等库。因为它们与 <code>Immutable.is</code> 类似，所以这里就不再一一介绍了。</p>
<p><strong>5. Immutable 与 cursor</strong></p>
<p>这里的 cursor 和数据库中的游标是完全不同的概念。由于 Immutable 数据一般嵌套非常深，所以为了便于访问深层数据，cursor 提供了可以直接访问这个深层数据的引用：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">Immutable</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'immutable'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">Cursor</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'immutable/contrib/cursor'</span><span class="pun">;</span><span class="pln">

let data </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Immutable</span><span class="pun">.</span><span class="pln">fromJS</span><span class="pun">({</span><span class="pln"> a</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> b</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> c</span><span class="pun">:</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="pun">});</span><span class="pln">
</span><span class="com">// 让 cursor 指向 { c: 1 }</span><span class="pln">
let cursor </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Cursor</span><span class="pun">.</span><span class="kwd">from</span><span class="pun">(</span><span class="pln">data</span><span class="pun">,</span><span class="pln"> </span><span class="pun">[</span><span class="str">'a'</span><span class="pun">,</span><span class="pln"> </span><span class="str">'b'</span><span class="pun">],</span><span class="pln"> newData </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">// 当 cursor 或其子 cursor 执行更新时调用</span><span class="pln">
  console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">newData</span><span class="pun">);</span><span class="pln">
</span><span class="pun">});</span><span class="pln">

cursor</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'c'</span><span class="pun">);</span><span class="pln"> </span><span class="com">// 1</span><span class="pln">
cursor </span><span class="pun">=</span><span class="pln"> cursor</span><span class="pun">.</span><span class="pln">update</span><span class="pun">(</span><span class="str">'c'</span><span class="pun">,</span><span class="pln"> x </span><span class="pun">=&gt;</span><span class="pln"> x </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">
cursor</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'c'</span><span class="pun">);</span><span class="pln"> </span><span class="com">// 2</span><span class="pln">
</span></code></pre>
<p><strong>6. Immutable 与 PureRender</strong></p>
<p>前面已经介绍过，React 做性能优化时最常用的就是 <code>shouldComponentUpdate</code> 方法，但它默认返回 <code>true</code>，即始终会执行 <code>render</code> 方法，然后做 Virtual DOM 比较，并得出是否需要做真实 DOM 的更新，这里往往会带来很多没必要的渲染。</p>
<p>当然，我们也可以在 <code>shouldComponentUpdate</code> 中使用深拷贝和深比较来避免无必要的 <code>render</code>，但深拷贝和深比较一般都是非常昂贵的选择。</p>
<p>Immutable.js 则提供了简洁、高效的判断数据是否变化的方法，只需 <code>===</code> 和 <code>is</code> 比较就能知道是否需要执行 <code>render</code>，而这个操作几乎零成本，所以可以极大提高性能。修改后的<code>shouldComponentUpdate</code> 是这样的：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">is</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'immutable'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  shouldComponentUpdate</span><span class="pun">(</span><span class="pln">nextProps</span><span class="pun">,</span><span class="pln"> nextState</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> thisProps </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props </span><span class="pun">||</span><span class="pln"> </span><span class="pun">{};</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> thisState </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">||</span><span class="pln"> </span><span class="pun">{};</span><span class="pln">

    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Object</span><span class="pun">.</span><span class="pln">keys</span><span class="pun">(</span><span class="pln">thisProps</span><span class="pun">).</span><span class="pln">length </span><span class="pun">!==</span><span class="pln"> </span><span class="typ">Object</span><span class="pun">.</span><span class="pln">keys</span><span class="pun">(</span><span class="pln">nextProps</span><span class="pun">).</span><span class="pln">length </span><span class="pun">||</span><span class="pln">
        </span><span class="typ">Object</span><span class="pun">.</span><span class="pln">keys</span><span class="pun">(</span><span class="pln">thisState</span><span class="pun">).</span><span class="pln">length </span><span class="pun">!==</span><span class="pln"> </span><span class="typ">Object</span><span class="pun">.</span><span class="pln">keys</span><span class="pun">(</span><span class="pln">nextState</span><span class="pun">).</span><span class="pln">length</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">const</span><span class="pln"> key </span><span class="kwd">in</span><span class="pln"> nextProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">nextProps</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="pln">key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln">
         </span><span class="pun">!</span><span class="kwd">is</span><span class="pun">(</span><span class="pln">thisProps</span><span class="pun">[</span><span class="pln">key</span><span class="pun">],</span><span class="pln"> nextProps</span><span class="pun">[</span><span class="pln">key</span><span class="pun">]))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">const</span><span class="pln"> key </span><span class="kwd">in</span><span class="pln"> nextState</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">nextState</span><span class="pun">.</span><span class="pln">hasOwnProperty</span><span class="pun">(</span><span class="pln">key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln">
         </span><span class="pun">!</span><span class="kwd">is</span><span class="pun">(</span><span class="pln">thisState</span><span class="pun">[</span><span class="pln">key</span><span class="pun">],</span><span class="pln"> nextState</span><span class="pun">[</span><span class="pln">key</span><span class="pun">]))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>使用 Immutable 后，当灰色节点的 state 变化后，不会再渲染树中的所有节点，而是只渲染图右侧灰色的部分，如图 2-4 所示。</p>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/04.d02z.004.png" alt="{%}"></p>
<p><strong>图 2-4　Immutable 渲染</strong></p>
<p><strong>7. Immutable 与 <code>setState</code></strong></p>
<p>React 建议把 <code>this.state</code> 当作不可变的，因此修改前需要做一个深拷贝：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="str">'_'</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'lodash'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      data</span><span class="pun">:</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> times</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">},</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  handleAdd</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    let data </span><span class="pun">=</span><span class="pln"> _</span><span class="pun">.</span><span class="pln">cloneDeep</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">data</span><span class="pun">);</span><span class="pln">
    data</span><span class="pun">.</span><span class="pln">times </span><span class="pun">=</span><span class="pln"> data</span><span class="pun">.</span><span class="pln">times </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln"> data</span><span class="pun">:</span><span class="pln"> data </span><span class="pun">});</span><span class="pln">
    </span><span class="com">// 如果上面不做 cloneDeep，下面打印的结果会是加 1 后的值</span><span class="pln">
    console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">data</span><span class="pun">.</span><span class="pln">times</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>但在使用 Immutable 后，操作变得很简单：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">App</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      data</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Map</span><span class="pun">({</span><span class="pln"> times</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">}),</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  handleAdd</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">(({</span><span class="pln"> data </span><span class="pun">})</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">({</span><span class="pln">
      data</span><span class="pun">:</span><span class="pln"> data</span><span class="pun">.</span><span class="pln">update</span><span class="pun">(</span><span class="str">'times'</span><span class="pun">,</span><span class="pln"> v </span><span class="pun">=&gt;</span><span class="pln"> v </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">),</span><span class="pln">
    </span><span class="pun">}));</span><span class="pln">
    </span><span class="com">// 这时的 times 并不会改变</span><span class="pln">
    console</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">data</span><span class="pun">.</span><span class="kwd">get</span><span class="pun">(</span><span class="str">'times'</span><span class="pun">));</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>Immutable 可以给应用带来极大的性能提升，但是否使用还要看项目情况。由于侵入性较强，新项目引入比较容易，老项目迁移需要谨慎地评估迁移成本。对于一些提供给外部使用的公共组件，最好不要把 Immutable 对象直接暴露在对外的接口中。</p>
<h3><strong>2.6.4　<code>key</code></strong></h3>
<p>写动态子组件的时候，如果没有给动态子项添加 <code>key</code> prop，则会报一个警告：</p>
<pre class="代码无行号 prettyprint"><code><span class="typ">Warning</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Each</span><span class="pln"> child </span><span class="kwd">in</span><span class="pln"> an array </span><span class="kwd">or</span><span class="pln"> iterator should have a unique </span><span class="str">"key"</span><span class="pln"> prop</span><span class="pun">.</span><span class="pln"> </span><span class="typ">Check</span><span class="pln"> the render method of </span><span class="str">'App'</span><span class="pun">.</span><span class="pln"> </span><span class="typ">See</span><span class="pln"> https</span><span class="pun">:</span><span class="com">//fb.me/react-warning-keys for more information.</span><span class="pln">
</span></code></pre>
<p>这个警告指的是，如果每一个子组件是一个数组或迭代器的话，那么必须有一个唯一的 <code>key</code> prop。这个 <code>key</code> prop 究竟是做什么的呢？</p>
<p>我们想象一下，假如需要渲染一个有 5000 项的成绩排名榜单，而且每隔几秒就会更新一次排名，其中大部分排名只是位置变了，还有少部分的是完全更新了，少部分则是清出榜单了。</p>
<p>此时 <code>key</code> 就发挥作用了，它是用来标识当前项的唯一性的 props。现在尝试来描述这一场景，我们有一份学生的成绩数组：</p>
<pre class="代码无行号 prettyprint"><code><span class="pun">[{</span><span class="pln">
  sid</span><span class="pun">:</span><span class="pln"> </span><span class="str">'600211'</span><span class="pun">,</span><span class="pln">
  name</span><span class="pun">:</span><span class="pln"> </span><span class="str">'Cam'</span><span class="pun">,</span><span class="pln">
</span><span class="pun">},</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  sid</span><span class="pun">:</span><span class="pln"> </span><span class="str">'600243'</span><span class="pun">,</span><span class="pln">
  name</span><span class="pun">:</span><span class="pln"> </span><span class="str">'Arcthur'</span><span class="pun">,</span><span class="pln">
</span><span class="pun">},</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  sid</span><span class="pun">:</span><span class="pln"> </span><span class="str">'600225'</span><span class="pun">,</span><span class="pln">
  name</span><span class="pun">:</span><span class="pln"> </span><span class="str">'Echo'</span><span class="pun">,</span><span class="pln">
</span><span class="pun">}]</span><span class="pln">
</span></code></pre>
<p>其中，<code>sid</code> 是学号，<code>name</code> 是名字。那么，我们来实现成绩排名的榜单：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> </span><span class="typ">Rank</span><span class="pun">({</span><span class="pln"> list </span><span class="pun">})</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
    </span><span class="str">&lt;ul&gt;</span><span class="pln">
      </span><span class="pun">{</span><span class="pln">list</span><span class="pun">.</span><span class="pln">map</span><span class="pun">((</span><span class="pln">entry</span><span class="pun">,</span><span class="pln"> index</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">li key</span><span class="pun">={</span><span class="pln">index</span><span class="pun">}&gt;{</span><span class="pln">entry</span><span class="pun">.</span><span class="pln">name</span><span class="pun">}&lt;/</span><span class="pln">li</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">))}</span><span class="pln">
    </span><span class="pun">&lt;/</span><span class="pln">ul</span><span class="pun">&gt;</span><span class="pln">
  </span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>我们把 <code>key</code> 设成了序号，这么做的确不会报警告了，但这是非常低效的做法。我们在生产环境下常常犯这样的错误，这个 <code>key</code> 是每次用来做 Virtual DOM diff 的，每一位同学都用序号来更新的问题是它没有和同学的唯一信息相匹配，相当于用了一个随机键，那么不论有没有相同的项，更新都会重新渲染。</p>
<p>正确的做法也很简单，只需要把 <code>key</code> 的内容换成 <code>sid</code> 就可以了：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> </span><span class="typ">Rank</span><span class="pun">({</span><span class="pln"> list </span><span class="pun">})</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
    </span><span class="str">&lt;ul&gt;</span><span class="pln">
      </span><span class="pun">{</span><span class="pln">list</span><span class="pun">.</span><span class="pln">map</span><span class="pun">((</span><span class="pln">entry</span><span class="pun">,</span><span class="pln"> index</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">li key</span><span class="pun">={</span><span class="pln">entry</span><span class="pun">.</span><span class="pln">sid</span><span class="pun">}&gt;{</span><span class="pln">entry</span><span class="pun">.</span><span class="pln">name</span><span class="pun">}&lt;/</span><span class="pln">li</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">))}</span><span class="pln">
    </span><span class="pun">&lt;/</span><span class="pln">ul</span><span class="pun">&gt;</span><span class="pln">
  </span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>当 <code>key</code> 相同时，React 会怎么渲染呢？答案是只渲染第一个相同 <code>key</code> 的项，且会报一个警告：</p>
<pre class="代码无行号 prettyprint"><code><span class="typ">Warning</span><span class="pun">:</span><span class="pln"> flattenChildren</span><span class="pun">(…):</span><span class="pln"> </span><span class="typ">Encountered</span><span class="pln"> two children </span><span class="kwd">with</span><span class="pln"> the same key</span><span class="pun">,</span><span class="pln"> </span><span class="str">`.$a`</span><span class="pun">.</span><span class="pln"> </span><span class="typ">Child</span><span class="pln"> keys must be unique</span><span class="pun">;</span><span class="pln"> </span><span class="kwd">when</span><span class="pln"> two children share a key</span><span class="pun">,</span><span class="pln"> only the first child will be used</span><span class="pun">.</span><span class="pln">
</span></code></pre>
<p>因此，对 <code>key</code> 有一个原则，那就是独一无二，且能不用遍历或随机值就不用，除非列表内容也并不是唯一的表示，且没有可以相匹配的属性。</p>
<p>关于 <code>key</code>，我们还需要知道的一种情况是，有两个子组件需要渲染的时候，我们没法给它们设 <code>key</code>。这时需要用到 React 插件 <code>createFragment</code> 来解决：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> createFragment </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-addons-create-fragment'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> </span><span class="typ">Rank</span><span class="pun">({</span><span class="pln"> first</span><span class="pun">,</span><span class="pln"> second </span><span class="pun">})</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> children </span><span class="pun">=</span><span class="pln"> createFragment</span><span class="pun">({</span><span class="pln">
    first</span><span class="pun">:</span><span class="pln"> first</span><span class="pun">,</span><span class="pln">
    second</span><span class="pun">:</span><span class="pln"> second</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">

  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
    </span><span class="str">&lt;ul&gt;</span><span class="pln">
      </span><span class="pun">{</span><span class="pln">children</span><span class="pun">}</span><span class="pln">
    </span><span class="pun">&lt;/</span><span class="pln">ul</span><span class="pun">&gt;</span><span class="pln">
  </span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>上述代码中，<code>first</code> 和 <code>second</code> 两个 prop 的 key 就是我们设置对象的 key。</p>
<h3><strong>2.6.5　react-addons-perf</strong></h3>
<p>做了这么多工作，怎么才能量化以上所做的性能优化的效果呢？这里介绍一个性能检测工具来帮助我们找到应用的性能瓶颈之所在。</p>
<p>react-addons-perf 是官方提供的插件。通过 <code>Perf.start()</code> 和 <code>Perf.stop()</code> 两个 API 设置开始和结束的状态来作分析。它会把各组件渲染的各个阶段的时间统计出来，然后打印出一张表格。</p>
<p>react-addons-perf 可以打印组件渲染的各个阶段，如图 2-5 所示。</p>
<ul>
<li><p><strong><code>Perf.printInclusive(measurements)</code></strong>：所有阶段的时间。</p>
</li>
<li><p><strong><code>Perf.printExclusive(measurements)</code></strong>：不包含挂载组件的时间，即初始化 props、state，调用 <code>componentWillMount</code> 和 <code>componentDidMount</code> 方法的时间等。</p>
</li>
<li><p><strong><code>Perf.printWasted(measurements)</code></strong>：监测渲染的内容保持不变的组件（可以查看哪些组件没有被 <code>shouldComponentUpdate</code> 命中）。</p>
</li>
</ul>
<p class="图"><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/04.d02z.005.png" alt="{%}"></p>
<p><strong>图 2-5　react-addons-perf 打印结果</strong></p>
<p>无论是 PureRender 还是 <code>key</code> 值，整个 React 组件的优化逻辑都是针对 Virtual DOM 的更新优化。如果需要用到更复杂的方法，推荐先阅读第 3 章，深度探究 Virtual DOM 的运行原理。</p>
<h2><strong>2.7　动画</strong></h2>
<p>动画就是使用页面局部的快速更新让人们产生动态效果的感觉。</p>
<p>动画可以帮助用户理解页面，增加应用的趣味性和可玩性，提高用户体验。有时候，一个好的加载动画甚至要比优化数据库、减少等待时间要有效得多。</p>
<p>React 通过 <code>setState</code> 让界面迅速发生变化，但动画的哲学告诉我们，变化要慢，得用一个逐渐变化的过程来过渡，从而帮助用户理解页面。</p>
<p>界面的变化可以分为 DOM 节点（或组件）的增与减以及 DOM 节点（或组件）属性的变化。其中 React 提供的 TransitionGroup 能够帮助我们便捷地识别出增加或删除的组件，从而让我们能够专注于更加简单的属性变化的动画。</p>
<p>关于 JavaScript 动画与 CSS 动画的说法不一，为了方便起见，这里统一将缓动函数通过 JavaScript 实现的动画称作 JavaScript 动画，缓动函数由 CSS 提供（浏览器实现）的动画称作 CSS 动画。</p>
<h3><strong>2.7.1　CSS 动画与 JavaScript 动画</strong></h3>
<p>总的来说，使用 CSS 动画，能够得到更好的性能和更快的开发效率。尽管运用 CSS 更加方便，但必然有其作为 DSL 的局限性。当碰到 CSS 的局限性，导致用 CSS 无法实现或者实现起来十分烦琐时，就是使用 JavaScript 动画的时候了。</p>
<p><strong>1. CSS 动画的局限性</strong></p>
<p>CSS 动画的局限性如下所示。</p>
<ul>
<li><p>CSS 只支持 cubic-bezier 的缓动，如果你的动画对缓动函数有要求，就必须使用 JavaScript 动画。</p>
</li>
<li><p>CSS 动画只能针对一些特有的 CSS 属性。仍然有一些属性是 CSS 动画不支持的，例如 SVG 中 <code>path</code> 的 <code>d</code> 属性。</p>
</li>
<li><p>CSS 把 <code>translate</code>、<code>rotate</code>、<code>skew</code> 等都归结为一个属性——<code>transform</code>。因此，这些属性只能共用同一个缓动函数。例如，我们想要动画的轨迹是一条贝塞尔曲线，可以通过给 <code>left</code> 和 <code>top</code> 这两个属性加两个不同的 cubic-bezier 缓动来实现，但是 <code>left</code> 和 <code>top</code> 实现的动画性能不如 <code>translateX</code> 和 <code>translateY</code>。</p>
</li>
</ul>
<p><strong>2. CSS <code>animation</code></strong></p>
<p>CSS transition 设计得非常简洁，因此适用于比较简单的动画。而 CSS <code>animation</code> 弥补了 CSS transition 在控制上的不足。利用 CSS <code>animation</code>，我们可以：</p>
<ul>
<li><p>使用多步动画（多关键帧动画）；</p>
</li>
<li><p>弥补 CSS transition 在控制上的不足，设置动画的反转、暂停、次数（可以设置为永久）等。</p>
</li>
</ul>
<p><strong>3. 用 JavaScript 包装过的 CSS 动画</strong></p>
<p>有些文章也把用 JavaScript 包装过的 CSS 动画归结为 JavaScript 动画，这样 CSS 动画的范畴就太小了。原生的 CSS 动画可以很方便地实现一些微互动，如：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">el </span><span class="pun">{</span><span class="pln">
  opacity</span><span class="pun">:</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">

  </span><span class="pun">&amp;:</span><span class="pln">hover </span><span class="pun">{</span><span class="pln">
    opacity</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0.8</span><span class="pun">;</span><span class="pln">
    transition</span><span class="pun">:</span><span class="pln"> opacity </span><span class="pun">.</span><span class="lit">4s</span><span class="pln"> ease</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>但是对于大多数情况而言，使用原生 CSS 动画，流程比较烦琐。首先，我们要给 DOM 节点在不同状态下加不同的复杂的 <code>className</code> 。然后在 CSS 中给不同的 <code>className</code> 写不同的样式以及动画逻辑。这里就有必要用 JavaScript 做一些包装，来做一些共同的逻辑，简化动画的开发。</p>
<p>这里我们介绍使用 react-smooth 库来写动画。它不仅支持 CSS 动画，也支持各种缓动类型的 JavaScript 动画，并且提供定制化缓动函数的插件入口：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;Animate</span><span class="pln"> </span><span class="atn">from</span><span class="pun">=</span><span class="atv">{1}</span><span class="pln"> </span><span class="atn">to</span><span class="pun">=</span><span class="atv">{0.8}</span><span class="pln"> </span><span class="atn">attributeName</span><span class="pun">=</span><span class="atv">"opacity"</span><span class="tag">&gt;</span><span class="pln">
  // ...
</span><span class="tag">&lt;/Animate&gt;</span><span class="pln">
</span></code></pre>
<p><strong>4. JavaScript 动画</strong></p>
<p>这里将 JavaScript 动画定义为缓动函数用 JavaScript 实现的动画，因此 JavaScript 动画包含缓动函数部分和渲染部分。</p>
<p>2.7.3 节将详细说明缓动函数以及如何用 JavaScript 实现缓动函数。而在渲染部分，可以在View 层利用强大的 React 来帮助我们渲染。这样只要在缓动函数中执行 <code>setState</code> 来更新动画进度，从而触发页面重绘。</p>
<p><strong>5. SVG 线条动画</strong></p>
<p>说起 SVG 线条动画，最出名的恐怕是 vivus.js，它巧妙地利用了 SVG path 的 <code>stroke-dasharray</code>属性和 <code>getTotalLength</code> 方法。</p>
<p><code>stroke-dasharray</code> 是设置 SVG path 虚线的属性。因此，要做一个简单的线条动画，只需：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">el </span><span class="pun">{</span><span class="pln">
  stroke</span><span class="pun">-</span><span class="pln">dasharray</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1px</span><span class="pun">;</span><span class="pln">

  </span><span class="pun">&amp;.</span><span class="pln">active </span><span class="pun">{</span><span class="pln">
    stroke</span><span class="pun">-</span><span class="pln">dashoffset</span><span class="pun">:</span><span class="pln"> totalLength</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
    transition</span><span class="pun">:</span><span class="pln"> stroke</span><span class="pun">-</span><span class="pln">dasharray </span><span class="pun">.</span><span class="lit">4s</span><span class="pln"> ease</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>然而 vivus 有两个缺陷：</p>
<ul>
<li><p>它用 JavaScript 动画实现 <code>stroke-dasharray</code> 的缓动，而实际上 CSS 动画是支持 <code>stroke-dasharray</code> 属性的；</p>
</li>
<li><p>vivus 不支持虚线动画。</p>
</li>
</ul>
<p>那么，如何利用 <code>stroke-dasharray</code> 来实现虚线动画呢？</p>
<p><code>stroke-dasharray</code>，顾名思义，其值其实是一个数组。因此，我们可以利用这一特性逐渐改变这个数组的长度，如：</p>
<pre class="代码无行号 prettyprint"><code><span class="lit">1px</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0px</span><span class="pun">;</span><span class="pln">
</span><span class="lit">2px</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0px</span><span class="pun">;</span><span class="pln">
</span><span class="lit">2px</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1px</span><span class="pun">;</span><span class="pln">
</span><span class="lit">2px</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2px</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1px</span><span class="pun">;</span><span class="pln">
</span><span class="lit">2px</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2px</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2px</span><span class="pun">;</span><span class="pln">
</span><span class="lit">2px</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2px</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2px</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1px</span><span class="pun">;</span><span class="pln">
</span><span class="lit">2px</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2px</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2px</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2px</span><span class="pun">;</span><span class="pln">
</span><span class="pun">...</span><span class="pln">
</span></code></pre>
<h3><strong>2.7.2　玩转 React Transition</strong></h3>
<p>2015 年，React 给整个前端界带来了一种新的开发方式，我们抛弃了无所不能的 DOM 操作。对于 React 实现动画这个命题，DOM 操作已经是一条死路，而 CSS3 动画又只能实现一些最简单的功能。这时候 ReactCSSTransitionGroup 插件无疑是一枚强心剂。</p>
<p>React 渲染结果的任何变化，无非是组件节点的增、添、删除和组件属性的变化。React Transition 帮助开发者识别组件的子组件们的增与删。下面让我们来谈谈 React Transition 的设计、用法、实现原理，以及基于 React Transition 封装的又一个好工具 React CSS Transition。</p>
<p><strong>1. React Transition 的设计及用法</strong></p>
<p>学习 API 或者用法很简单，但是在学习 API 的时候，我们不妨也来思考一下 React Transition API 的设计，说不定会有更多的收获。</p>
<p>React Transition 如何帮助开发者识别增删的节点呢？方法有很多，而 React 结合自己的特点，设计了以生命周期函数的方式来实现，即让子组件的每一个实例都实现相应的生命周期函数。当 React Transition 识别到某个子组件增或删时，则调用它相应的生命周期函数。我们可以在生命周期函数中实现动画逻辑。</p>
<p>事实上，一个组件中所有子组件的增删动画逻辑大同小异（动效的统一性）。如果每一个子组件的动效相同，那么每一个子组件可以共用同一个生命周期函数。因此，React Transition 提供了 <code>childFactory</code> 配置，让用户自定义一个封装子组件的工厂方法，为子组件加上相应的生命周期函数。</p>
<p>React Transition 提供了哪些生命周期呢？想想也知道，它们无非是：</p>
<ul>
<li><p><code>componentWillAppear</code></p>
</li>
<li><p><code>componentDidAppear</code></p>
</li>
<li><p><code>componentWillEnter</code></p>
</li>
<li><p><code>componentDidEnter</code></p>
</li>
<li><p><code>componentWillLeave</code></p>
</li>
<li><p><code>componentDidLeave</code></p>
</li>
</ul>
<p><code>componentWillxxx</code> 在什么时候触发很容易判断，只需在 <code>componentWillReceiveProps</code> 中对<code>this.props.children</code> 和 <code>nextProps.children</code> 做一个比较即可。而 <code>componentDidxxx</code> 要何时触发呢？</p>
<p>可以给 <code>componentWillxxx</code> 提供一个回调函数，用来执行 <code>componentDidxxx</code>。</p>
<p>React Transition 的 API 设计正是这样的，你若感到迷惑，可以先来看一个例子。</p>
<p>之前说过，React Transition 对 CSS 动画做了封装，因此我们来实现一个 React Transition 的 JavaScript 动画。在实现 React Transition 的 <code>childFactory</code> 工厂方法的时候，我们可以先实现一个 <code>JSTransitionChild</code> 的类：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">update</span><span class="pun">(</span><span class="kwd">done</span><span class="pun">,</span><span class="pln"> now</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">leaveTime</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">leaveTime </span><span class="pun">=</span><span class="pln"> now</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> duration </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> passedTime </span><span class="pun">=</span><span class="pln"> now </span><span class="pun">-</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">enterTime</span><span class="pun">;</span><span class="pln">

  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">passedTime </span><span class="pun">&gt;</span><span class="pln"> duration</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">cafId</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      caf</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">cafId</span><span class="pun">);</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">leaveTime </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">done</span><span class="pun">();</span><span class="pln">

    </span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="kwd">const</span><span class="pln"> progress </span><span class="pun">=</span><span class="pln"> ease</span><span class="pun">(</span><span class="pln">passedTime </span><span class="pun">/</span><span class="pln"> duration</span><span class="pun">);</span><span class="pln">

  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
    progress</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">})</span><span class="pln">

  </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">cafId </span><span class="pun">=</span><span class="pln"> raf</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">enter</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">));</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

componentWillLeave</span><span class="pun">(</span><span class="kwd">done</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">cafId</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    caf</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">cafId</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">leaveTime </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  raf</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">update</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">done</span><span class="pun">));</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>虽然我们没有实现 <code>componentDidLeave</code> 函数，但是仍然如实地在正确的地方执行了 <code>done</code> 回调，确保 <code>componentDidLeave</code> 执行。这是为什么呢？</p>
<p><code>componentWillLeave</code> 中的回调函数（即这里的 <code>done</code>）有点特殊。我们知道，React 动画归根结底是让状态变化变慢，或者说延迟变化。那么对于消失的动画来说，我们要花费一段时间展现消失的动画，就必须让消失的子组件延迟消失，在这段时间内暂时保留。因此，这里的回调函数不仅仅是执行 <code>componentDidLeave</code>，也执行了让这个子组件从子组件集中消失的操作。</p>
<p><strong>2. React CSS Transition 设计及用法</strong></p>
<p>React Transition 还对 CSS 动画做了专门的封装。用 CSS3 来做 React 动画简直完美！我们不用像 JavaScript 动画那样用 <code>setState</code> 来让状态延缓更新，CSS3 中就有让状态延迟更新的方法。我们把延迟更新状态的逻辑交给 CSS，不仅可以让代码更加专注于业务逻辑，更为简洁，还能提高动画的性能。</p>
<p>React CSS Transition 为子组件的每个生命周期加了不同的 <code>className</code>，这样用户可以很方便地根据 <code>className</code> 的变化来实现动画。例如：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;ReactCSSTransitionGroup</span><span class="pln">
  </span><span class="atn">transitionName</span><span class="pun">=</span><span class="atv">"example"</span><span class="pln">
  </span><span class="atn">transitionEnterTimeout</span><span class="pun">=</span><span class="atv">{400}</span><span class="pln">
</span><span class="tag">&gt;</span><span class="pln">
  {items}
</span><span class="tag">&lt;/ReactCSSTransitionGroup&gt;</span><span class="pln">
</span></code></pre>
<p>对应的 SCSS 代码为：</p>
<pre class="代码无行号 prettyprint"><code><span class="pun">.</span><span class="pln">example</span><span class="pun">-</span><span class="pln">enter </span><span class="pun">{</span><span class="pln">
  transform</span><span class="pun">:</span><span class="pln"> scaleY</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">

  </span><span class="pun">&amp;.</span><span class="pln">example</span><span class="pun">-</span><span class="pln">enter</span><span class="pun">-</span><span class="pln">active </span><span class="pun">{</span><span class="pln">
    transform</span><span class="pun">:</span><span class="pln"> scaleY</span><span class="pun">(</span><span class="lit">1</span><span class="pun">);</span><span class="pln">
    transition</span><span class="pun">:</span><span class="pln"> transform </span><span class="pun">.</span><span class="lit">4s</span><span class="pln"> ease</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>这样便轻松地实现了 <code>items</code> 中新增元素的动画。</p>
<p>在使用 React Transition 时，如何设定子组件集的 <code>key</code> 也颇有学问，毕竟代表一个元素的不是它的位置，而是它的 <code>key</code> 值。</p>
<p>例如：我们要展现 10 年来 GDP 排名前 10 的省份，把动画加在某个名次省份发生更新的元素上，此时可以把 <code>key</code> 设置为 <code>${名次}-${省份id}</code>。</p>
<p>当然，如果使用 react-smooth 来实现，会更简洁：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">const</span><span class="pln"> enter </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">from</span><span class="pun">:</span><span class="pln"> </span><span class="str">'scaleY(0)'</span><span class="pun">,</span><span class="pln">
  to</span><span class="pun">:</span><span class="pln"> </span><span class="str">'scaleY(1)'</span><span class="pun">,</span><span class="pln">
  attributeName</span><span class="pun">:</span><span class="pln"> </span><span class="str">'transform'</span><span class="pun">,</span><span class="pln">
  duration</span><span class="pun">:</span><span class="pln"> </span><span class="lit">400</span><span class="pun">,</span><span class="pln">
</span><span class="pun">};</span><span class="pln">

</span><span class="com">// 支持列表动画</span><span class="pln">
</span><span class="pun">&lt;</span><span class="typ">AnimateGroup</span><span class="pln"> enter</span><span class="pun">={</span><span class="pln">enter</span><span class="pun">}&gt;</span><span class="pln">
  </span><span class="pun">{</span><span class="pln">items</span><span class="pun">}</span><span class="pln">
</span><span class="pun">&lt;/</span><span class="typ">AnimateGroup</span><span class="pun">&gt;</span><span class="pln">
</span></code></pre>
<h3><strong>2.7.3　缓动函数</strong></h3>
<p>虽然 CSS 动画简单易用而且性能高，但是 JavaScript 动画依然有其必要性，而且也非常重要。而谈到 JavaScript 动画，不得不说一说缓动函数。</p>
<p>缓动函数是什么，它是一个返回当前帧动画进度的函数。</p>
<p><strong>1. 缓动函数用户体验</strong></p>
<p>从动画体验的角度来说，不同的缓动函数会带给用户不同的缓动体验。以我们常见的缓动函数 <code>linear</code>、<code>ease</code> 和 <code>spring</code> 为例，缓动体验一般为 <code>linear</code> &lt; <code>ease</code> &lt; <code>spring</code>。</p>
<p>为什么这么说呢？<code>linear</code>、<code>ease</code> 和 <code>spring</code> 其实刚好代表 3 种缓动函数类型。其中，<code>linear</code> 是一种匀速运动， 给人的感觉是机械、呆板、没有生机，只有工厂里的机器是保持速度一成不变的！人们喜欢有生命的运动。</p>
<p><code>ease</code>、<code>spring</code> 都是变速运动，那么为什么 <code>spring</code> 的缓动体验要比 <code>ease</code> 更好呢？物理原则是优秀用户体验（UX）的核心原则之一，界面设计遵从物体在真实世界中的运动规律，会让人们感觉更加自然、舒适。</p>
<p><code>spring</code> 是最经典、最常用的物理缓动过程。而 cubic-bezier（三次贝塞尔曲线） 因为具有很强的控制能力，人们可以非常简单、直观地配置一条 <code>y - t</code> 曲线作为缓动过程。因此，<code>spring</code> 和 cubic-bezier（如 <code>ease</code>、<code>ease-in</code>、<code>ease-out</code>、<code>ease-in-out</code>、<code>linear</code>）在动画中最为常用。所以下面先以 <code>spring</code> 为例探讨一种通用的物理缓动的实现方法，然后谈谈如何实现 cubic-bezier 的缓动过程。</p>
<p><strong>2. 物理缓动</strong></p>
<p>根据经典力学的观点，世界上所有的原子每时每刻仿佛都会根据当前速度、受力和位置计算出下一刻的速度、受力和位置。上帝有一台超级计算机吗？非也，计算机反而是我们利用原子的这些特性拼装出来的。不过现在，我们要用计算机，像上帝那样再造一个世界。</p>
<p>物理缓动是模仿现实世界物体运动的缓动，我们可以先模拟物理规律，然后用最简洁的物理法则的表述方式——物理公式来计算物体状态。一个简单的思路跃然纸上：</p>
<ul>
<li><p>在每一帧中对动画对象进行受力分析，计算该帧动画对象的加速度；</p>
</li>
<li><p>如果知道该帧的速度、位置，就可以根据该帧的加速度、速度、位置，计算下一帧的速度、位置；</p>
</li>
<li><p>当我们知道第一帧的速度和位置，就可以像多米诺骨牌那样算出动画对象每一帧的位置！任何物理缓动都可以这样完成！</p>
</li>
</ul>
<p>　</p>
<ul>
<li><p><strong>模拟物理规律</strong></p>
<p>以 <code>spring</code> 为例，我们先来描述一下其物理环境。</p>
<p>有一个弹簧，弹簧上绑了一个砝码，砝码在运动的时候受到空气阻力（空气阻力 <em>F</em><sub>damping</sub>与砝码当前的速度 <em>v<sub>t</sub></em> 呈正相关）。</p>
</li>
<li><p><strong>受力分析</strong></p>
<p>回到初中物理，根据胡克定律，砝码受到弹簧的拉力为:</p>
<p><img src="http://latex.codecogs.com/gif.latex?F_{\rm%20spring}=k\Delta%20x" alt="F_{\rm spring}=k\Delta x">（<em>k</em> 为弹簧的劲度系数）</p>
<p>我们假设该砝码受到的空气阻力的阻尼系数为 <em>k</em><sub>damping</sub>。</p>
<p>对砝码进行受力分析，得到：</p>
<p><img src="http://latex.codecogs.com/gif.latex?F=F_{\rm%20spring}-F_{\rm%20damping}=k_{\rm%20spring}\Delta%20x-k_{\rm%20damping}\times%20v_t" alt="F=F_{\rm spring}-F_{\rm damping}=k_{\rm spring}\Delta x-k_{\rm damping}\times v_t"></p>
</li>
<li><p><strong>建立相邻两帧前后物理状态的关系式</strong></p>
<p>设 <em>a<sub>t</sub></em> 为砝码当前加速度，得到：</p>
<p><img src="http://latex.codecogs.com/gif.latex?F=ma_t" alt="F=ma_t"></p>
<p>设 <img src="http://latex.codecogs.com/gif.latex?v'" alt="v'"> 和 <img src="http://latex.codecogs.com/gif.latex?x'" alt="x'"> 分别为经过 d<em>t</em> 时间后，砝码新的速度和位移，得到：</p>
<p><img src="http://latex.codecogs.com/gif.latex?\begin{aligned}&amp;a_t=\lim_{{\rm%20d}t\to0}\frac{{\rm%20d}v}{{\rm%20d}t}=\lim_{{\rm%20d}t\to0}\frac{v'-v_t}{{\rm%20d}t}\\&amp;v_t=\lim_{{\rm%20d}t\to0}\frac{{\rm%20d}x}{{\rm%20d}t}=\lim_{{\rm%20d}t\to0}\frac{x'-x_t}{{\rm%20d}t}\end{aligned}" alt="\begin{aligned}&amp;a_t=\lim_{{\rm d}t\to0}\frac{{\rm d}v}{{\rm d}t}=\lim_{{\rm d}t\to0}\frac{v'-v_t}{{\rm d}t}\\&amp;v_t=\lim_{{\rm d}t\to0}\frac{{\rm d}x}{{\rm d}t}=\lim_{{\rm d}t\to0}\frac{x'-x_t}{{\rm d}t}\end{aligned}"></p>
<p>即：</p>
<p><img src="http://latex.codecogs.com/gif.latex?\begin{aligned}&amp;v'=\lim_{{\rm%20d}t\to0}a_t*{\rm%20d}t+v_t\\&amp;x'=\lim_{{\rm%20d}t\to0}v_t*{\rm%20d}t+x_t\end{aligned}" alt="\begin{aligned}&amp;v'=\lim_{{\rm d}t\to0}a_t*{\rm d}t+v_t\\&amp;x'=\lim_{{\rm d}t\to0}v_t*{\rm d}t+x_t\end{aligned}"></p>
<p>然而这并不是相邻两帧前后物理状态的关系式子，因为 d<em>t</em> 不是一帧的时间，而是无限小。</p>
<p>幸好我们可以知道当 d<em>t</em> 越趋近于 0 时，等式两边的值越接近（极限的单调有界性）。</p>
<p>别忘了我们不是来做物理实验的，我们的目的是做一个能够骗过人类眼睛的物理运动过程。因此，我们可以把 d<em>t</em> 设置为一个很小的常量值来拟合这个运动过程，把等号变成约等号（设置为常量也是为了降低误差）。</p>
<p>越来越接近了！然而这里还有一个小小的波折：这个很小的常量 d<em>t</em> 的值也不是一帧的时间。简单地说，我们可以用 d<em>t</em> 去拼凑一帧的时间（以下表述为 <img src="http://latex.codecogs.com/gif.latex?\Delta%20t" alt="\Delta t">），如图 2-6 所示。</p>
<p><img src="http://www1.ituring.com.cn/figures/2017/ReactDeep/04.d02z.006.png" alt="{%}"></p>
<p><strong>图 2-6　拼凑帧原理</strong></p>
<p>当 <img src="http://latex.codecogs.com/gif.latex?\Delta%20t" alt="\Delta t">） 不是 d<em>t</em> 的整数倍时，最后多出来的那一小块时间可以用一个简单的插值算法，比如线性插值，来计算那一小块时间的物理状态改变量。</p>
<p>至此，一个简单的 Web 动画物理引擎就实现了。</p>
</li>
</ul>
<p>万变不离其宗，这里 <code>spring</code> 只是一个简单的例子。使用这种通用的模拟物理规律的方法，我们可以实现任意物理动画的缓动，比如一个复杂而炫酷的用 three.js 实现的动画<span class="注释编号">8</span>。</p>
<p class="注释内容"><span class="注释编号下">8</span>webgl animation cloth，详见 <a href="http://threejs.org/examples/#webgl_animation_cloth" target="_blank">http://threejs.org/examples/#webgl_animation_cloth</a>。</p>
<p>现在，我们利用 react-smooth 来实现弹簧动画：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;Animate</span><span class="pln"> </span><span class="atn">from</span><span class="pun">=</span><span class="atv">{{left:</span><span class="pln"> 0}} </span><span class="atn">to</span><span class="pun">=</span><span class="atv">{{left:</span><span class="pln"> 10}} </span><span class="atn">ease</span><span class="pun">=</span><span class="atv">"spring"</span><span class="tag">&gt;</span><span class="pln">
  {style =&gt; </span><span class="tag">&lt;div</span><span class="pln"> </span><span class="atn">style</span><span class="pun">={</span><span class="pln">style</span><span class="pun">}</span><span class="tag">&gt;</span><span class="pln">test</span><span class="tag">&lt;/div&gt;</span><span class="pln">}
</span><span class="tag">&lt;/Animate&gt;</span><span class="pln">
</span></code></pre>
<p>不过说到 <code>spring</code> 动画，不得不提起 react-motion 库。下面是使用 react-motion 库实现一个开关的例子：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Switch</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      open</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  handleClick</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
      open</span><span class="pun">:</span><span class="pln"> </span><span class="pun">!</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">open</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="typ">Motion</span><span class="pln"> style</span><span class="pun">={{</span><span class="pln">x</span><span class="pun">:</span><span class="pln"> spring</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">open </span><span class="pun">?</span><span class="pln"> </span><span class="lit">400</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)}}&gt;</span><span class="pln">
        </span><span class="pun">{({</span><span class="pln">x</span><span class="pun">})</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln">
          </span><span class="pun">&lt;</span><span class="pln">div className</span><span class="pun">=</span><span class="str">"demo"</span><span class="pun">&gt;</span><span class="pln">
            </span><span class="pun">&lt;</span><span class="pln">div
              className</span><span class="pun">=</span><span class="str">"demo-block"</span><span class="pln">
              onClick</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleClick</span><span class="pun">}</span><span class="pln">
              style</span><span class="pun">={{</span><span class="pln">
                transform</span><span class="pun">:</span><span class="pln"> </span><span class="str">`translate3d(${x}px, 0, 0)`</span><span class="pun">,</span><span class="pln">
              </span><span class="pun">}}</span><span class="pln">
            </span><span class="pun">/&gt;</span><span class="pln">
          </span><span class="pun">&lt;</span><span class="str">/div&gt;
        }
      &lt;/</span><span class="typ">Motion</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p><strong>3. cubic-bezier 缓动</strong></p>
<p>物理动画固然炫酷，但是 cubic-bezier 同样是一个非常优秀的缓动过程。</p>
<p>cubic-bezier 可以非常直观、方便地配置一条变速运动的缓动曲线。由于 CSS 原生提供 cubic-bezier 的缓动函数，所以 cubic-bezier 在 Web 动画中得到大量使用。</p>
<p>然而，由于 CSS 这种 DSL 的局限性，我们经常不得不用程序语言来实现一个缓动过程。举一个最简单的例子，由于 CSS 的缓动只能作用于值类型的 CSS 属性，所以假设要根据某种规则对 SVG path 的 <code>d</code> 属性做动画，CSS 便毫无用武之地。此时人们往往会用丑陋的 <code>linear</code> 缓动实现一个 JavaScript 动画，说好的变速运动呢？</p>
<p>因此，有必要用程序语言实现一个 cubic-bezier。</p>
<ul>
<li><p><strong>cubic-bezier 函数表达式</strong></p>
<p>我们先来看看 cubic-bezier 的函数表达式：</p>
<p><img src="http://latex.codecogs.com/gif.latex?(x,y%29=t^3+3t^2(1-t%29\cdot(x_1,y_1%29+3t(1-t%29^2\cdot(x_2,y_2%29+(1-t%29^3" alt="(x,y)=t^3+3t^2(1-t)\cdot(x_1,y_1)+3t(1-t)^2\cdot(x_2,y_2)+(1-t)^3"></p>
<p>乍看之下，我们可能会觉得这个问题非常简单，上式不就是 cubic-bezier 的缓动函数吗？</p>
<p>当然不是这么简单，我想你已经发现了，此 <em>t</em> 非彼 <em>t</em> 。cubic-bezier 的缓动过程的时间是贝塞尔曲线的 <em>x</em> 坐标，也就是式中的 <em>x</em>。</p>
<p>也就是说，我们要根据这个 <img src="http://latex.codecogs.com/gif.latex?(x,y%29=f(t%29" alt="(x,y)=f(t)">（或者说 <img src="http://latex.codecogs.com/gif.latex?x=f_x(t%29,y=f_y(t%29" alt="x=f_x(t),y=f_y(t)">），得到 <em>x</em> → <em>y</em> 的函数。</p>
<p>假设 <img src="http://latex.codecogs.com/gif.latex?x\to%20t:f_x" alt="x\to t:f_x"> 的反函数为 <img src="http://latex.codecogs.com/gif.latex?t\to%20x:g" alt="t\to x:g">，即：</p>
<p><img src="http://latex.codecogs.com/gif.latex?t=g(x%29" alt="t=g(x)"></p>
<p>可得：</p>
<p><img src="http://latex.codecogs.com/gif.latex?y=f_y(t%29=f_y(g(x%29%29" alt="y=f_y(t)=f_y(g(x))"></p>
<p>所以问题简化为求 <em>f<sub>x</sub></em> 的反函数，或者说解方程，可是这个一元三次方程与大多数方程一样，不存在求根公式。所以，我们只能用区间逼近的方法来求近似解。</p>
<p>换成计算机术语来说，任何数学函数都是程序语言中的纯函数，任何纯函数都可以当成一个散列表，表中的键是参数，表中的值是函数返回结果。我们知道 <em>f<sub>x</sub></em> 这个函数都是单调递增的，也就是说，这个表是已经排序的，所以可以用最简单的二分查找方法，不断缩减 <em>t</em> 的范围，从而求出在一定精度内的 <em>t</em> 的值。</p>
<p>为了提高时间复杂度和动画性能，我们可以优化这个区间逼近的方法，即根据曲线的导数（即 <em>x</em> 在某个时刻的变化率）来更合理地逼近区间。</p>
<blockquote>
<p><strong>说明</strong>　读者可以查阅牛顿法<span class="注释编号">9</span>和泰勒级数<span class="注释编号">10</span>的相关数学知识，使用 cubic-bezier 的二阶导和三阶导（四阶导开始为 0），进一步提高时间复杂度。</p>
</blockquote>
<p>或许 CSS 只提供了 cubic-bezier 也是考虑到了其实现较为复杂，属于计算密集型，并不适合用 JavaScript 来实现。但经我们实验统计后发现，JavaScript 版 cubic-bezier 函数平均计算时间仅为 0.33 ms。</p>
<p>利用 react-smooth 实现 cubic-bezier 动画的代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;Animate</span><span class="pln"> </span><span class="atn">from</span><span class="pun">=</span><span class="atv">{{left:</span><span class="pln"> 0}} </span><span class="atn">to</span><span class="pun">=</span><span class="atv">{{left:</span><span class="pln"> 10}} </span><span class="atn">ease</span><span class="pun">=</span><span class="atv">"ease"</span><span class="tag">&gt;</span><span class="pln">
  {style =&gt; </span><span class="tag">&lt;div</span><span class="pln"> </span><span class="atn">style</span><span class="pun">={</span><span class="pln">style</span><span class="pun">}</span><span class="tag">&gt;</span><span class="pln">test</span><span class="tag">&lt;/div&gt;</span><span class="pln">}
</span><span class="tag">&lt;/Animate&gt;</span><span class="pln">
</span></code></pre>
<p>要开发出好的动画，我们不仅要懂动画的设计，要有基本的数值分析及图形图像学知识，更重要的还是要能写出优雅的、可维护的、易扩展的代码。</p>
</li>
</ul>
<p class="注释内容"><span class="注释编号下">9</span>Newton's method，详见 <a href="https://en.wikipedia.org/wiki/Newton%27s_method">https://en.wikipedia.org/wiki/Newton%27s_method</a>。</p>
<p class="注释内容"><span class="注释编号下">10</span>Taylor series，详见 <a href="https://en.wikipedia.org/wiki/Taylor_series">https://en.wikipedia.org/wiki/Taylor_series</a>。</p>
<h2><strong>2.8　自动化测试</strong></h2>
<p>测试可以让项目保持健壮，在后期维护和扩展的过程中，减少犯错的几率。当项目发布时，代码能通过所有测试也代表所覆盖到的场景全部通过。自动化测试就是把整个流程自动化，代替复杂的人工点击。同时通过配置回调钩子，可以让测试定期执行或在每次发布前执行。自动化测试包含很多内容，本节主要指对 React 渲染的 UI 层功能的自动化测试。</p>
<p>写测试之前需要了解测试工具。首先需要一个测试执行器，用于执行测试用例，Mocha 是最流行的测试执行器之一。除此之外，还要使用 Chai 等库来做测试断言。熟悉这两个工具后，我们就可以搭建完整的测试环境了。</p>
<p>React 对测试有完善的支持，目前比较完善的 React 测试框架有 Jest 和 Enzyme，下面会介绍这两个框架。</p>
<h3><strong>2.8.1　Jest</strong></h3>
<p>Jest 是由 Facebook 开源的 React 单元测试框架，内部 DOM 操作基于 JSDOM，语法和断言基于 Jasmine 框架。它有以下 4 个特点：</p>
<ul>
<li><p>自动找到测试；</p>
</li>
<li><p>自动 mock 模拟依赖包，达到单元测试的目的；</p>
</li>
<li><p>并不需要真实 DOM 环境执行，而是 JSDOM 模拟的 DOM；</p>
</li>
<li><p>多进程并行执行测试。</p>
</li>
</ul>
<p>当使用 Jest 来测试 React 组件时，还要引入 react-addons-test-utils 插件，用于模拟浏览器事件和对 DOM 进行校验。它提供的常用方法如下。</p>
<ul>
<li><p><strong><code>Simulate.{eventName} (DOMElement element, [object eventData])</code></strong>：模拟触发事件。</p>
</li>
<li><p><strong><code>renderIntoDocument(ReactElement instance)</code></strong>：渲染 React 组件到文档中，这里的文档节点由 JSDOM 提供。</p>
</li>
<li><p><strong><code>findRenderedDOMComponentWithClass(ReactComponent tree, string className)</code></strong>：从渲染的 DOM 树中查找含有 class 的节点。</p>
</li>
<li><p><strong><code>findRenderedDOMComponentWithTag(ReactComponent tree, function componentClass)</code></strong>：从渲染的 DOM 树中找到指定组件的节点。</p>
</li>
</ul>
<p><strong>1. Jest 实例</strong></p>
<p>我们以第 1 章的 Tabs 组件为例来写一个测试用例。首先，我们需要测试渲染出的 Tab 内容：</p>
<pre class="代码无行号 prettyprint"><code><span class="com">// ./__test__/tab-test.js</span><span class="pln">
jest</span><span class="pun">.</span><span class="pln">unmock</span><span class="pun">(</span><span class="str">'../tab.js'</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">ReactDOM</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-dom'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">TestUtils</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-addons-test-utils'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">Tab</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'../Tab'</span><span class="pun">;</span><span class="pln">

describe</span><span class="pun">(</span><span class="str">'Tab'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  it</span><span class="pun">(</span><span class="str">'render the tab content'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 根据 data 渲染出 Tab 内容</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> tab </span><span class="pun">=</span><span class="pln"> </span><span class="typ">TestUtils</span><span class="pun">.</span><span class="pln">renderIntoDocument</span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="typ">Tabs</span><span class="pln"> classPrefix</span><span class="pun">={</span><span class="str">'tabs'</span><span class="pun">}</span><span class="pln"> defaultActiveIndex</span><span class="pun">={</span><span class="lit">0</span><span class="pun">}</span><span class="pln"> className</span><span class="pun">=</span><span class="str">"ui-tabs"</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">TabPane</span><span class="pln"> order</span><span class="pun">=</span><span class="str">"0"</span><span class="pln"> tab</span><span class="pun">={</span><span class="str">'Tab 1'</span><span class="pun">}&gt;第一个</span><span class="pln"> </span><span class="typ">Tab</span><span class="pln"> </span><span class="pun">里的内容&lt;/</span><span class="typ">TabPane</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">TabPane</span><span class="pln"> order</span><span class="pun">=</span><span class="str">"1"</span><span class="pln"> tab</span><span class="pun">={</span><span class="str">'Tab 2'</span><span class="pun">}&gt;第二个</span><span class="pln"> </span><span class="typ">Tab</span><span class="pln"> </span><span class="pun">里的内容&lt;/</span><span class="typ">TabPane</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">TabPane</span><span class="pln"> order</span><span class="pun">=</span><span class="str">"2"</span><span class="pln"> tab</span><span class="pun">={</span><span class="str">'Tab 3'</span><span class="pun">}&gt;第三个</span><span class="pln"> </span><span class="typ">Tab</span><span class="pln"> </span><span class="pun">里的内容&lt;/</span><span class="typ">TabPane</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="str">/Tabs&gt;
    );

    const tabNode = ReactDOM.findDOMNode(tab);

    /</span><span class="pun">/</span><span class="pln"> </span><span class="pun">验证渲染出</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="pun">个</span><span class="pln"> </span><span class="typ">Tab</span><span class="pln">
    expect</span><span class="pun">(</span><span class="pln">tab</span><span class="pun">.</span><span class="pln">querySelectorAll</span><span class="pun">(</span><span class="str">'.tabs-tab'</span><span class="pun">).</span><span class="pln">length</span><span class="pun">).</span><span class="pln">toEqual</span><span class="pun">(</span><span class="lit">3</span><span class="pun">);</span><span class="pln">
    </span><span class="com">// 验证默认选中第一个 Tab，即索引为 0 的子元素含有 active 的 class</span><span class="pln">
    expect</span><span class="pun">(</span><span class="pln">tab</span><span class="pun">.</span><span class="pln">querySelectorAll</span><span class="pun">(</span><span class="str">'.tabs-tab'</span><span class="pun">)[</span><span class="lit">0</span><span class="pun">].</span><span class="pln">classList</span><span class="pun">.</span><span class="pln">contains</span><span class="pun">(</span><span class="str">'tabs-active'</span><span class="pun">)).</span><span class="pln">toBe</span><span class="pun">(</span><span class="kwd">true</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">
</span><span class="pun">});</span><span class="pln">
</span></code></pre>
<p>验证了渲染后，还需要验证点击后能切换到新的 Tab：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">describe</span><span class="pun">(</span><span class="str">'Tab'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  it</span><span class="pun">(</span><span class="str">'changes active tab after click'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> tab </span><span class="pun">=</span><span class="pln"> </span><span class="typ">TestUtils</span><span class="pun">.</span><span class="pln">renderIntoDocument</span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="typ">Tabs</span><span class="pln"> classPrefix</span><span class="pun">={</span><span class="str">'tabs'</span><span class="pun">}</span><span class="pln"> defaultActiveIndex</span><span class="pun">={</span><span class="lit">0</span><span class="pun">}</span><span class="pln"> className</span><span class="pun">=</span><span class="str">"ui-tabs"</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">TabPane</span><span class="pln"> order</span><span class="pun">=</span><span class="str">"0"</span><span class="pln"> tab</span><span class="pun">={</span><span class="str">'Tab 1'</span><span class="pun">}&gt;第一个</span><span class="pln"> </span><span class="typ">Tab</span><span class="pln"> </span><span class="pun">里的内容&lt;/</span><span class="typ">TabPane</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">TabPane</span><span class="pln"> order</span><span class="pun">=</span><span class="str">"1"</span><span class="pln"> tab</span><span class="pun">={</span><span class="str">'Tab 2'</span><span class="pun">}&gt;第二个</span><span class="pln"> </span><span class="typ">Tab</span><span class="pln"> </span><span class="pun">里的内容&lt;/</span><span class="typ">TabPane</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">TabPane</span><span class="pln"> order</span><span class="pun">=</span><span class="str">"2"</span><span class="pln"> tab</span><span class="pun">={</span><span class="str">'Tab 3'</span><span class="pun">}&gt;第三个</span><span class="pln"> </span><span class="typ">Tab</span><span class="pln"> </span><span class="pun">里的内容&lt;/</span><span class="typ">TabPane</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="str">/Tabs&gt;
    );

    /</span><span class="pun">/</span><span class="pln"> </span><span class="pun">模拟点击第三个标签</span><span class="pln">
    </span><span class="typ">TestUtils</span><span class="pun">.</span><span class="typ">Simulate</span><span class="pun">.</span><span class="pln">click</span><span class="pun">(</span><span class="pln">
      tab</span><span class="pun">.</span><span class="pln">querySelectorAll</span><span class="pun">(</span><span class="str">'.tabs-tab'</span><span class="pun">)[</span><span class="lit">2</span><span class="pun">]</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
    </span><span class="com">// 第一个标签取消选中，第三个标签被选中</span><span class="pln">
    expect</span><span class="pun">(</span><span class="pln">tab</span><span class="pun">.</span><span class="pln">querySelectorAll</span><span class="pun">(</span><span class="str">'.tabs-tab '</span><span class="pun">)[</span><span class="lit">0</span><span class="pun">].</span><span class="pln">classList</span><span class="pun">.</span><span class="pln">contains</span><span class="pun">(</span><span class="str">'tabs-active'</span><span class="pun">)).</span><span class="pln">toBe</span><span class="pun">(</span><span class="kwd">false</span><span class="pun">);</span><span class="pln">
    expect</span><span class="pun">(</span><span class="pln">tab</span><span class="pun">.</span><span class="pln">querySelectorAll</span><span class="pun">(</span><span class="str">'.tabs-tab'</span><span class="pun">)[</span><span class="lit">2</span><span class="pun">].</span><span class="pln">classList</span><span class="pun">.</span><span class="pln">contains</span><span class="pun">(</span><span class="str">'tabs-active'</span><span class="pun">)).</span><span class="pln">toBe</span><span class="pun">(</span><span class="kwd">true</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">
</span><span class="pun">});</span><span class="pln">
</span></code></pre>
<p>综上，使用 Jest 测试组件非常容易。它既可以模拟渲染 DOM 节点，也可以模拟触发 DOM 事件。在大部分情况下，它已经很好用。</p>
<p><strong>2. 浅渲染机制</strong></p>
<p>浅渲染（shallow rendering）很有趣，意思就是只渲染组件中的第一层，这样测试执行器就不需要关心 DOM 和执行环境了。</p>
<p>在实际开发中，组件的层级非常深，所以测试顶层组件时，如果需要把所有子组件全部渲染出来，成本变得非常高。因为 React 组件良好的封装性，测试组件时，大部分测试只需要关注组件本身，它的子组件测试应该在子组件对应的测试代码里做。这样测试执行得很快。</p>
<p>但浅渲染也有天生缺点，它只能测试一级节点。如果要测试子级节点，那就只能做全渲染。</p>
<p>假如一个组件内部有个非常复杂的子组件 ComplexComponent：</p>
<pre class="代码无行号 prettyprint"><code><span class="tag">&lt;div&gt;</span><span class="pln">
  </span><span class="tag">&lt;span</span><span class="pln"> </span><span class="atn">className</span><span class="pun">=</span><span class="atv">"heading"</span><span class="tag">&gt;</span><span class="pln">Title</span><span class="tag">&lt;/span&gt;</span><span class="pln">
  </span><span class="tag">&lt;ComplexComponent</span><span class="pln"> </span><span class="atn">foo</span><span class="pun">=</span><span class="atv">"bar"</span><span class="pln"> </span><span class="tag">/&gt;</span><span class="pln">
</span><span class="tag">&lt;/div&gt;</span><span class="pln">
</span></code></pre>
<p>做浅渲染测试是这样的：</p>
<pre class="代码无行号 prettyprint"><code><span class="pln">let renderer </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactTestUtils</span><span class="pun">.</span><span class="pln">createRenderer</span><span class="pun">();</span><span class="pln">
result </span><span class="pun">=</span><span class="pln"> renderer</span><span class="pun">.</span><span class="pln">getRenderOutput</span><span class="pun">();</span><span class="pln">

expect</span><span class="pun">(</span><span class="pln">result</span><span class="pun">.</span><span class="pln">type</span><span class="pun">).</span><span class="pln">toBe</span><span class="pun">(</span><span class="str">'div'</span><span class="pun">);</span><span class="pln">
expect</span><span class="pun">(</span><span class="pln">result</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">children</span><span class="pun">).</span><span class="pln">toEqual</span><span class="pun">([</span><span class="pln">
  </span><span class="pun">&lt;</span><span class="pln">span className</span><span class="pun">=</span><span class="str">"heading"</span><span class="pun">&gt;</span><span class="typ">Title</span><span class="pun">&lt;</span><span class="str">/span&gt;,
  &lt;ComplexComponent foo="bar" /</span><span class="pun">&gt;,</span><span class="pln">
</span><span class="pun">]);</span><span class="pln">
</span></code></pre>
<p><strong>3. 全渲染机制</strong></p>
<p>全渲染（full rendering）就是完整渲染出当前组件及其所有的子组件，就像在真实浏览器中渲染那样。当组件内部直接改变了 DOM 时，就需要使用全渲染来测试。全渲染需要真实地模拟 DOM 环境，流行的做法有以下几种。</p>
<ul>
<li><p><strong>使用 JSDOM</strong>：使用 JavaScript 模拟 DOM 环境，能满足 90% 的使用场景。这是 Jest 内部所使用的全渲染框架。</p>
</li>
<li><p><strong>使用 Cheerio</strong>：类似 JSDOM，更轻的实现，类似 jQuery 的语法。这是 Enzyme 内部使用的全渲染框架。</p>
</li>
<li><p><strong>使用 Karma</strong>：在真实的浏览器中执行测试，也支持在多个浏览器中依次执行测试，使用的是真实 DOM 环境，但速度稍慢。</p>
</li>
</ul>
<h3><strong>2.8.2　Enzyme</strong></h3>
<p>Enzyme 是由 Airbnb 开源的 React 组件测试框架。与 Jest 相比，Enzyme 提供类似 jQuery 操作 DOM 的语法，在做测试断言时更灵活、易用。React 官方正讨论用 Enzyme 替代 TestUtils，这也许在下一版中就会实现。</p>
<p>Enzyme 提供 3 种不同的方式来测试组件。</p>
<ul>
<li><p><strong>shallow</strong>：推荐的方式，浅渲染，只会渲染本组件内容，引用的外部组件不会渲染，提供更多好的隔离性。</p>
</li>
<li><p><strong>render</strong>：如果 shallow 不能满足，才会使用它。基于 Cheerio 来模拟 DOM 环境（Cheerio 是类似 JSDOM 的另一框架）。</p>
</li>
<li><p><strong>mount</strong>：类似 render，会做全渲染，对于测试生命周期时非常有用。</p>
</li>
</ul>
<p>使用 Enzyme 做上述 Tab 测试的代码如下：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> shallow </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'enzyme'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">Tab</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'../Tab'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> expect </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'chai'</span><span class="pun">;</span><span class="pln">

describe</span><span class="pun">(</span><span class="str">'Tab'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  it</span><span class="pun">(</span><span class="str">'render the tab content'</span><span class="pun">,</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> tab </span><span class="pun">=</span><span class="pln"> shallow</span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="typ">Tabs</span><span class="pln"> classPrefix</span><span class="pun">={</span><span class="str">'tabs'</span><span class="pun">}</span><span class="pln"> defaultActiveIndex</span><span class="pun">={</span><span class="lit">0</span><span class="pun">}</span><span class="pln"> className</span><span class="pun">=</span><span class="str">"ui-tabs"</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">TabPane</span><span class="pln"> order</span><span class="pun">=</span><span class="str">"0"</span><span class="pln"> tab</span><span class="pun">={</span><span class="str">'Tab 1'</span><span class="pun">}&gt;第一个</span><span class="pln"> </span><span class="typ">Tab</span><span class="pln"> </span><span class="pun">里的内容&lt;/</span><span class="typ">TabPane</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">TabPane</span><span class="pln"> order</span><span class="pun">=</span><span class="str">"1"</span><span class="pln"> tab</span><span class="pun">={</span><span class="str">'Tab 2'</span><span class="pun">}&gt;第二个</span><span class="pln"> </span><span class="typ">Tab</span><span class="pln"> </span><span class="pun">里的内容&lt;/</span><span class="typ">TabPane</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">TabPane</span><span class="pln"> order</span><span class="pun">=</span><span class="str">"2"</span><span class="pln"> tab</span><span class="pun">={</span><span class="str">'Tab 3'</span><span class="pun">}&gt;第三个</span><span class="pln"> </span><span class="typ">Tab</span><span class="pln"> </span><span class="pun">里的内容&lt;/</span><span class="typ">TabPane</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="str">/Tabs&gt;
    );

    expect(tab.find('.tabs-tab')).to.have.length(3);
    expect(tab.find('.tabs-tab')[0].hasClass('tabs-active')).to.be.true;
  })

  it('changes active tab after click', () =&gt; {
    const tab = shallow(
      &lt;Tabs classPrefix={'tabs'} defaultActiveIndex={0} className="ui-tabs"&gt;
        &lt;TabPane order="0" tab={'Tab 1'}&gt;第一个 Tab 里的内容&lt;/</span><span class="typ">TabPane</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">TabPane</span><span class="pln"> order</span><span class="pun">=</span><span class="str">"1"</span><span class="pln"> tab</span><span class="pun">={</span><span class="str">'Tab 2'</span><span class="pun">}&gt;第二个</span><span class="pln"> </span><span class="typ">Tab</span><span class="pln"> </span><span class="pun">里的内容&lt;/</span><span class="typ">TabPane</span><span class="pun">&gt;</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="typ">TabPane</span><span class="pln"> order</span><span class="pun">=</span><span class="str">"2"</span><span class="pln"> tab</span><span class="pun">={</span><span class="str">'Tab 3'</span><span class="pun">}&gt;第三个</span><span class="pln"> </span><span class="typ">Tab</span><span class="pln"> </span><span class="pun">里的内容&lt;/</span><span class="typ">TabPane</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="str">/Tabs&gt;
    );

    tab.find('.tabs-tab')[2].simlate('click');
    /</span><span class="pun">/</span><span class="pln"> </span><span class="pun">第一个标签取消选中，第三个标签被选中</span><span class="pln">
    expect</span><span class="pun">(</span><span class="pln">tab</span><span class="pun">.</span><span class="pln">find</span><span class="pun">(</span><span class="str">'.tabs-tab'</span><span class="pun">)[</span><span class="lit">0</span><span class="pun">].</span><span class="pln">hasClass</span><span class="pun">(</span><span class="str">'tabs-active'</span><span class="pun">)).</span><span class="pln">to</span><span class="pun">.</span><span class="pln">be</span><span class="pun">.</span><span class="kwd">false</span><span class="pun">;</span><span class="pln">
    expect</span><span class="pun">(</span><span class="pln">tab</span><span class="pun">.</span><span class="pln">find</span><span class="pun">(</span><span class="str">'.tabs-tab'</span><span class="pun">)[</span><span class="lit">2</span><span class="pun">].</span><span class="pln">hasClass</span><span class="pun">(</span><span class="str">'tabs-active'</span><span class="pun">)).</span><span class="pln">to</span><span class="pun">.</span><span class="pln">be</span><span class="pun">.</span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">});</span><span class="pln">
</span><span class="pun">});</span><span class="pln">
</span></code></pre>
<p>Enzyme shallow 渲染模式可以解决大部分测试问题，而且性能非常好。通过类 jQuery 的 API 来操作 DOM，减少了很多重复代码，比 Jest 更加高效。因此，越来越多的项目正在使用 Enzyme。</p>
<p>最后，为了便于测试，React 组件应该尽可能采用声明式的写法。反过来讲，你也可以根据一个组件是否易于测试来反推代码质量。一个好的 React 组件也一定是易于测试的。测试可以让代码变得更加健壮，后期扩展也更加有信心。</p>
<h3><strong>2.8.3　自动化测试</strong></h3>
<p>现在是时候把整个流程自动化起来了，你需要一个持续集成服务器（CI）来把整个流程自动化。如果使用 GitHub 或 Gitlab 来管理代码，你可以使用 Travis CI 或 Circle CI。</p>
<p>每当有新的 Commit 提交或 PR 发起后，CI 就会自动执行测试，我们可以及时看到测试结果。</p>
<p>在后端工程中，早就流传着“如果这个库没有测试代码，那谁敢用”的话，可见测试在现代软件开发中扮演着越来越重要的角色，前端引入单元测试也是因为复杂客户端应用的大趋势。我们不得不对复杂的交互逻辑进行提前验证，以保证在修改功能时避免主功能上的问题。</p>
<h2><strong>2.9　组件化实例：优化 Tabs 组件</strong></h2>
<p>经过这一章对 React 各个部分的深入介绍，我们试着用所讲的知识对 1.8 节的 Tabs 组件做一次彻底的优化：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">import</span><span class="pln"> </span><span class="typ">React</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Component</span><span class="pun">,</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">,</span><span class="pln"> cloneElement </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">ReactDOM</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-dom'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">EventEmitter</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'events'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> classnames </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'classnames'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="typ">CSSModules</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-css-modules'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Seq</span><span class="pln"> </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'immutable'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> immutableRenderDecorator </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-immutable-render-mixin'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="typ">Motion</span><span class="pun">,</span><span class="pln"> spring </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'react-motion'</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">import</span><span class="pln"> styles </span><span class="kwd">from</span><span class="pln"> </span><span class="str">'./app.scss'</span><span class="pun">;</span><span class="pln">
</span></code></pre>
<p>这次我们引入更多的库，其中包括 Immutable 库、配套的 PureRender 库 react-immutable-render-mixin、简化 CSS Modules 的库 react-css-modules 和动画库 React Motion。</p>
<p>首先，从我们引入的 CSS Modules 讲起，这里使用 react-css-modules 库。经过 webpack 的配置后，Tabs 组件就具备渲染 CSS Modules 的能力了。对应的样式文件最大的变化就是扁平化了：</p>
<pre class="代码无行号 prettyprint"><code><span class="pun">.</span><span class="pln">bar </span><span class="pun">{</span><span class="pln">
  position</span><span class="pun">:</span><span class="pln"> relative</span><span class="pun">;</span><span class="pln">
  margin</span><span class="pun">-</span><span class="pln">bottom</span><span class="pun">:</span><span class="pln"> </span><span class="lit">16px</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="pun">.</span><span class="pln">nav </span><span class="pun">{</span><span class="pln">
  font</span><span class="pun">-</span><span class="pln">size</span><span class="pun">:</span><span class="pln"> </span><span class="lit">14px</span><span class="pun">;</span><span class="pln">

  </span><span class="pun">&amp;:</span><span class="pln">after</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">&amp;:</span><span class="pln">before </span><span class="pun">{</span><span class="pln">
    display</span><span class="pun">:</span><span class="pln"> table</span><span class="pun">;</span><span class="pln">
    content</span><span class="pun">:</span><span class="pln"> </span><span class="str">" "</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  </span><span class="pun">&amp;:</span><span class="pln">after </span><span class="pun">{</span><span class="pln">
    clear</span><span class="pun">:</span><span class="pln"> both</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="pun">.</span><span class="pln">tab </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">float</span><span class="pun">:</span><span class="pln"> left</span><span class="pun">;</span><span class="pln">
  list</span><span class="pun">-</span><span class="pln">style</span><span class="pun">:</span><span class="pln"> none</span><span class="pun">;</span><span class="pln">
  margin</span><span class="pun">-</span><span class="pln">right</span><span class="pun">:</span><span class="pln"> </span><span class="lit">24px</span><span class="pun">;</span><span class="pln">
  padding</span><span class="pun">:</span><span class="pln"> </span><span class="lit">8px</span><span class="pln"> </span><span class="lit">20px</span><span class="pun">;</span><span class="pln">
  text</span><span class="pun">-</span><span class="pln">decoration</span><span class="pun">:</span><span class="pln"> none</span><span class="pun">;</span><span class="pln">
  color</span><span class="pun">:</span><span class="pln"> </span><span class="com">#666;</span><span class="pln">
  cursor</span><span class="pun">:</span><span class="pln"> pointer</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="pun">.</span><span class="pln">tabActive </span><span class="pun">{</span><span class="pln">
  color</span><span class="pun">:</span><span class="pln"> </span><span class="com">#00C49F;</span><span class="pln">
  cursor</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">default</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="pun">.</span><span class="pln">panel </span><span class="pun">{</span><span class="pln">
  display</span><span class="pun">:</span><span class="pln"> none</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="pun">.</span><span class="pln">content </span><span class="pun">{</span><span class="pln">
  display</span><span class="pun">:</span><span class="pln"> block</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="pun">.</span><span class="pln">contentActive </span><span class="pun">{</span><span class="pln">
  display</span><span class="pun">:</span><span class="pln"> block</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="pun">.</span><span class="pln">inkBar </span><span class="pun">{</span><span class="pln">
  position</span><span class="pun">:</span><span class="pln"> absolute</span><span class="pun">;</span><span class="pln">
  left</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
  bottom</span><span class="pun">:</span><span class="pln"> </span><span class="lit">1px</span><span class="pun">;</span><span class="pln">
  box</span><span class="pun">-</span><span class="pln">sizing</span><span class="pun">:</span><span class="pln"> border</span><span class="pun">-</span><span class="pln">box</span><span class="pun">;</span><span class="pln">
  height</span><span class="pun">:</span><span class="pln"> </span><span class="lit">2px</span><span class="pun">;</span><span class="pln">
  background</span><span class="pun">-</span><span class="pln">color</span><span class="pun">:</span><span class="pln"> </span><span class="com">#00C49F;</span><span class="pln">
  z</span><span class="pun">-</span><span class="pln">index</span><span class="pun">:</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>在 JSX 中，只要使用 <code>styleName</code> prop 来设置对应的 <code>key</code> 即可。我们直接看 TabPane 组件使用 CSS Modules 的例子：</p>
<pre class="代码无行号 prettyprint"><code><span class="lit">@immutableRenderDecorator</span><span class="pln">
</span><span class="lit">@CSSModules</span><span class="pun">(</span><span class="pln">styles</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> allowMultiple</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">})</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">TabPane</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> propTypes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    tab</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">oneOfType</span><span class="pun">([</span><span class="pln">
      </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">string</span><span class="pun">,</span><span class="pln">
      </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">node</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">]).</span><span class="pln">isRequired</span><span class="pun">,</span><span class="pln">
    order</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">string</span><span class="pun">.</span><span class="pln">isRequired</span><span class="pun">,</span><span class="pln">
    disable</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">bool</span><span class="pun">,</span><span class="pln">
    isActive</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">bool</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> className</span><span class="pun">,</span><span class="pln"> isActive</span><span class="pun">,</span><span class="pln"> children </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">const</span><span class="pln"> classes </span><span class="pun">=</span><span class="pln"> classnames</span><span class="pun">({</span><span class="pln">
      panel</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln">
      contentActive</span><span class="pun">:</span><span class="pln"> isActive</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="pln">div
        role</span><span class="pun">=</span><span class="str">"tabpanel"</span><span class="pln">
        styleName</span><span class="pun">={</span><span class="pln">classes</span><span class="pun">}</span><span class="pln">
        aria</span><span class="pun">-</span><span class="pln">hidden</span><span class="pun">={!</span><span class="pln">isActive</span><span class="pun">}&gt;</span><span class="pln">
        </span><span class="pun">{</span><span class="pln">children</span><span class="pun">}</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>此外，我们看到 immutableRenderDecorator 和 CSSModules 是两个高阶组件。需要说明的是，对于与组件主体功能无关的抽象，我们一般都用高阶组件来抽象。</p>
<p>对 TabPane 的父组件 TabContent 的改写，也采用类似的方式：</p>
<pre class="代码无行号 prettyprint"><code><span class="lit">@immutableRenderDecorator</span><span class="pln">
</span><span class="lit">@CSSModules</span><span class="pun">(</span><span class="pln">styles</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> allowMultiple</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">})</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">TabContent</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> propTypes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    panels</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">object</span><span class="pun">,</span><span class="pln">
    activeIndex</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">number</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">

  getTabPanes</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> activeIndex</span><span class="pun">,</span><span class="pln"> panels </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> panels</span><span class="pun">.</span><span class="pln">map</span><span class="pun">((</span><span class="pln">child</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">child</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln">

      </span><span class="kwd">const</span><span class="pln"> order </span><span class="pun">=</span><span class="pln"> parseInt</span><span class="pun">(</span><span class="pln">child</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">order</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">);</span><span class="pln">
      </span><span class="kwd">const</span><span class="pln"> isActive </span><span class="pun">=</span><span class="pln"> activeIndex </span><span class="pun">===</span><span class="pln"> order</span><span class="pun">;</span><span class="pln">

      </span><span class="kwd">return</span><span class="pln"> </span><span class="typ">React</span><span class="pun">.</span><span class="pln">cloneElement</span><span class="pun">(</span><span class="pln">child</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        isActive</span><span class="pun">,</span><span class="pln">
        children</span><span class="pun">:</span><span class="pln"> child</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">children</span><span class="pun">,</span><span class="pln">
        key</span><span class="pun">:</span><span class="pln"> </span><span class="str">`tabpane-${order}`</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">});</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> classes </span><span class="pun">=</span><span class="pln"> classnames</span><span class="pun">({</span><span class="pln">
      content</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="pln">div styleName</span><span class="pun">={</span><span class="pln">classes</span><span class="pun">}&gt;</span><span class="pln">
        </span><span class="pun">{</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">getTabPanes</span><span class="pun">()}</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>接着，我们来看 TabNav 组件，一个显著的更新是对其增加了动画效果，即对切换到当前选中的 tab 标签的下划线做了滑动效果。这里利用了 React Motion 库来实现：</p>
<pre class="代码无行号 prettyprint"><code><span class="kwd">function</span><span class="pln"> getOuterWidth</span><span class="pun">(</span><span class="pln">el</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> el</span><span class="pun">.</span><span class="pln">offsetWidth</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">function</span><span class="pln"> getOffset</span><span class="pun">(</span><span class="pln">el</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> html </span><span class="pun">=</span><span class="pln"> el</span><span class="pun">.</span><span class="pln">ownerDocument</span><span class="pun">.</span><span class="pln">documentElement</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">const</span><span class="pln"> box </span><span class="pun">=</span><span class="pln"> el</span><span class="pun">.</span><span class="pln">getBoundingClientRect</span><span class="pun">();</span><span class="pln">

  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    top</span><span class="pun">:</span><span class="pln"> box</span><span class="pun">.</span><span class="pln">top </span><span class="pun">+</span><span class="pln"> window</span><span class="pun">.</span><span class="pln">pageYOffset </span><span class="pun">-</span><span class="pln"> html</span><span class="pun">.</span><span class="pln">clientTop</span><span class="pun">,</span><span class="pln">
    left</span><span class="pun">:</span><span class="pln"> box</span><span class="pun">.</span><span class="pln">left </span><span class="pun">+</span><span class="pln"> window</span><span class="pun">.</span><span class="pln">pageXOffset </span><span class="pun">-</span><span class="pln"> html</span><span class="pun">.</span><span class="pln">clientLeft</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="lit">@immutableRenderDecorator</span><span class="pln">
</span><span class="lit">@CSSModules</span><span class="pun">(</span><span class="pln">styles</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> allowMultiple</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">})</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">TabNav</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> propTypes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    panels</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="kwd">object</span><span class="pun">,</span><span class="pln">
    activeIndex</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">number</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">

  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      inkBarWidth</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln">
      inkBarLeft</span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  componentDidMount</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="com">// 计算激活 tab 的宽度和相对屏幕的左侧位置</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> activeIndex </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> node </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactDOM</span><span class="pun">.</span><span class="pln">findDOMNode</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> el </span><span class="pun">=</span><span class="pln"> node</span><span class="pun">.</span><span class="pln">querySelectorAll</span><span class="pun">(</span><span class="str">'li'</span><span class="pun">)[</span><span class="pln">activeIndex</span><span class="pun">];</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
      inkBarWidth</span><span class="pun">:</span><span class="pln"> getOuterWidth</span><span class="pun">(</span><span class="pln">el</span><span class="pun">),</span><span class="pln">
      inkBarLeft</span><span class="pun">:</span><span class="pln"> getOffset</span><span class="pun">(</span><span class="pln">el</span><span class="pun">).</span><span class="pln">left</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  componentDidUpdate</span><span class="pun">(</span><span class="pln">prevProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">prevProps</span><span class="pun">.</span><span class="pln">activeIndex </span><span class="pun">!==</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">activeIndex</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> activeIndex </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
      </span><span class="kwd">const</span><span class="pln"> node </span><span class="pun">=</span><span class="pln"> </span><span class="typ">ReactDOM</span><span class="pun">.</span><span class="pln">findDOMNode</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
      </span><span class="kwd">const</span><span class="pln"> el </span><span class="pun">=</span><span class="pln"> node</span><span class="pun">.</span><span class="pln">querySelectorAll</span><span class="pun">(</span><span class="str">'li'</span><span class="pun">)[</span><span class="pln">activeIndex</span><span class="pun">];</span><span class="pln">

      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
        inkBarWidth</span><span class="pun">:</span><span class="pln"> getOuterWidth</span><span class="pun">(</span><span class="pln">el</span><span class="pun">),</span><span class="pln">
        inkBarLeft</span><span class="pun">:</span><span class="pln"> getOffset</span><span class="pun">(</span><span class="pln">el</span><span class="pun">).</span><span class="pln">left</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">});</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  getTabs</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> panels</span><span class="pun">,</span><span class="pln"> activeIndex </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">

    </span><span class="com">// children 经过 Immutable 转换后，需要使用 Immutable API 遍历</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> panels</span><span class="pun">.</span><span class="pln">map</span><span class="pun">((</span><span class="pln">child</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">child</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="kwd">return</span><span class="pun">;</span><span class="pln"> </span><span class="pun">}</span><span class="pln">

      </span><span class="kwd">const</span><span class="pln"> order </span><span class="pun">=</span><span class="pln"> parseInt</span><span class="pun">(</span><span class="pln">child</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">order</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">);</span><span class="pln">

      let classes </span><span class="pun">=</span><span class="pln"> classnames</span><span class="pun">({</span><span class="pln">
        tab</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln">
        tabActive</span><span class="pun">:</span><span class="pln"> activeIndex </span><span class="pun">===</span><span class="pln"> order</span><span class="pun">,</span><span class="pln">
        disabled</span><span class="pun">:</span><span class="pln"> child</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">disabled</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">});</span><span class="pln">

      let events </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{};</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">child</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">disabled</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        events </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
          onClick</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">onTabClick</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">,</span><span class="pln"> order</span><span class="pun">),</span><span class="pln">
        </span><span class="pun">};</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">

      </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">ref</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{};</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">activeIndex </span><span class="pun">===</span><span class="pln"> order</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">ref</span><span class="pun">.</span><span class="kwd">ref</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">'activeTab'</span><span class="pun">;</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">

      </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="pln">li
          role</span><span class="pun">=</span><span class="str">"tab"</span><span class="pln">
          aria</span><span class="pun">-</span><span class="pln">disabled</span><span class="pun">={</span><span class="pln">child</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">disabled </span><span class="pun">?</span><span class="pln"> </span><span class="str">'true'</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="str">'false'</span><span class="pun">}</span><span class="pln">
          aria</span><span class="pun">-</span><span class="pln">selected</span><span class="pun">={</span><span class="pln">activeIndex </span><span class="pun">===</span><span class="pln"> order</span><span class="pun">?</span><span class="pln"> </span><span class="str">'true'</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="str">'false'</span><span class="pun">}</span><span class="pln">
          </span><span class="pun">{...</span><span class="pln">events</span><span class="pun">}</span><span class="pln">
          styleName</span><span class="pun">={</span><span class="pln">classes</span><span class="pun">}</span><span class="pln">
          key</span><span class="pun">={</span><span class="pln">order</span><span class="pun">}</span><span class="pln">
          </span><span class="pun">{...</span><span class="kwd">ref</span><span class="pun">}</span><span class="pln">
        </span><span class="pun">&gt;</span><span class="pln">
          </span><span class="pun">{</span><span class="pln">child</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">tab</span><span class="pun">}</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="str">/li&gt;
      );
    });
  }

  render() {
    const { activeIndex } = this.props;

    const rootClasses = classnames({
      bar: true,
    });

    const classes = classnames({
      nav: true,
    });

    return (
      &lt;div styleName={rootClasses} role="tablist"&gt;
        &lt;Motion style={{ left: spring(this.state.inkBarLeft) }}&gt;
          {({ left }) =&gt; &lt;InkBar width={this.state.inkBarWidth} left={left} /</span><span class="pun">&gt;}</span><span class="pln">
        </span><span class="pun">&lt;</span><span class="str">/Motion&gt;
        &lt;ul styleName={classes}&gt;
          {this.getTabs()}
        &lt;/</span><span class="pln">ul</span><span class="pun">&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>对于这个效果，我们只是在改变它的样式，只需要改变滑动条的横向距离即可。但在这里我们没有用 <code>left</code> 属性，而是利用了 CSS 的 <code>translate3d</code> 启用 GPU 来加速动画的渲染效率：</p>
<pre class="代码无行号 prettyprint"><code><span class="lit">@immutableRenderDecorator</span><span class="pln">
</span><span class="lit">@CSSModules</span><span class="pun">(</span><span class="pln">styles</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> allowMultiple</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">})</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">InkBar</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> propTypes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    left</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">number</span><span class="pun">,</span><span class="pln">
    width</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">number</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> left</span><span class="pun">,</span><span class="pln"> width </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">const</span><span class="pln"> classes </span><span class="pun">=</span><span class="pln"> classnames</span><span class="pun">({</span><span class="pln">
      inkBar</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">});</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="pln">div styleName</span><span class="pun">={</span><span class="pln">classes</span><span class="pun">}</span><span class="pln"> style</span><span class="pun">={{</span><span class="pln">
        </span><span class="typ">WebkitTransform</span><span class="pun">:</span><span class="pln"> </span><span class="str">`translate3d(${left}px, 0, 0)`</span><span class="pun">,</span><span class="pln">
        transform</span><span class="pun">:</span><span class="pln"> </span><span class="str">`translate3d(${left}px, 0, 0)`</span><span class="pun">,</span><span class="pln">
        width</span><span class="pun">:</span><span class="pln"> width</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">}}&gt;</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>最后是 Tabs 组件的实现，它利用了 Immutable 的 <code>Seq</code> 封装了原来的 <code>children</code> 数组：</p>
<pre class="代码无行号 prettyprint"><code><span class="lit">@immutableRenderDecorator</span><span class="pln">
</span><span class="lit">@CSSModules</span><span class="pun">(</span><span class="pln">styles</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> allowMultiple</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">true</span><span class="pln"> </span><span class="pun">})</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Tabs</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Component</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">static</span><span class="pln"> propTypes </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    children</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">oneOfType</span><span class="pun">([</span><span class="pln">
      </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">arrayOf</span><span class="pun">(</span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">node</span><span class="pun">),</span><span class="pln">
      </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">node</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">]),</span><span class="pln">
    defaultActiveIndex</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">number</span><span class="pun">,</span><span class="pln">
    activeIndex</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">number</span><span class="pun">,</span><span class="pln">
    onChange</span><span class="pun">:</span><span class="pln"> </span><span class="typ">PropTypes</span><span class="pun">.</span><span class="pln">func</span><span class="pun">,</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">

  </span><span class="kwd">static</span><span class="pln"> defaultProps </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    onChange</span><span class="pun">:</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">{},</span><span class="pln">
  </span><span class="pun">};</span><span class="pln">

  constructor</span><span class="pun">(</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">props</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleTabClick </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleTabClick</span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">);</span><span class="pln">
    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">immChildren </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Seq</span><span class="pun">(</span><span class="pln">currProps</span><span class="pun">.</span><span class="pln">children</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">const</span><span class="pln"> currProps </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">

    let activeIndex</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="str">'activeIndex'</span><span class="pln"> </span><span class="kwd">in</span><span class="pln"> currProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      activeIndex </span><span class="pun">=</span><span class="pln"> currProps</span><span class="pun">.</span><span class="pln">activeIndex</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="str">'defaultActiveIndex'</span><span class="pln"> </span><span class="kwd">in</span><span class="pln"> currProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      activeIndex </span><span class="pun">=</span><span class="pln"> currProps</span><span class="pun">.</span><span class="pln">defaultActiveIndex</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">

    </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      activeIndex</span><span class="pun">,</span><span class="pln">
      prevIndex</span><span class="pun">:</span><span class="pln"> activeIndex</span><span class="pun">,</span><span class="pln">
    </span><span class="pun">};</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  componentWillReceiveProps</span><span class="pun">(</span><span class="pln">nextProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="str">'activeIndex'</span><span class="pln"> </span><span class="kwd">in</span><span class="pln"> nextProps</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
        activeIndex</span><span class="pun">:</span><span class="pln"> nextProps</span><span class="pun">.</span><span class="pln">activeIndex</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">});</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  handleTabClick</span><span class="pun">(</span><span class="pln">activeIndex</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> prevIndex </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">activeIndex</span><span class="pun">;</span><span class="pln">

    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">activeIndex </span><span class="pun">!==</span><span class="pln"> activeIndex </span><span class="pun">&amp;&amp;</span><span class="pln">
        </span><span class="str">'defaultActiveIndex'</span><span class="pln"> </span><span class="kwd">in</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">setState</span><span class="pun">({</span><span class="pln">
        activeIndex</span><span class="pun">,</span><span class="pln">
        prevIndex</span><span class="pun">,</span><span class="pln">
      </span><span class="pun">});</span><span class="pln">

      </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">.</span><span class="pln">onChange</span><span class="pun">({</span><span class="pln"> activeIndex</span><span class="pun">,</span><span class="pln"> prevIndex </span><span class="pun">});</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  renderTabNav</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="typ">TabNav</span><span class="pln">
        key</span><span class="pun">=</span><span class="str">"tabBar"</span><span class="pln">
        onTabClick</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">handleTabClick</span><span class="pun">}</span><span class="pln">
        panels</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">immChildren</span><span class="pun">}</span><span class="pln">
        activeIndex</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">activeIndex</span><span class="pun">}</span><span class="pln">
      </span><span class="pun">/&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  renderTabContent</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="typ">TabContent</span><span class="pln">
        key</span><span class="pun">=</span><span class="str">"tabcontent"</span><span class="pln">
        activeIndex</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">state</span><span class="pun">.</span><span class="pln">activeIndex</span><span class="pun">}</span><span class="pln">
        panels</span><span class="pun">={</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">immChildren</span><span class="pun">}</span><span class="pln">
      </span><span class="pun">/&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

  render</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> className </span><span class="pun">}</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">props</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">const</span><span class="pln"> classes </span><span class="pun">=</span><span class="pln"> classnames</span><span class="pun">(</span><span class="pln">className</span><span class="pun">,</span><span class="pln"> </span><span class="str">'ui-tabs'</span><span class="pun">);</span><span class="pln">

    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(</span><span class="pln">
      </span><span class="pun">&lt;</span><span class="pln">div className</span><span class="pun">={</span><span class="pln">classes</span><span class="pun">}&gt;</span><span class="pln">
        </span><span class="pun">{</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">renderTabNav</span><span class="pun">()}</span><span class="pln">
        </span><span class="pun">{</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">renderTabContent</span><span class="pun">()}</span><span class="pln">
      </span><span class="pun">&lt;/</span><span class="pln">div</span><span class="pun">&gt;</span><span class="pln">
    </span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span></code></pre>
<p>之前我们也讲到，对于数组或对象类型的 props 而言，优化的最直接手段就是使用 Immutable。经过测试，Tabs 组件大大减少了无意义的渲染次数。</p>
<p>自此，Tabs 组件的优化就告一段落了。你有没有发现原 Tabs 组件是可以设置 <code>classPrefix</code> 以表达主题？在 CSS Modules 中，这是怎么表达的呢？这个问题留给你思考。</p>
<h2><strong>2.10　小结</strong></h2>
<p>本章通过深入介绍 React 的概念及特性，让开发者从方方面面去熟悉它，最终通过优化 Tabs组件让开发者对 React 组件开发有一个全面的认识并具备实践的能力。随着 React 的不停发展，相关内容一定还会更新，但基本思路从 React 诞生以来就没有变化过。希望读者可以从这些内容中举一反三，实践出开发组件的最佳方法，然后运用于生产中，并与整个社区分享。</p>

